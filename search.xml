<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划之01背包问题（一）</title>
      <link href="2021/12/31/1231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/12/31/1231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-01背包dp-N-V-1-（第一讲）"><a href="#1-01背包dp-N-V-1-（第一讲）" class="headerlink" title="1.01背包dp[N] [V+1]（第一讲）"></a>1.01背包dp[N] [V+1]（第一讲）</h1><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的体积是 v[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大，求出最大总价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 3, V &#x3D; 5, v &#x3D; [4,2,3], w &#x3D; [4,2,3]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。</span><br></pre></td></tr></table></figure><p>考虑上面的这个输入，我们用表格来思考一下，我们考虑放入前i件物品获得的最大价值是多少</p><table><thead><tr><th>i\V</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4</td><td>4</td></tr><tr><td>2</td><td>0</td><td>0</td><td>2</td><td>2</td><td>4</td><td>4</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td></tr></tbody></table><blockquote><p>定义状态</p></blockquote><p>前n个物品的在提及V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题，定义dp[i] [j] 为前i个物品放入到体积为j的背包中可以获得的最大价值。</p><blockquote><p>状态方程</p></blockquote><p>对于每个<strong>物品i（体积v[i]价值w[i]）</strong>我们都有两种选择：<strong>放入背包或不放入背包</strong>，是否放入取决于两个条件，第一：背包的容量是否足够；第二：放入之后的总价值与不放入到总价值哪个更大。</p><ul><li><strong>空间不足的时候</strong>，第i个物品放不进去，那么最大价值就是前i-1个物品的价值：<ul><li>dp[i] [j] = dp[i-1] [j]</li></ul></li><li><strong>空间充足的时候</strong>，能够放入第i个物品，但是我们必须要判断是选择放还是不放，<strong>判断的依据就是不放进去和放进去的价值大小</strong>，并选择两者中较大者：<ul><li>不放为：dp[i-1] [j]</li><li>放进去为：dp[i-1] [j - v[i]] + w[i] （因为要放进去，所以留给前i-1个物品的大小只有j-v[i]了，然后再加上w[i]）</li><li>最终dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j - v[i]] + w[i])</li></ul></li></ul><blockquote><p>边界条件</p></blockquote><p>当只放入第一件物品的时候，只需要判断当前的空间j是否能够放入v[0]即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">self, N, V, v, w</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j] = w[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; v[i]:</span><br><span class="line">                    <span class="comment"># 空间不足</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 空间充足</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-v[i]] + w[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][V]</span><br></pre></td></tr></table></figure><h1 id="2-01背包优化为二维dp-2-V-1"><a href="#2-01背包优化为二维dp-2-V-1" class="headerlink" title="2.01背包优化为二维dp[2] [V+1]"></a>2.01背包优化为二维dp[2] [V+1]</h1><p>通过上面的表格我们可以发现，当前行的结果只与上一行的结果有关，因此我们可以用一个二维数组来保存结果，这样可以更加节省空间。只需要判断当前行是奇数行还是偶数行即可，这里我们用的是i &amp; 1 这个操作，也可以用i%2这个来做判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> j &gt;= v[<span class="number">0</span>]:</span><br><span class="line">            dp[<span class="number">0</span>][j] = w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 空间不足</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; v[i]:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-v[i]] + w[i])</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][V]</span><br></pre></td></tr></table></figure><h1 id="3-01背包优化一维dp-V-1"><a href="#3-01背包优化一维dp-V-1" class="headerlink" title="3.01背包优化一维dp[V+1]"></a>3.01背包优化一维dp[V+1]</h1><p>根据状态转移方程 $dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j - v[i]] + w[i])$ 我们可以看出，dp[i] [j]只与dp[i-1] [j] 、dp[i-1] [j - v[i]] 这两个元素相关，<strong>即第i行的数值只与第i-1行的<u>第j个格子以及第j-v[i]个格子相关</u>。</strong></p><p>对于第i行，我们此时遍历的顺序是从0到V，只需要改为从V到0就可以不用到这两个元素，这样就可以从二维降低到一维。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-v[i]] + w[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="4-416-分割等和子集"><a href="#4-416-分割等和子集" class="headerlink" title="4.416. 分割等和子集"></a>4.<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 100</p><p>我们以这个题目为例，来体验一下01背包问题的三种解法，把思路再过一遍。</p><h2 id="第一种解法：dp-N-V-1-解法"><a href="#第一种解法：dp-N-V-1-解法" class="headerlink" title="第一种解法：dp[N] [V+1]解法"></a>第一种解法：dp[N] [V+1]解法</h2><ul><li>因为需要把一个数组分成两个等和子集，所以数组之和必须是偶数才能够保证分成两个，每个子集的和定义为target；</li><li>然后接下来的过程就是从数组中可以选元素，但是我们背包的大小是target；</li><li>状态转移函数和边界条件都和上面的推理过程一样；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-nums[i]] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="第二种解法：dp-2-V-1-解法"><a href="#第二种解法：dp-2-V-1-解法" class="headerlink" title="第二种解法：dp[2] [V+1]解法"></a>第二种解法：dp[2] [V+1]解法</h2><p>这种解法只需要在前者的基础上加一个判断i为0还是1即可；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-nums[i]] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="第三种解法：dp-V-1-解法"><a href="#第三种解法：dp-V-1-解法" class="headerlink" title="第三种解法：dp [V+1]解法"></a>第三种解法：dp [V+1]解法</h2><p>这是第三种解法，依然类似与上面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h2><p>由于题目只需要返回能否分割等和子集（true or false）因此在我们定义dp数组的时候可以定义为bool类型，这样可以节省计算的时间；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-nums[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-494-目标和"><a href="#5-494-目标和" class="headerlink" title="5.494. 目标和"></a>5.<a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 20<br>0 &lt;= nums[i] &lt;= 1000<br>0 &lt;= sum(nums[i]) &lt;= 1000<br>-1000 &lt;= target &lt;= 1000</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>问题转换</p></blockquote><p>因为需要向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，所以最终我们得到的结果就是：正数之和+负数之和==target。<br>我们假设P是正子集，N是负子集，sum(P)代表正子集之和，sum(N)代表负子集之和。<br>例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]。</p><p>那么让我们看看如何将其转换为子集求和问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                  sum(P) - sum(N) &#x3D; target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) &#x3D; target + sum(nums)</span><br></pre></td></tr></table></figure><p>最终，我们可以得到sum(P)=(target + sum(nums))/2，<strong>所以我们的最终问题转换为求从数组nums中找到一组数，让其之和为sum(P)。</strong></p><blockquote><p>需要注意几个条件：</p></blockquote><p>第一：因为数组都是整数，所以target + sum(nums)必须是偶数；<br>第二：targe可能为负数，所以sum(nums)&lt;abs(target)即数组之和小于target的绝对值，例如：nums = [200], target=-100就是无法满足，返回0；（target为负数这个条件应该是题目最近新改的，我看很多题解都没有考虑到这个）</p><blockquote><p>状态转移</p></blockquote><p>动态规划定义dp长度为sum(P) + 1即可；<br>定义dp[j]为组成和为j的组合又dp[j]种， dp[j] += dp[j-nums[i]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        sum_ = sum(nums) + target</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> <span class="keyword">or</span> sum(nums) &lt; abs(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, nums[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] += dp[j-nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>此为本人学习笔记，整理方便回顾，会参考到部分博主，尽可能会一一列明，如有遗漏请见谅。</p><p>参考资料：</p><p>宫水三叶的相关题解以及LeetCode相关题解</p><p><a href="https://blog.csdn.net/weixin_45594025/article/details/106112195">https://blog.csdn.net/weixin_45594025/article/details/106112195</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解回溯算法</title>
      <link href="2021/12/29/1229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2021/12/29/1229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h1><p>回溯算法需要考虑三个问题：</p><ul><li>结束条件：递归在什么时候终止，返回结果；</li><li>已有路径：已经加入到结果中的元素；</li><li>待选路径：还有哪些元素可以加入到路径中来；</li></ul><p>核心有两个，一个是什么时候结束，一个是什么时候做选择以及回溯（递归）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">res = [] <span class="comment"># 记录中间结果（保存路径）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">res, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(res)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        res.append(选择)</span><br><span class="line">        backtrack(res, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        res.pop()</span><br></pre></td></tr></table></figure><h1 id="以46-全排列为例分析："><a href="#以46-全排列为例分析：" class="headerlink" title="以46. 全排列为例分析："></a>以<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>为例分析：</h1><img src="/2021/12/29/1229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.png" class><p>当输入为nums = [1,2,3]，我们进行全排列的过程是：首先固定第一个元素，然后在剩下的元素里选择一个固定第二个元素，最后固定第三个元素。例如，首先选择1作为第一个元素，然后就只有2、3可以作为第二个元素，如果选择2作为第二个元素，就只有3可以作为第三个元素；反之如果选择3作为第二个元素，就只有2作为第三个元素。</p><p>我们看一下这一题的三个问题：</p><ul><li><p>首先是结束条件：如果遍历到第三个元素说明递归终止；</p></li><li><p>其次是已有路径：当前元素如果是2，我们想要把当前元素选3，只需要交换2和3即可；</p></li><li><p>最后是待选路径：待选路径就是nums中没有加入到已有路径中的元素；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bacaktrack</span>():</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> len(res) == n:</span><br><span class="line">              <span class="comment"># 结束条件，长度为n的时候结束</span></span><br><span class="line">                result.append(res[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                  <span class="comment"># 做选择前需要判断nums[i]是否已经加入到res中，如果没有加入就选择加入</span></span><br><span class="line">                  <span class="comment"># 做选择</span></span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    bacaktrack()</span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    res.pop()</span><br><span class="line">        result = []<span class="comment"># result保存最终结果</span></span><br><span class="line">        res = []<span class="comment"># res 保存中间结果</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        bacaktrack()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上面的代码可以优化一下，因为我们得到的最终结果只需要在nums中进行交换元素即可，不需要每次都从头遍历保存在res中，这样既可以节省时间也可以节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bacaktrack</span>(<span class="params">start</span>):</span></span><br><span class="line">          <span class="comment"># start表示下一次递归从nums中的开始位置</span></span><br><span class="line">            <span class="keyword">if</span> start == n:</span><br><span class="line">              <span class="comment"># 结束条件，如果开始位置start==n结束为止就终止</span></span><br><span class="line">                result.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n):</span><br><span class="line">              <span class="comment"># 做选择（把start开始位置与i位置交换元素）</span></span><br><span class="line">                nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">                bacaktrack(start + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销选择（两次交换就相当于撤销选择了）</span></span><br><span class="line">                nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">        result = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        bacaktrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关题目目录"><a href="#相关题目目录" class="headerlink" title="相关题目目录"></a>相关题目目录</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></p><p><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></p><p><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></p><p><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></p><p>题目还有很多，可以直接去回溯标签下找一些，做几个熟悉一下即可。</p><p>参考文献：<a href="https://www.cnblogs.com/looyee/articles/12084932.html">https://www.cnblogs.com/looyee/articles/12084932.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二叉树的层序遍历</title>
      <link href="2021/12/27/1227-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/12/27/1227-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-层序遍历讲解"><a href="#1-层序遍历讲解" class="headerlink" title="1.层序遍历讲解"></a>1.层序遍历讲解</h1><blockquote><p>基本用法</p></blockquote><p>层序遍历就是按二叉树从上到下，从左到右依次访问每个节点。</p><ul><li>首先将二叉树的根节点push到队列中，判断队列不为NULL，就输出队头的元素， </li><li>判断节点如果有孩子，就将孩子push到队列中， </li><li>遍历过的节点出队列， </li><li>循环以上操作，直到Tree == NULL。</li></ul><p>在使用python实现的过程中，我可以借助列表来模拟队列操作；在每次访问队头元素的时候，可以用pop(0)来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                nodeQueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>进阶用法</p></blockquote><h4 id="102-叉树的层序遍历"><a href="#102-叉树的层序遍历" class="headerlink" title="102.叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102.叉树的层序遍历</a></h4><p>层序遍历的基础用法基本上不会涉及到，因为仅仅只是实现了遍历元素的功能，更多的是进阶用法：题目中一般是让你访问每一层，然后把每一层单独保存下来。LeetCode中的层序遍历变形基本都是基于这一种操作。</p><p>进阶用法在前者的基础上新增加一个队列来保存每一层的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            <span class="comment"># 用res和nextQueue来保存每一层的节点和结果 </span></span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextQueue.append(node.right)</span><br><span class="line">            result.append(res)</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="2-相关题目变形"><a href="#2-相关题目变形" class="headerlink" title="2.相关题目变形"></a>2.相关题目变形</h1><h4 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> chl <span class="keyword">in</span> node.children:</span><br><span class="line">                    nextQueue.append(chl)</span><br><span class="line">            result.append(res)</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h4><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。</p><p>这个题目是在题目102的基础上，只是输出结果是先输出底层在输出顶层，所以代码只需要修改一行即可。把结果逆序输出即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result[::-1]</span><br></pre></td></tr></table></figure><h4 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>这个题目也是基于102的基础，只是输出的时候中间每一层的res奇数层从左到右，偶数层从右到左。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextQueue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(res[::<span class="number">-1</span>])</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>这个题目也是经典变形，只需要修改一下代码即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二叉树的三种遍历方式（前序、中序、后序）</title>
      <link href="2021/12/24/1225-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>2021/12/24/1225-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、三种遍历方式讲解"><a href="#1、三种遍历方式讲解" class="headerlink" title="1、三种遍历方式讲解"></a>1、三种遍历方式讲解</h2><blockquote><p>LeetCode题目链接</p></blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><blockquote><p>三种遍历讲解</p></blockquote><table><thead><tr><th>名称</th><th align="left">节点遍历方式（左根右）</th><th>题目难度</th></tr></thead><tbody><tr><td>二叉树的先序遍历</td><td align="left">根节点、左节点、右节点</td><td>Easy</td></tr><tr><td>二叉树的中序遍历</td><td align="left">左节点、根节点、右节点</td><td>Easy</td></tr><tr><td>二叉树的后序遍历</td><td align="left">根节点、左节点、右节点</td><td>Easy</td></tr></tbody></table><p>只要弄清楚三者的区别在做题的时候就可以更好的实现和理解，实现方法可以分为递归和非递归两种方式，代码可以参考下面。</p><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="2、前序遍历代码实现"><a href="#2、前序遍历代码实现" class="headerlink" title="2、前序遍历代码实现"></a>2、前序遍历代码实现</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(nodeStack) != <span class="number">0</span>:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line">        result = []</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的中序遍历"><a href="#3-二叉树的中序遍历" class="headerlink" title="3.二叉树的中序遍历"></a>3.二叉树的中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> nodeStack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                nodeStack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = nodeStack.pop()</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        result = []</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="4-二叉树的后序遍历"><a href="#4-二叉树的后序遍历" class="headerlink" title="4.二叉树的后序遍历"></a>4.二叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><blockquote><p>非递归方式</p></blockquote><p>后序遍历的稍微有一点不一样，因为在访问左右根的时候，比较难操作，我们可以实现先访问<strong>根右左</strong>，然后再逆序输出就可以得到<strong>左右根</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(nodeStack) != <span class="number">0</span>:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">        result = []</span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="5-N叉树的前序遍历"><a href="#5-N叉树的前序遍历" class="headerlink" title="5.N叉树的前序遍历"></a>5.N叉树的前序遍历</h2><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">                pre(chl)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        pre(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><p>递归方式需要注意，遍历的时候是先保存后面的，再保存前面的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = [root]</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> node.children[::<span class="number">-1</span>]:</span><br><span class="line">                nodeStack.append(chl)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-N叉树的后序遍历"><a href="#6-N叉树的后序遍历" class="headerlink" title="6.N叉树的后序遍历"></a>6.N叉树的后序遍历</h2><blockquote><p>非递归方式</p></blockquote><p>N叉树并没有什么太大的区别，只需要在遍历的时候用for循环考虑多个子节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> node.children:</span><br><span class="line">                nodeStack.append(chl)</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">                post_(chl)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">        result = []</span><br><span class="line">        post_(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研经验贴】本科双非上岸复旦大学计算机学院</title>
      <link href="2021/04/21/0421-%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>2021/04/21/0421-%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<p>去年指导一位本科学弟，成功上岸复旦大学计算机学院，特邀请他写下此贴。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我本科就读于双非院校，初试成绩分别为<strong>政治69，英语71，数学126，408计算机基础综合112，总分378</strong>。</p><p>在前面我很想说，其实我认为考研有一个很重要的方面是找到属于自己的复习方式以及节奏，别人的经验包括我的也更多的是一种参考，就像政治讲的实事求是，根据自己的情况，找到属于自己的学习方法。</p><p>比如我个人如果早期起来的很早，下午会没有精神，那我就八点多到教室也完全可以；我也有一个朋友考的科软，每天八九点来，晚上学到九点就不学，最后成绩441，四千人成绩前五，虽然天赋有一定成分，但是也可以说明，并不是每天必须呆在自习室多久才能有多好的成绩。</p><p>所以还是强调，考研不能仅靠别人推荐的学习安排，更重要的是实事求是，根据自身情况找到属于自己的方法。</p><h1 id="分科介绍"><a href="#分科介绍" class="headerlink" title="分科介绍"></a>分科介绍</h1><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>我其实对最后的政治成绩并不是很满意，我客观题应该是44，这次主观题有点失误。</p><p>客观题重要的是多刷题，我也是听完了徐涛的课程，刷的是肖老的1000题、肖八、肖四，后期在手机上刷了各种模拟卷，比如余等人的（其实我觉得徐涛、腿姐的模拟卷质量不是很高），在小程序上，学累了就刷一下题，分数不重要，到后期甚至模拟卷我都可能35分不到，更重要的是这些知识不断地会重复，而且真题一定会简单一些，刷题刷多了最后做真题能明显地感觉到哪些选项是对的，哪些是干扰项，从哪个地方干扰的。最后有时间也要看几套真题，模拟卷和真题还是有一定差距，最像真题风格的选择题目也就肖四肖八。</p><p>主观题是因为今年肖老发挥超神，大题都预测到了，而我当时是看了研木易的主观题，最后并没有按照肖四中全部背下来写，更多的是用自己的话整理出来。但是可能由于上海的判卷尺度，让老师误认为我并没有背肖四，只是记住了大概；还有就是也不一定要写满，我觉得我是把肖老提到的点写完之后自己又补充，每道题都写满，最后成绩不是很理想，如果考旱区的可以注意一下。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>英语今年英二比较难，我是按照往年的题目难度去准备的，英语并不是我的强项，也没花费很多时间，最后的结果还比较差强人意。</p><p>暑假的时候利用王江涛那本十天背完考研词汇，大概十几天每天花四五个小时，背会了大概七、八成的单词，接下来就是用扇贝每天手机复习一点。 暑假开始做真题，只做阅读理解，一开始做的英一，后来时间不太够就做的英二。到十一月的时候开始看一些作文以及做一些完型等题型。</p><p>总的来说只要坚持背单词，做好阅读，英语不会成为拖累的科目，但如果想要在这方面考的高一点，就需要基础比较好或者复习比较努力。 </p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>今年数二的题目非常简单，按照往年经验一般有一道难题压轴，但是今年并没有出现难题，只要计算基础过关都能拿到一个不错的分数。</p><p>我的数学进度不太值得参考，大概就是在网上看到的进度往后推一个月左右。三四月份我是在家复习，看完了张宇的基础三十讲当中的高数部分，五月份到学校之后，一段时间不学习导致忘记了很多，又重新开始看武忠翔的基础班，到七月底才开始线代，强化甚至也是暑假结束了还没有看完高数的强化。不过我想说的是，如果自己真的进度没有很快，那么看到别人进度快不要着急，一定要打好基础，最后来得及的。</p><p>后期我做的模拟题是张八，李六和李四，比较推荐李林的试卷，包括李林的习题集880也很推荐，只不过我后期才发现，只做了880的线代部分。李林的题目和真题比较像，不会出现很偏很怪的题目，做好之后遇到基础的题目应该不会没有思路，如果想要成绩高一点，那就需要大量的刷题。</p><p>再说一下考试的时候，杭州考场时只给两张16开的草稿纸，根本不够用的，而且考试当天也最好喝杯咖啡什么提提神，我考试的时候有点晕晕乎乎，导致一道填空题写对了，往答题卡上写的时候漏抄了，就直接丢掉了五分。同时也证明大量的刷题也十分重要，我是三个小时刚好做完，甚至一点检查的时间都没有，而我朋友刷题多，他两个小时就做完了，所以最后就成绩比较高。</p><h2 id="408计算机基础综合"><a href="#408计算机基础综合" class="headerlink" title="408计算机基础综合"></a>408计算机基础综合</h2><p>​      我是从暑假开始看408的，先看了天勤的数据结构，直接看书看完了，发现收获不是很多。之后再看的王道全家桶，看视频以及做书上的习题。408这种东西一开始学的时候会觉得很痛苦，因为很多知识记不住，但是没关系，一遍一遍的看，到最后会觉得做408的真题是一件比较轻松愉悦的事情。</p><p>​    总的来说408应该看书，第一遍可以看视频，然后之后就可以直接看书，看三到四遍的时候就会发现没那么难，没有什么太难理解的东西，更多的在于能不能记得住，如果想要125+甚至更高的话，只看王道是不够的，应该结合考纲所指出的具体书籍进行学习。</p><h1 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h1><ul><li><p>政治：《肖秀荣全家桶》，徐涛的《精讲精练》（如果看课可以选择这个）</p></li><li><p>英语：我是只用的张剑的《黄皮书》，单词用的是王江涛《十天背会考研词汇》</p></li><li><p>数学：我跟的武忠翔，书用的是《高等数学辅导讲义》《线性代数辅导讲义》，习题集我只推荐他们的《660》（《330》不太推荐），还有李林的《880》编的也比较有真题味。模拟卷李六和李四一定要做，都是基础的题目，22的试题可能比21难的情况下，可以适当看张宇的张八和张四，然后就是合工大共创以及超越。（汤家凤和李永乐团队的模拟题不推荐）</p></li><li><p>408：《王道全家桶》</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实即便从现在开始，也不用太紧张，只考虑初试的话也是完全来的及的。不要总盯着别人的进度以及攻略帖子的时间表，如果实在比较慢还是要稳扎稳打，不能为了赶进度而马马虎虎做完，这样后期也要花费时间来填坑。考研从来不是比谁学的久，而是比谁学的多，比谁考场发挥的好的比赛。心态也是考研很重要的一部分，希望大家可以稳住心态慢慢来，最终考上理想的学校和专业！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 经验贴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】计算机考研复习指导（简易版）</title>
      <link href="2021/04/19/0419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/"/>
      <url>2021/04/19/0419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍了408计算机考研复习的基本过程，关于时间、资料、真题都会有介绍，大家可以参考一下，整个属于简易版，后期我会推出一个更加详细的版本。</p><h1 id="考研资料准备"><a href="#考研资料准备" class="headerlink" title="考研资料准备"></a>考研资料准备</h1><img src="/2021/04/19/0419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/1.png" class><p><strong>对于辅导书</strong>，并没有太多的选择，除了王道的辅导书就是天勤，除此之外并没有其他可以选择的了，由于我身边考研的同学中，大多数都是选择王道的，所以在此处也就统一推荐王道了，各位可以根据自己的喜好来从两个机构的辅导书中自行决定。</p><p><strong>对于教材</strong>，我推荐的这四本也是网上大家用到的比较多的，这些教材可以在网上找一些PDF即可，因为使用的频率比较低。计算机组成原理有一些章节可以参考一下教材，其他的三门看辅导书已经足够了。复习过程中，可以直接看辅导书进行复习，遇到不会的知识点、重难点可以翻看一下教材，或者是去看一下王道的视频讲解。<strong>不建议全程看王道的视频或者教材，只要针对性的去看即可。</strong></p><p><strong>对于真题</strong>，真题是十分重要的，甚至可以说是最重要的复习资料，从真题里面你可以分析出出题类型、难度、方向、综合性。真题做题方法可以按照四个科目单独做，也可以按照整套试卷的方式来做。</p><p>对于模拟题，无论是王道还是天勤的模拟题，质量都是无法和真题相媲美，只能拿来做个参考，不用过于在意分数，毕竟408复习过程中的能做的题目并不是很多。</p><h1 id="408复习指导"><a href="#408复习指导" class="headerlink" title="408复习指导"></a>408复习指导</h1><p>408复习大致上需要4-5轮，每一轮都要侧重点不同</p><h2 id="第一轮复习-60天-75天"><a href="#第一轮复习-60天-75天" class="headerlink" title="第一轮复习(60天-75天)"></a>第一轮复习(60天-75天)</h2><blockquote><p>复习过程</p></blockquote><ul><li>第一轮的复习需要<strong>全面复习</strong>，无论是重点知识点还是非重点都要全部看一遍，大纲上提到的知识点都必须要复习到；</li><li>对于一些难点，如果实在看不懂也不用怕，可以先做个标记，可以先放下，等之后第二轮再特意攻克；</li><li><strong>做题</strong>，<strong>可以先做选择题以及一部分分析题</strong>，这样安排是因为选择题一般涉及到的知识点比较单一，可以起到巩固知识点的作用；分析题一般会涉及到多个知识点，有的甚至是多个学科，所以做不出来是很正常的，能做出来多少就做多少；</li><li><strong>时间</strong>：408四个科目，难度和内容都不一样，一般来说需要2个月时间才能复习完一轮，平均2天复习一章，有一些章节比较简单，花费的时间就相对减少（例如数据结构的第1、2、3章，计组的第1章，操作系统第1、5章，计网的第1、6章）这些章节复习的时候就自己把握时间，有些章节就会比较难，内容也会很多，可能需要安排3天时间复习一章；</li><li>常遇到的问题：408四个科目会出现后一门的时候忘记了前一门的知识，这个很多人都会遇到，我建议是通过<strong>我的笔记</strong>来快速回顾一下整个一门课的知识点。</li></ul><h2 id="第二轮复习（50-60天）"><a href="#第二轮复习（50-60天）" class="headerlink" title="第二轮复习（50-60天）"></a>第二轮复习（50-60天）</h2><blockquote><p>复习过程</p></blockquote><ul><li>第二轮复习依然是全面为主，但是在复习速度会快很多，因为简单的知识点只要看一下回顾一下就可以了，难点以及自己做出特殊标记的地方需要重点回顾；</li><li>在这一轮，选择题的问题要全部解决或者尽可能全部解决；分析题要基本上能够做出来，做不出来的也要看答案去理解，学习解题方法；</li><li>通过这一轮的复习，要基本上做到所有题型都遇到了也能做出来，为接下来第三轮作准备，同时要熟悉考试的题型，不仅仅是纯粹做题，把出题的套路也要解决掉；</li><li>这一轮复习时间上可能会比第一轮少一点，一个半月至两个月，反正就是尽可能压缩，提高复习速度和效率，人总是会拖延的，如果你给自己定了时间点就会自然而然提高效率；</li></ul><h2 id="第三轮复习"><a href="#第三轮复习" class="headerlink" title="第三轮复习"></a>第三轮复习</h2><blockquote><p>复习过程</p></blockquote><ul><li>这一轮的<strong>重点是真题</strong>，408是统考，所以考试的题目、出题方向都不会有太大的变化，因为要照顾到全国的学生，真题的重要性不言而喻；</li><li>真题可以按照整套试卷来做，也可以按照单独科目来做，可以先拿出来三年的做一下测试一下，最后建议流出后三年的试卷先不要做，可以留着后面测试一下（这个后面并不是考试前，大概十一月份就要做完所有的真题）；</li><li>分析真题，这个是至关重要的，因为你只做题目是没有用的，必须要分析自己做错的原因，出题的方向，横向对比以及纵向对比出题的类型，最后要总结一下哪些题型每年都考，哪些自己做到还不够好，哪些还需要加强；</li><li>通过真题查漏补缺，做题遇到不会的知识点，做完就赶紧复习一下，看看书和笔记，然后记住，通过不断查漏补缺来提升分数和实力。</li></ul><h2 id="第四轮复习"><a href="#第四轮复习" class="headerlink" title="第四轮复习"></a>第四轮复习</h2><ul><li>复习到这阶段距离考试估计还有一个月左右，这段时间也没有太多题目可以做，网上会有一些模拟题，可以参考看看，有时间和精力就做做，因为到最后一个月政治会有很多需要记忆的内容，专业课更多的是查漏补缺。</li><li>这个时期你已经没有足够的时间去系统性把辅导书全面复习了，所以你平时整理的笔记就会十分重要了，你可以拿出来笔记来快速反复复习。</li></ul><h1 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h1><p>由于整理笔记十分花费时间，所以不建议大家去自己整理笔记，可以在本人整理的笔记基础之上添加一些笔记即可；</p><p>详情可点击该链接，文末有购买方式：<a href="https://sanduohou.github.io/2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">【考研】408计算机考研笔记介绍及使用方法</a></p><img src="/2021/04/19/0419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/2.png" class>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】408计算机考研笔记介绍及使用方法</title>
      <link href="2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="408笔记介绍"><a href="#408笔记介绍" class="headerlink" title="408笔记介绍"></a>408笔记介绍</h1><img src="/2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/2.png" class><p>408的复习由于涉及到四个科目，且内容十分广泛，<strong>很容易出现复习后一门科目的时候而忘记前面复习的科目</strong>，因此萌发了自己整理一份笔记，这样可以快速回顾整个科目多个章节的内容。笔记是用OneNote制作整理的，因为这个软件可以实现表格的无限嵌套，整理的笔记会条理清晰，然后加上不同的配色来突出重难点。笔记是初试期间整理的，一般是复习完一章就晚上回到住处整理，如果对知识熟悉一章也花不了太多时间，还可以加深记忆。前期使用确实是花费了较多的时间用来整理笔记，不过整理几章熟悉软件的操作之后速度就大大加快。</p><p>我是复试通过之后，在一个复试群里发了自己的笔记，就有很多参加复试的小伙伴向我索要笔记，当时主要是想着能够帮助大家，基本是白菜价给那些小伙伴们，后来朋友就鼓励我把笔记放在闲鱼，这样可以让更多的人用到自己的笔记而受益。我是相信自己的笔记可以帮到各位学弟学妹才拿出来的，整理笔记并不需要成绩多么好，只需要能够细心、认真、耐心、愿意花时间就可以做得很好。笔记是用OneNote制作整理，有想要尝试的小伙伴可以试一下，但是要做好需要花费大量时间的准备，<strong>经历过整理笔记的经历之后我不太建议大家再去自己去整理笔记。这就像计算机中“时间换空间”还是“空间换时间”一样，你可以通过花费一些钱来获得笔记节省时间，真的没有必要再去自己花费大量的时间整理笔记。</strong></p><ul><li><strong>《数据结构笔记》</strong>参考2021版王道、数据结构（C语言版严蔚敏）</li><li><strong>《计算机组成原理笔记》</strong>参考2021版王道、计算机组成原理（第二版唐朔飞）</li><li><strong>《计算机网络笔记》</strong>参考2021版王道、计算机网络第七版（谢希仁）整理</li><li><strong>《操作系统笔记》</strong>是根据2021版王道、计算机操作系统（第四版）汤小丹整理</li></ul><p><strong>目前，笔记只有纸质版，不再出售电子版，纸质版定价为99元四科，彩色打印包邮，有需要的同学可以通过下方购买，购买之后添加我的私人微信：cs188513890</strong></p><p><a href="http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW">http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW</a></p><p><a href="http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW"><strong><u>408笔记购买方式，该链接即可跳转</u></strong></a></p><p>购买之后14:00之前下单，当天发货，14:00之后下单，第二天发货。</p><img src="/2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/1.png" class><h1 id="第二版笔记的升级"><a href="#第二版笔记的升级" class="headerlink" title="第二版笔记的升级"></a>第二版笔记的升级</h1><p>第一版笔记由于是初试期间整理，有几个章节做的并不够好，因此我在第一版笔记的基础上进行了小的调整。</p><p> <strong>第二版笔记调整如下</strong>: </p><ol><li><p>原有的配图是截图方式，现在改为文字编辑或更换带有明显水印的截图，例如数据结构的代码全部是编辑器编辑之后再截图更加清晰; </p></li><li><p>部分章节的配色第一版没有加上去，在第二版中全部加上去保证统一格式; </p></li><li><p>数据结构前三个章节由于内容较少，第一版采用的是思维导图方式，在第二版中我进行了改进，与现有笔记格式统一; </p></li><li><p>为了防止盗版，把水印的位置与笔记合为一体，既不影响诸位使用也可以保证水印的存在；</p></li><li><p>另外，最近也开始在找人整理出第三版笔记了，具体更新时间暂时不确定，大家有需要可以先使用第二版笔记即可，应付考研完全是足够的；</p></li><li><p>由于笔记是彩色打印，截图打印出来的效果可能会有点不清晰，还请多谅解，不过基本不影响大家正常使用。</p></li></ol><h1 id="笔记如何使用"><a href="#笔记如何使用" class="headerlink" title="笔记如何使用?"></a>笔记如何使用?</h1><p>第一，笔记是对知识的整理、归纳、汇总，涉及的多是重点、难点知识，无法做到对知识的全面覆盖，所有一定要结合辅导书使用。前期需要以辅导书为主，笔记为辅，对知识进行全面复习;后期因为要抓住重点、难点、考点进行复习，不能胡子眉毛一把抓，可以笔记和辅导书同步结合，然后结合真题进行复习，越到后期笔记越重要。 </p><p>第二，为了解决408复习过程中复习后一个科目忘记前一个科目的情况，大家可以在复习空余，定期根据笔记来快速回顾前面的一个科目重点知识，这样既不需要花太多的时间也可防止知识遗忘。 </p><p>第三，笔记主要是用于初试，但是复试亦可，因为复试只需要根据提问叙述出大致意思即可，对一些细节、计算的要求相对较低，所以准备复试的小伙伴也完全可以在短期内复习408的大量内容，并且全部是重点。我整理了一份每章节的复试问题汇总，如果有需要可以私聊我。 </p><p>第四，对于本科期间的期末考试，原则上来说知识是覆盖到了，但是每个学校的期末考试侧重点是不一样的，所以如果是用于期末复习的小伙伴需要根据自己学校的历年考题来进行适当调整。</p><p>第五，现在改考408是大趋势，20、21两年改考的学校已经有几十所，诸位如果选定的学校不是408一定要做好准备：<strong>如果改考408怎么半？</strong>临时改科目确实是一件比较讨厌的事情，大家在准备的过程中也都是信息满满，抱着必上某所学校的决心，甚至是非某所学校不上的决绝，但是我遇到过很多人，当成绩出来的时候，他们找调剂，有点甚至需要二战、工作而以没有学可上而结束。到那时，很多人都会感慨一句:“<strong>有学上比考到自己心目中那所学校更重要。</strong>”</p><p>以上只是建议，还请诸位谨慎采纳，祝各位都可以取得一个好的成绩!</p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>笔记全程都是由我一人初试期间整理，难免会有个别错误以及一些不足之处，如果各位学弟学妹在使用过程中发现，可以通过邮箱（<a href="mailto:&#49;&#x38;&#56;&#53;&#49;&#51;&#56;&#x39;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;">&#49;&#x38;&#56;&#53;&#49;&#51;&#56;&#x39;&#x30;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a>）反馈于我，我在之后的版本中会做一个汇总以便帮助大家指正;</p><p><strong>诸位做为中国高等教育的精英，保护版权、尊重版权、打击盗版应该从我们每个人做起，如果精英阶层都无法做到保护他人知识产权，那么我们所接受的教育就会存在很大缺陷!今日你为他人知识产权站队，明天他人也会为你的知识产权撑腰！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】考研择校如果做到尽可能理性？</title>
      <link href="2021/04/13/0413%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/"/>
      <url>2021/04/13/0413%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-38614663c03722521a9e7f88195d097a_r.jpg" alt="考研择校如何做到尽可能理性选择，拒绝盲目？"></p><p>20年上岸，看到身边很多小伙伴最终被迫选择调剂、工作、二战，感到十分可惜。特写下此篇，以指导诸位学弟学妹在考研的第一步就选择对，这样会让你的考研之路更加有把握。看完此篇，再来对照你择校的过程。大家在选择学校的时候，一定要经过尽可能的理性分析，而不是感性的选择。选择学校这一步走错了，基本上也就意味着你的考研之路悲惨结局开始了。</p><h2 id="第一：什么是感性选择？"><a href="#第一：什么是感性选择？" class="headerlink" title="第一：什么是感性选择？"></a><strong>第一：什么是感性选择？</strong></h2><p>名校情结，非这个学校不上，完全没有考虑自己的实力和学校的难度；感觉自己能够考上，对自己要考的学校了解很少，例如初试科目难度怎么样、复试比例多少、刷人多不多、是否等歧视双非学校等信息都一无所知；对往年数据（经验贴）没有做任何收集，全凭自己的感觉走；选择考研，并不是自己真的想要考研，而是看身边人考研了，自己随大流；<strong>以上情况都是考研择校的大忌，往往会葬送你的考研梦想；</strong>当然，如果你能够承受名校情结可能带来的风险，并且知道如果自己无法上岸会去干什么，那你就勇敢去拼搏一把吧！</p><h2 id="第二：如何做到尽可能理性选择？"><a href="#第二：如何做到尽可能理性选择？" class="headerlink" title="第二：如何做到尽可能理性选择？"></a><strong>第二：如何做到尽可能理性选择？</strong></h2><p>要说明一点，择校想要做到完全理性是不可能的，只能做到有限理性，因为我们的信息是有限，即使你能够把我下面强调的信息完全收集到也不行，因为人们在预估自己的实力之时，往往很难做到理性。但是通过我下面的方法，可以尽可能让你选择一个自己更有把握的学校<br>选择几个学校作为备选项，就是这几个学校都可以作为你的意愿学校，这种备选学校最好能够有5个以上，实力都相差不大即可；收集备</p><p><strong>选学校过去三年的考研信息，这些信息包括：（很重要）</strong><br><strong>初试科目及难度、专硕/学硕招生人数（去掉推免之后的人数）、进入复试的人数及比例、历年的报录比、每年的单科分数线及总分数线、是否歧视双非学校的学生、是否保护第一志愿、复试科目都有哪些内容等等</strong>，只要能够找到的，全部都收集下来，会有一些信息学校没有公布；</p><p>还要再去看经验贴，就是往年考上的学姐学长在网上分享的经验贴，这是一个很好的一手材料，作为对考研学校的一些辅助分析，例如可以分析复试难度、是否歧视双非等信息；把上面这些数据拿出来对比，既要纵向对比（看这个学校的报考热度、分数是否增加），也要横向对比（看哪个学校更好考一些）。</p><p>根据这些对比，你要能够预估一下自己这些学校下一年的分数会在多少，自己要是考这些学校能够考多少分，需要付出多大的努力，有多大的决心；除此之外，还要考虑复试，因为初试能够进去只是过了第一关，复试这一关更加重要。复试不及格是无法录取的，就拿计算机专业来说，有的学校需要上机编程，你能否顺利通过，又能拿到多少分呢？对于计算机的同学来说，需要强调的是，就我目前观察的情况是，21年计算机多所学校出现了高分被刷的同学，而且不乏初试排名前几名的同学，这是因为现在考研已经进入了存量时代，老师开始更加重视学生专业技能而不在是你能考多少分。因为老师招收一个学生，本来就培养时间在2.5-3年之间，如果跨考的学生基础以及可塑性太差的话，即使是初试高分老师也是不太想要的。</p><p>对自己进行分析，这是最难做到理性的，所以在完成以上的分析之后，要把这些数据找一个老师或者考上的学长学姐帮你分析。看看你能否实现你自己预定的分数，哪个学校考上的把握更大，然后选择1-2个学校作为备选（这两个学校最好科目差不多，如果科目差别大的话，就只能选择一所学校了），到9、10月份的时候根据自己的复习情况填报志愿。</p><h2 id="第三：如何看待“选择大于努力”"><a href="#第三：如何看待“选择大于努力”" class="headerlink" title="第三：如何看待“选择大于努力”"></a><strong>第三：如何看待“选择大于努力”</strong></h2><p>每个人的看法都不一样，我说说自己的看法：“选择大于努力”这句话是考研界十分流行的一句话，首先要明确的是：选择确实比努力更重要，因为你选择错了，怎么努力都是徒劳，因为你努力的上限不能够达到你选择的下限，就像鲤鱼跳龙门一样，这条鲤鱼能够跳的最大高度不能够超过门的高度。</p><p>今年（20年）因为疫情的影响，很多学校扩招，选择这些学校的学生真的是很幸运的。但是疫情毕竟是突发事件，几十年才能遇到一次，所以我们还是主要考虑常规事件。选择很重要，但是你选择的学校毕竟是自己喜欢的、想要去的，如果选择一个自己即使考上了也不能够开心学习的学校，哪怕这个学校很好考，我也认为大可不必。选择还是要想我上面所说，尽可能理性选择，而不是感性盲目选择。</p><p>最后再说一句，每个人在备考的过程中都会雄心壮志，非这个学校不上，但是最终大多数人都会被现实打败，他们会屈服在自己考研分数的现实面前，不得不低下自己骄傲的头颅，卑微地四处找调剂，那个时候他们才会认识到<strong>“有学上是多么重要”</strong>。当然也有人会继续扬起自己骄傲的头颅选择二战。现实是可悲的，考研无论怎么扩招，最终录取率还是保持在20-30%，四、五个考研学生里只有一个学生能够录取！</p><p>选择考研，你真的准备好了吗？</p><hr><p>我建立了一个考研打卡群，群里有一些小伙伴可以每天一起打卡自己的学习内容，如果你是单独备考，欢迎你加入我们，一起交流学习！</p><p>微信：cs188513890（加好友请备注：考研打卡群）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【408笔记勘误】4月10日更新</title>
      <link href="2021/04/08/0406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/"/>
      <url>2021/04/08/0406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>笔记在整理过程中，难免存在一些错误，我会把大家反馈的错误在此处进行勘误，如果您在使用笔记的过程中发现有错误之处，还请及时告知于我，以便我勘误，并在下一版笔记中纠正。</p><p>联系方式（微信）：cs188513890</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="第三节：线性表的链式表示"><a href="#第三节：线性表的链式表示" class="headerlink" title="第三节：线性表的链式表示"></a>第三节：线性表的链式表示</h3><img src="/2021/04/08/0406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/1-1.png" class><p>把**<u>“按值查找节点值”与“按序号查找节点的值”</u>**交换位置</p><h2 id="第四章：树和二叉树"><a href="#第四章：树和二叉树" class="headerlink" title="第四章：树和二叉树"></a>第四章：树和二叉树</h2><h3 id="第三节：二叉树的遍历与线索二叉树"><a href="#第三节：二叉树的遍历与线索二叉树" class="headerlink" title="第三节：二叉树的遍历与线索二叉树"></a>第三节：二叉树的遍历与线索二叉树</h3><img src="/2021/04/08/0406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/1-2.png" class><p>三种遍历方式，都应该是先访问左节点，再访问右节点，因此需要把<strong>T-&gt;rchild与T-&gt;lchild</strong>交换位置</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="第一章：操作系统概述"><a href="#第一章：操作系统概述" class="headerlink" title="第一章：操作系统概述"></a>第一章：操作系统概述</h3><h3 id="第一节：基本概念"><a href="#第一节：基本概念" class="headerlink" title="第一节：基本概念"></a>第一节：基本概念</h3><img src="/2021/04/08/0406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/3-1.png" class><p>删去<strong>“前者时间换空间；后者空间换时间”</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【效率】如何用iPad辅助考研备考</title>
      <link href="2021/04/01/0401%E5%A6%82%E4%BD%95%E7%94%A8iPad%E8%BE%85%E5%8A%A9%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83/"/>
      <url>2021/04/01/0401%E5%A6%82%E4%BD%95%E7%94%A8iPad%E8%BE%85%E5%8A%A9%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic1.zhimg.com/80/v2-9e9dc0dc8a84987e296c0920261bc910_1440w.jpg" alt="img"></p><p>iPad长期以来被诟病——买前生产力，买后爱奇艺。考研过程中，我看到身边很多人确实是把iPad作为一种追剧的神器，而不是学习的利刃。我通过将近一年的使用，却用iPad做了不少事情，用来考研备考的辅助神器，真的是一个不错的选择，今天为大家分享一些我的使用方法。<strong>当然正如题主所说，iPad只是辅助，能否发挥其性能以及把其性能发挥到何种程度也要看个人。</strong></p><blockquote><p>装备：32GiPad2019+BOW可折叠键盘+Apple Pencil（发挥最大效能三者缺一不可）<br>本文将会介绍以下几个软件：<strong>OneNote、notability、Anki背诵神器、墨墨背单词软件、MarginNote2、欧路词典、Forest专注森林、B站万能学习资源、百度网盘</strong></p></blockquote><h2 id="第一｜OneNote（做笔记、计划、记录、总结等）"><a href="#第一｜OneNote（做笔记、计划、记录、总结等）" class="headerlink" title="第一｜OneNote（做笔记、计划、记录、总结等）"></a>第一｜OneNote（做笔记、计划、记录、总结等）</h2><p>本人算是一个OneNote重度用户了，考研期间的笔记、每日计划、每周总结、考研择校等等所有的东西，基本都是在OneNote上完成。OneNote的一些其他用法可以看看我的这个回答</p><h3 id="1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）"><a href="#1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）" class="headerlink" title="1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）"></a>1、考研每日计划（下面的这个视频<strong>是我制作的如何在OneNote制作每日计划模板教程）</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-219e72ec6055307ceb025c2cd01b4185_1440w.jpg" alt="img"></p><h3 id="2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。"><a href="#2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。" class="headerlink" title="2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。"></a>2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。</h3><p><img src="https://pic3.zhimg.com/80/v2-38614663c03722521a9e7f88195d097a_1440w.jpg" alt="img"></p><h3 id="3、每个月的总体规划"><a href="#3、每个月的总体规划" class="headerlink" title="3、每个月的总体规划"></a>3、每个月的总体规划</h3><p><img src="https://pic4.zhimg.com/80/v2-233b0b5cc2d20a621d97dcc7dc9aa2f3_1440w.jpg" alt="img"></p><h3 id="4、每周的总结"><a href="#4、每周的总结" class="headerlink" title="4、每周的总结"></a>4、每周的总结</h3><p><img src="https://pic2.zhimg.com/80/v2-96b1c453043a1d8a0971d39b1cc1b5e5_1440w.jpg" alt="img">每周的一个小总结，这是最后一个多月前的一次大总结</p><p>5、通过OneNote，我记录下自己考研过程中的每日点点滴滴，每周都会回头看看自己这周学习了哪些内容，还有哪些需要加强，还会整理自己的英语笔记、专业课笔记、政治笔记。</p><p>政治复习是花最少的时间，获得最高的分数，具体建议可以看看我的博客中关于政治复习建议的文章</p><p><img src="https://pic1.zhimg.com/80/v2-e61ca954717deec88167421407af99bc_1440w.jpg" alt="img">徐涛的30天背诵大作战，每天背一点</p><p><img src="https://pic1.zhimg.com/80/v2-35bab5b50fb4f34e2cc2715e59f845ac_1440w.jpg" alt="img">英语作文模板，自己通过很多其他优秀的模板整理出一份属于自己的模板，最终效果也不错</p><p>下面是专业课笔记（计算机网络、数据结构、计算机组成原理、操作系统），因为408科目比较多，所以需要整理出笔记方便自己的复习，针对笔记虽然会很有争议，但是还是要因人而异，尤其是针对内容较多的时候，笔记可以更好辅助复习。</p><p><img src="https://pic2.zhimg.com/80/v2-2c11080be72801a3baf7369412d04999_1440w.jpg" alt="img">操作系统笔记</p><p><img src="https://pic2.zhimg.com/80/v2-0c4a66e65bd08bb74bc9c23d20f245f1_1440w.jpg" alt="img">计算机网络笔记</p><p><img src="https://pic1.zhimg.com/80/v2-70e64827c965aa1a5c7d177ffad482d4_1440w.jpg" alt="img">还有数据结构笔记和计算机组成原理笔记</p><p><img src="https://pic4.zhimg.com/80/v2-a521e3bbd6d119009e062074416da787_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1f37d420b2c0058713f0d930ad2989ca_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-aad604278b4c225092f797a3e51123f4_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-43108766c4c1d52bffad75a7a4e4cdd0_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5c46076370d4547b0af45961f7b2bd8b_1440w.jpg" alt="img"></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="第二｜notability（标记、看PDF、整理笔记）"><a href="#第二｜notability（标记、看PDF、整理笔记）" class="headerlink" title="第二｜notability（标记、看PDF、整理笔记）"></a>第二｜notability（标记、看PDF、整理笔记）</h2><p>notability用来看PDF、做标记、整理笔记也是十分方便的，我主要用来完成做前两者的事情，如果再结合它的<strong>分屏功能</strong>简直是太棒了，就是iPad2019屏幕稍微有点小，不过也够用了。</p><p>notability手写、标记、荧光笔……等功能一定要用起来，我使用过好几款类似软件，但是最好用的还是这一款。</p><p><img src="https://pic2.zhimg.com/80/v2-7356d88f6c51cb6146ace5030bd68bed_1440w.jpg" alt="img">把OneNote里的笔记导出到notability，在上标记很方便</p><p><img src="https://pic2.zhimg.com/80/v2-54f5703ea2e1b21c6034ac0d4941acb1_1440w.jpg" alt="img">数学笔记，好多资料考后删了，内存不够，有点心疼</p><p><img src="https://pic2.zhimg.com/80/v2-06e50f547ce2df0ab182da64e083f4e1_1440w.jpg" alt="img">英语作文模板，考英语二，小作文背十篇基本就够了</p><p><img src="https://pic3.zhimg.com/80/v2-378423545490f6ccbec83c6de8b8f0b6_1440w.jpg" alt="img">这个是大作文模板，大作文要整理出来一份自己的模板，我的这一份用着感觉挺好的，考场发挥也不错啦</p><p><img src="https://pic1.zhimg.com/80/v2-4b82c015c019321d97b7d3ad4f559148_1440w.jpg" alt="img">政治很多资料都没必要买，可以看PDF版就好，特别是肖四，PDF版本会比纸质版提前3天出来，可以比别人早几天背诵，真的很重要</p><p><img src="https://pic1.zhimg.com/80/v2-970ab3ff6eb3c932e843998c3b76326c_1440w.jpg" alt="img">OneNote做出来的笔记，最终就是这样的，很方便，重点突出</p><p><img src="https://pic4.zhimg.com/80/v2-c9a741db8f5a1d1976fbba94edbfc753_1440w.jpg" alt="img">英语二大作文模板</p><p><strong>分屏功能</strong>：这个是nb和欧路词典，左边是英语文章，直接选中后复制就可以在右边出现翻译，对于英语学习来说简直是不可多得的利器，对于日后的研究生阅读论文帮助也很大。</p><p><img src="https://pic2.zhimg.com/80/v2-dac6d504608210ee808b416814b8ed41_1440w.jpg" alt="img"></p><h2 id="第三｜Anki背诵神器（强推，背英语单词、背政治题目）"><a href="#第三｜Anki背诵神器（强推，背英语单词、背政治题目）" class="headerlink" title="第三｜Anki背诵神器（强推，背英语单词、背政治题目）"></a><strong>第三｜Anki背诵神器（强推</strong>，背英语单词、背政治题目）</h2><p>遇到这款神器真是幸运，政治选择题能够拿到40+，真当是多亏这款软件了，用来做《肖1000题》、《各位名师的模拟题》大概做了40+套，重复很多遍，关键是为我节省了很多时间。*<strong>我今年也建立了一个Anki卡组免费共享裙，欢迎大家一起交流学习，可以直接看我主页“想法”第一条就是有图片可以扫描进入。*</strong></p><p><strong><em>注意：这款工具安卓、电脑均可使用，进群有安装包可以下载使用\</em></strong></p><p><img src="https://pic4.zhimg.com/80/v2-5fd56e965f0fca8894f58cd38cb216b3_1440w.jpg" alt="img">这个是我用到的模拟题</p><p><img src="https://pic2.zhimg.com/80/v2-7762737e6e031645f194ac4bd340d04d_1440w.jpg" alt="img">感谢各位大佬制作的Anki卡组，用起来很方便</p><h2 id="第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）"><a href="#第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）" class="headerlink" title="第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）"></a>第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）</h2><p>我试过很多款市面上流行的背单词软件，但是最喜欢的还是墨墨背单词，最大的特点就是根据“艾宾浩斯遗忘曲线”来帮助你重复背诵单词，其他软件这一点做的不是很好，缺点就是需要买单词上线，我当时买了8800个。</p><p><img src="https://pic2.zhimg.com/80/v2-ee3ab22400f2326f665b38e58721b8fd_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-0efdb35f4f58782210d17175a3f4fc96_1440w.jpg" alt="img"></p><h2 id="第五｜MarginNote2（可以把PDF标记之后直接生成PDF）"><a href="#第五｜MarginNote2（可以把PDF标记之后直接生成PDF）" class="headerlink" title="第五｜MarginNote2（可以把PDF标记之后直接生成PDF）"></a>第五｜MarginNote2（可以把PDF标记之后直接生成PDF）</h2><p>这个软件可以把你的标记生成思维导图，这一点还是很好用的，对于文科的学生我感觉帮助会更大一点，我用到比较少，据说生成的思维导图可以制作成卡片直接导入Anki中，尝试几次都没有成功。以后有机会再做尝试吧！</p><p><img src="https://pic3.zhimg.com/80/v2-bb0d075ac85759725e75eca4d5fd483a_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-963e5e817cdb4c257c3797b7dbed4e7c_1440w.jpg" alt="img"></p><h2 id="第六｜欧路词典（查生词）"><a href="#第六｜欧路词典（查生词）" class="headerlink" title="第六｜欧路词典（查生词）"></a>第六｜欧路词典（查生词）</h2><p>欧路词典有三个特点：一个是可以自己导入词典；一个是你可以利用iPad的分屏功能，在一个软件上直接划词复制之后，就会在欧路词典上出现这个词语的意思，非常方便；第三个功能是每次查词之后都可以加入生词本，然后你可以像墨墨单词那样复习一样；</p><p><img src="https://pic2.zhimg.com/80/v2-84533fa69f8cf0391199f1ce91a7a1ed_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-6fd7edf487fbbe0012b7cf319a8c061e_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-cf14c10f886bf7952c5ba6feea1f4a0e_1440w.jpg" alt="img"></p><h2 id="第七｜Forest专注森林（学习时种树，让自己变得更加专注）"><a href="#第七｜Forest专注森林（学习时种树，让自己变得更加专注）" class="headerlink" title="第七｜Forest专注森林（学习时种树，让自己变得更加专注）"></a>第七｜Forest专注森林（学习时种树，让自己变得更加专注）</h2><p>很多人都控制不住自己，总是会玩iPad，所以你可以在自己学习的时候在Forest专注森林里面种树，也可以邀请其他小伙伴一起种树，如果其中一个人退出软件就会导致双方的树枯萎。</p><p><img src="https://pic3.zhimg.com/80/v2-25af2266b51dc12586ab59694b3043ea_1440w.jpg" alt="img"></p><h2 id="第八｜B站（传说中的学习万能宝库，什么资源都有）"><a href="#第八｜B站（传说中的学习万能宝库，什么资源都有）" class="headerlink" title="第八｜B站（传说中的学习万能宝库，什么资源都有）"></a>第八｜B站（传说中的学习万能宝库，什么资源都有）</h2><p>B站的学习功能就不用说了，这个是有目共睹。</p><h2 id="第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）"><a href="#第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）" class="headerlink" title="第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）"></a><strong>第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）</strong></h2><p>百度网盘也是用的比较多的，我往往都是前一天晚上开始缓存，然后第二天就可以倍速观看了，如果没有提前缓存下来需要开通会员才可以使用倍速观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】政治考研复习建议</title>
      <link href="2021/04/01/0401%E6%94%BF%E6%B2%BB%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"/>
      <url>2021/04/01/0401%E6%94%BF%E6%B2%BB%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>20上岸，旱区（北上地区）政治75+，还算一个不错的分数；这篇帖子不仅仅是经验分享，更是一篇备考指导，让你可用最少的时间和精力，获得更多的分数，大家请根据自己的情况进行调整复习。</p><p><img src="https://pic2.zhimg.com/80/v2-137341f9506ac1289248d62ac6ee22ed_1440w.jpg" alt="img"></p><h3 id="一、欲拿高分，思想先行"><a href="#一、欲拿高分，思想先行" class="headerlink" title="一、欲拿高分，思想先行"></a><strong>一、欲拿高分，思想先行</strong></h3><p>考研过程中，只有政治可以说是几乎所有人的基础都是一样的——零基础，但是最后政治依然会有人拿到高分，而有人是50分低分飘过，究其原因，就是方法的失当和努力的缺失，更加重要的先入为主的错误思想。</p><p>这些错误思想包括：“政治是一门玄学”，“政治大家分数都差不多，拉不开分”，“政治只要能考60分就可以了”…………这些思想，在考研期间真是听了不知多少遍，其共同之处都是对政治的不重视。就拿“政治能否拉开分数来说”，诸位可以任意找几所学院的复试名单，看政治分数第一名与最后一名的分数差距便可知道，基本可以相差二十分以上，试问在考研过程中20分是个什么样的概念！！！关键是这20分的提升可能只需要四五十个小时便可以完成。</p><p>我们也完全可以把英语与政治对比一下，英语基础的好坏对你成绩的影响是非常大的，有的人可以轻轻松松考到80分，而有的人努力大半年也只能考50分，这就是差距。政治备考，如若可以重视起来，认真准备，并且善于利用我下面提供的一款软件Anki，拿到75+的分数并非不可能。</p><h3 id="二、书籍推荐、省时省；做好计划、心中有数；"><a href="#二、书籍推荐、省时省；做好计划、心中有数；" class="headerlink" title="二、书籍推荐、省时省；做好计划、心中有数；"></a><strong>二、书籍推荐、省时省；做好计划、心中有数；</strong></h3><h4 id="（一）书籍推荐"><a href="#（一）书籍推荐" class="headerlink" title="（一）书籍推荐"></a><strong>（一）书籍推荐</strong></h4><p>考研花钱，政治最花钱，买书是最多的，但是很多书完全可以不用买，因为只需要看一下PDF就可以了，但是有些必须要买。<strong>因为我用的是肖秀荣的书，所以就以他的整套书为例，如果你用的是其他老师的书，也可以进行对比。</strong>每个老师的图书系列都是差不多的，无论跟哪个老师都可以，基本上考研政治这几位名师都是很不错的，选择了就请相信。</p><p><img src="https://pic1.zhimg.com/80/v2-4037681b96edbfa76a7f8c5ff28affac_1440w.jpg" alt="img"></p><p>考研毕竟是要花钱的，不要想着所有的书都看PDF，这是绝对行不通的，能帮你省点钱都帮你省了，如果实在拮据，就去闲鱼看看必买的书籍吧！</p><p>注意：其他老师的模拟卷，不用买，全部使用我下文提到的Anki背诵软件即可，但是需要网上找相关的模拟卷卡组导入，如果私信我的人多，我可以建立一个Anki卡组资料共享群；</p><h4 id="（二）关于计划"><a href="#（二）关于计划" class="headerlink" title="（二）关于计划"></a>（二）关于计划</h4><p>考研需要有一个整体的计划，你哪个时期该做什么？做到什么程度？自己心中都应该有数，最好能够以计划的形式写出来。</p><p><img src="https://pic4.zhimg.com/80/v2-575240b2779bd61a391ca5b9edd459b3_1440w.jpg" alt="img"></p><p>我根据自己的帖子，做一个大致的计划，稍微前后提前或者推迟半个月，不能太多，太早复习时间有点早，太晚复习选择题部分不能保证40+。政治是一门投入产出比最大的课程，如果你三四月份就开始复习，可能到最后和人家八九月份复习的人来说没有太大的分数区别；但是如果太晚复习我是十分不建议的，有的人会十一月才开始复习政治，你连政治的基础概念都无法全部理解，可能会有很多人说自己复习的很晚但是依然拿到不错的分数，但是这样还是太冒险，非常不建议。</p><p><img src="https://pic4.zhimg.com/80/v2-a61561988a2e3eb0c71fcf37a848e993_1440w.jpg" alt="img"></p><p><strong>改：9月-一轮复习 毛概、思修基础知识</strong></p><h3 id="三、一轮复习，掌握方法"><a href="#三、一轮复习，掌握方法" class="headerlink" title="三、一轮复习，掌握方法"></a><strong>三、一轮复习，掌握方法</strong></h3><p><strong>复习资料</strong>：《精讲精练》+《徐涛视频》+《1000题》</p><p><strong>复习方法</strong>：《精讲精练》快速过一遍，看视频，边看边理解书上的内容（也就马原需要理解，其他三科只需要记忆），看完视频再看一遍书，开始做《1000题》，错误的地方做个标记，尤其是马原部分，因为还要二刷；</p><p><strong>复习时间：</strong>我建议的开始复习政治的时间是：8月中旬前后开始，不能太晚，太晚很多基础的东西复习不完了，到最后做模拟冲刺卷的时候，你会发现自己很多基础的知识题都会出错。这轮复习下来大概需要2个月左右；</p><p>政治分为马原、毛概、史纲、思修，其中马原是最难理解的，大家都是零基础，建议结合徐涛的视频来复习，看视频的时候用1.5的倍速观看，每个视频的时间都不长，倍速之后也就二十分钟。徐涛的视频讲的很有意思，很多人都喜欢看，而且越看越想看，而且看的时候就像在看综艺节目，很开心<strong>，但是开心的同时是否学到了东西却是值得商榷的</strong>，很多人到最后只记得看视频却忘记学习知识，这个大家需要注意。我个人认为：<strong>除了马原必须要看视频之外，其他三科完全可以选择不看</strong>，因为其他三科都是基本的知识，理解的地方很少，<strong>如果看的话建议两倍速</strong>；</p><h3 id="四、二轮复习，借助Anki，结合核心考点"><a href="#四、二轮复习，借助Anki，结合核心考点" class="headerlink" title="四、二轮复习，借助Anki，结合核心考点"></a><strong>四、二轮复习，借助Anki，结合核心考点</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-68753fee2a0813b9a72423b34b21bd9c_1440w.jpg" alt="img"></p><p><strong>复习资料</strong>：<u>《1000题》+Anki记忆软件+《风中劲草核心考点》+《精讲精练》</u></p><p><strong>复习方法做题部分</strong>：《1000题》肯定是需要至少两遍，第二遍做题，只需要马原部分用到《1000题》，毛概、史纲、思修的《1000题》复习，我推荐使用<strong>Anki背诵软件</strong>，这个《1000题》的卡组可以在官网上找到资料分享。做题部分其实并不需要完全与第二轮分开，你可以先复习马原、毛概并完成相应的题目，等你复习史纲的时候就可以回过头来做第二遍马原的题目，当然也可以等第一轮完全结束的时候在开始第二遍做题。</p><p><strong>复习方法-《风中劲草》如何使用</strong>：风中劲草这本书的好处是内容简介、多种颜色标记、重点清晰，这本书用来第二轮复习，可以看完一章或者看完整个科目之后就刷第二遍题目。风中劲草需要前前后后看四遍左右，2-3天就可以完成一轮复习。</p><h3 id="五、三轮复习、多做模拟题的选择题部分"><a href="#五、三轮复习、多做模拟题的选择题部分" class="headerlink" title="五、三轮复习、多做模拟题的选择题部分"></a>五<strong>、三轮复习、多做模拟题的选择题部分</strong></h3><p>这个过程你需要做30-40套模拟题，大家不要以为30套模拟题很多，其实很少，因为每套模拟题只需要做选择题就可以了，基本一套也就二十多分钟就可以做完了。主要是多选部分，多选拿到高分，选择题才能拿到高分，想要拿75+，多选需要保证40+，这样把握更大；</p><p><strong>复习资料</strong>：<u>各位老师的模拟题+时政+近五年《真题》</u></p><p><strong>模拟题复习方法</strong>：大概在十一月下旬开始，就会有各种老师的模拟题出版，记住，只需要买《肖八》和《肖四》，其他的模拟题全部都用Anki背诵软件来做题，Anki背诵就类似于墨墨单词软件，采用的是艾宾浩斯遗忘曲线来辅助。我推荐使用Anki的原因并不是省钱，而是它可以帮助你短期内把这些试卷做三遍以上，而且花的时间会比你买试卷做题少很多。注意：《肖八》需要好好做，可以先只做选择题部分，做完一整套试卷就对答案，然后把每个选项中不懂得部分都翻书看一下；</p><p><img src="https://pic2.zhimg.com/80/v2-edc9e2ce1ab349c017d2244995535e95_1440w.jpg" alt="img"></p><p><strong>时政复习方法</strong>：时政选择题也占6分，但是根据20年的情况可以发现，时政选择题远远超过了6分，而且很多题目都会和时政结合起来出题。时政可以看看肖老师的《时政小册子》，微博上会有很多人分享自己整理的时政，以及各种考研公众号也会整理出来，<strong>你要广泛搜集这些他们整理的，就不用自己整理了，找来打印出来记住就可以了；</strong></p><p><strong>真题复习方法</strong>：真题是一定要做的，你最起码要做完最近五年的真题，分析一下命题人是如何设置陷阱，同时也要看一下分析题的答题方法，保证能够拿到最多的分数。</p><h3 id="六、四轮复习、冲刺分析题"><a href="#六、四轮复习、冲刺分析题" class="headerlink" title="六、四轮复习、冲刺分析题"></a><strong>六、四轮复习、冲刺分析题</strong></h3><p><strong>复习资料</strong>：<u>《肖四》（如果你跟的其他老师就选择其他老师的资料）</u></p><p><strong>复习方法</strong>：分析题占比50分，但是却是最容易拿到的，我身边的大多数人都是在最后15-20天开始准备分析题，分析题我用的是《肖四》，其实每个老师押题都是能够压中的，但是绝对很难做到全部压中题目，有的老师可能用50个题目去压考研的5个题，而有的老师却只用三十个题目就可以压中，肖老师在考研政治中的名气大家都有所耳闻，最后只用几页A4纸就可以搞定，性价比高，拿分也高。这个阶段，你狂背肖四就可以了，当然也可以背其他老师的押题卷，看个人喜好。</p><p>但是要记住，无论是哪个老师，都无法做到全部压中原题，所以在考场上遇到你没有背到的题目，就要从材料中去找答案，你翻看一下就会发现每一题的材料都会给整个A4纸那么多的内容，答案都会隐藏在材料中，要多去材料中找到答案，进行归纳总结。</p><hr><h3 id="补充与答疑"><a href="#补充与答疑" class="headerlink" title="补充与答疑"></a>补充与答疑</h3><h4 id="补充一：《1000题》怎么用"><a href="#补充一：《1000题》怎么用" class="headerlink" title="补充一：《1000题》怎么用"></a><strong>补充一：《1000题》怎么用</strong></h4><p>1、《1000题》需要做不止一遍，如果只用纸质版，想要做2遍花费的时间就无法想象，但是如果使用Anki背诵的话，做3-4遍所花费的时间都比纸质版2遍要少很多，所以我还是推荐第一遍做纸质版，之后就用Anki背诵神器来记忆；</p><p>2、第一遍做题方法：看完视频和基础知识之后就做本章节对应的《1000题》，做题的时候需要记住，一定要做错题标记，一是为了能够统计错题率，二是能够后面回头复习的时候看到自己做错的题目，方便复习；</p><p>第一遍做题错误率会很高，这个不要担心，毕竟是刚开始，后面会降下来的；</p><p>3、<strong>第二遍做《1000题》：这里是重点，一定要认真看。</strong></p><p>马原部分涉及到哲学，还是有一定难度，需要理解，我建议再把纸质版的《1000题》做第二遍，之后再使用Anki做马原的题目就会感觉到如鱼得水；</p><p>毛中特、史纲、思修第二遍就可以直接使用Anki做题，你会发现做一段时间之后你对知识的理解以及做题的速度都会优于身边人。</p><hr><p><strong>本文首发于我的知乎账号</strong>：上海地区政治77，考研政治复习指导 - 后羿的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/145769562">https://zhuanlan.zhihu.com/p/145769562</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 经验贴 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>a.md</title>
      <link href="2023/10/05/a-md/"/>
      <url>2023/10/05/a-md/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一文详解“旋转数组”</title>
      <link href="2022/01/24/220124%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>2022/01/24/220124%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 轮转数组</a></h1><p>难度中等1290</p><p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p></li><li><p><code>0 &lt;= k &lt;= 105</code></p><p><strong>进阶：</strong></p></li><li><p>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</p></li><li><p>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种</p></blockquote><p>先整体逆序，然后把前k逆序，最后把后n-k个逆序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums[:] = nums[::<span class="number">-1</span>]</span><br><span class="line">        nums[:k] = nums[:k][::<span class="number">-1</span>]</span><br><span class="line">        nums[k:] = nums[k:][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>第二种</p></blockquote><p>新建立数组保存下来前半部分和后半部分，这样在重新放入到nums中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums1 = nums[:n-k]</span><br><span class="line">        nums2 = nums[n-k:]</span><br><span class="line">        <span class="comment"># print(nums1, nums2)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            nums[i] = nums2[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k, n):</span><br><span class="line">            nums[j] = nums1[j - k]</span><br></pre></td></tr></table></figure><h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h1><p>难度中等651</p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二分查找</p></blockquote><p>因为经过了一定的旋转，所以我们在右边有序中，不断右移right，然后最后返回left即有序数组最左边元素最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="comment"># 右边有序</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左边有序</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h1 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></h1><p>难度困难445</p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><p><strong>进阶：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid </span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == nums[right]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode题目整理</title>
      <link href="2022/01/20/220120LeetCode%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2022/01/20/220120LeetCode%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h1><table><thead><tr><th>题目</th><th>标签</th><th>难度</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></td><td></td><td>简单</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></td><td></td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td><td></td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></td><td></td><td>困难</td><td>未整理</td></tr><tr><td><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></td><td>字符串、动态规划</td><td>中等</td><td>中心扩展、马拉车算法</td></tr><tr><td><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></td><td>字符串</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></td><td>数学</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></td><td>字符串</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></td><td>字符串</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td><td>链表、快慢指针</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td><td>链表、双指针</td><td>简单</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td><td>链表、栈、小根堆</td><td>困难</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></td><td>链表</td><td>困难</td><td>需要模拟一下，尤其是对于最后少于K个的情况</td></tr><tr><td><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></td><td>字符串</td><td>困难</td><td>KMP模式串匹配</td></tr><tr><td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></td><td>数组、二分查找</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></td><td>滑动窗口</td><td>困难</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></td><td>链表</td><td>中等</td><td>反转指定的链表</td></tr><tr><td><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></td><td>二叉树</td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></td><td>构造二叉树</td><td>中等</td><td>找到指定的位置，把节点分为左右子树，递归解法</td></tr><tr><td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></td><td>构造二叉树</td><td>中等</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td><td>二叉树</td><td>中等</td><td>递归，先把左侧的拉直，再把右侧拉直，先把左侧加入到根节点，再把右侧加入到根节点。</td></tr><tr><td><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></td><td>二叉树</td><td>中等</td><td>递归，也可以用层次遍历</td></tr><tr><td><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></td><td>二叉树</td><td>中等</td><td>层次遍历</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></td><td>链表、递归、迭代</td><td>简单</td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></td><td>二叉搜索树</td><td>中等</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,7,11,15], target &#x3D; 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,4], target &#x3D; 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,3], target &#x3D; 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 104</span><br><span class="line">-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</span><br><span class="line">-109 &lt;&#x3D; target &lt;&#x3D; 109</span><br><span class="line">只会存在一个有效答案</span><br><span class="line">进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一种解法暴力解决，两层循环就可以实现，这个时间复杂度有点大，所以我们可以尝试优化一下。</p><p>第二种方法利用hash来解决，因为每个数都是只有一个，所以我们用hash来存储每个数字和其位置，在hash中以数字作为索引，其位置作为值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; List[int]:</span></span><br><span class="line">        hash = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> hash.get(target - num) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> (hash.get(target - num), i)</span><br><span class="line">            hash[num] = i</span><br></pre></td></tr></table></figure><h1 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [0], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">每个链表中的节点数在范围 [1, 100] 内</span><br><span class="line">0 &lt;&#x3D; Node.val &lt;&#x3D; 9</span><br><span class="line">题目数据保证列表表示的数字不含前导零</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种</p></blockquote><p>需要考虑两个值，第一个是当前位相加的和tmp，第二个是进位cp。</p><p>我们这里首先是把l1和l2的值保存下来，然后再想办法新建一个链表保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        nums2 = []</span><br><span class="line">        nums1 = []</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                nums1.append(l1.val)</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                nums2.append(l2.val)</span><br><span class="line">                l2 = l2.next</span><br><span class="line">        head = cur = ListNode(<span class="literal">None</span>)</span><br><span class="line">        cp, tmp = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 进位，求和</span></span><br><span class="line">        <span class="keyword">while</span> nums1 <span class="keyword">or</span> nums2:</span><br><span class="line">            tmp = cp</span><br><span class="line">            <span class="keyword">if</span> nums1:</span><br><span class="line">                tmp += nums1.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> nums2:</span><br><span class="line">                tmp += nums2.pop(<span class="number">0</span>)</span><br><span class="line">            cur.next = ListNode(tmp % <span class="number">10</span>, <span class="literal">None</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            cp = tmp // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> cp:</span><br><span class="line">            cur.next = ListNode(cp, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><blockquote><p>优化，不需要用nums保存</p></blockquote><p>直接边读取数据，边保存到新的链表中。原理和上面的一样，但是降低了空间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        cp, tmp = <span class="number">0</span>, <span class="number">0</span>  <span class="comment"># 进位，求和</span></span><br><span class="line">        head = cur = ListNode(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            tmp = cp</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                tmp += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                tmp += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            cur.next = ListNode(tmp % <span class="number">10</span>, <span class="literal">None</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">            cp = tmp // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> cp:</span><br><span class="line">            cur.next = ListNode(cp, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> head.next</span><br></pre></td></tr></table></figure><h1 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：滑动窗口</p></blockquote><p>用i和j-1来表示当前子串的长度，当前元素s[j]如果在s[i:j]中的话，就说明已经存在重复了，这时候窗口左侧i就需要移动；当前元素s[j]如果不在s[i:j]中的话，说明依然是无重复元素，右侧j继续移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        i, j, n = <span class="number">0</span>, <span class="number">0</span>, len(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[j] <span class="keyword">not</span> <span class="keyword">in</span> s[i:j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            ans = max(ans, j - i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：hash表</p></blockquote><p>这种方法的时间和空间复杂度都要更有优势，我们用字典来作为hash的结构保存元素以及元素的位置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s: str) -&gt; int:</span><br><span class="line">        hash &#x3D; &#123;&#125;</span><br><span class="line">        i, ans &#x3D; 0, 0</span><br><span class="line">        for j, ch in enumerate(s):</span><br><span class="line">            if ch in hash:</span><br><span class="line">                i &#x3D; max(i, hash[ch])</span><br><span class="line">            ans &#x3D; max(ans, j - i + 1)</span><br><span class="line">            hash[ch] &#x3D; j + 1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 O(log (m+n)) 。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [0,0], nums2 &#x3D; [0,0]</span><br><span class="line">输出：0.00000</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [], nums2 &#x3D; [1]</span><br><span class="line">输出：1.00000</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2], nums2 &#x3D; []</span><br><span class="line">输出：2.00000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">nums1.length &#x3D;&#x3D; m</span><br><span class="line">nums2.length &#x3D;&#x3D; n</span><br><span class="line">0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; m + n &lt;&#x3D; 2000</span><br><span class="line">-106 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 106</span><br></pre></td></tr></table></figure><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种：合并、排序</p></blockquote><p>非常简单暴力的思路，也能够通过测试点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[int], nums2: List[int]</span>) -&gt; float:</span></span><br><span class="line">        nums3 = nums1 + nums2</span><br><span class="line">        nums3.sort()</span><br><span class="line">        l3 = len(nums3)</span><br><span class="line">        <span class="keyword">if</span> l3 % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            a = int(l3 / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> (nums3[a] + nums3[a<span class="number">-1</span>]) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = int((l3 + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums3[a]</span><br></pre></td></tr></table></figure><h1 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="解法一：中心扩展算法"><a href="#解法一：中心扩展算法" class="headerlink" title="解法一：中心扩展算法"></a>解法一：中心扩展算法</h2><p>由于回文串是对称的，对于中心扩展算法来说，我们每次选择从回文串的中心向左右两侧扩展，对应位置的元素一定是相同的。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>b</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一种情况：回文串长度为奇数，对于abbba这个回文串来说，它的中心是b（2）；</p><p>第二种情况：回文串长度为偶数，对于baab这个回文串来说，它的中心就是aa(4\5);</p><p>所以我们遍历一个字符串，只需要把把当前位置作为中心，向两侧进行扩展来判断以当前位置为中心的回文串的最大长度是多少就可以了。</p><p>首先定义一个expandAroundCenter函数，来判断制定字符串以及中心的位置，判断以当前位置为中心的最长回文串；</p><p>其次，遍历所有的中心，然后把当前中心的回文串长度与最长长度比较，同时需要更新最长回文串的起始和结束为止；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span>(<span class="params">s, left, right</span>):</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> right - left - <span class="number">1</span>  </span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            len1 = expandAroundCenter(s, i, i)</span><br><span class="line">            len2 = expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">            l = max(len1, len2)</span><br><span class="line">            <span class="keyword">if</span> l &gt; end - start:</span><br><span class="line">                start = i - (l - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                end = i + l // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>时间复杂度：$O（n²）$。两层循环，每层循环都是遍历每个字符。</p><p>空间复杂度：$O（1）$。</p><h2 id="解法二：马拉车算法"><a href="#解法二：马拉车算法" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>具体的讲解请参考这位博主的整理<a href="https://zhuanlan.zhihu.com/p/70532099">https://zhuanlan.zhihu.com/p/70532099</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置和终止位置，也可以不用加起始标记位置</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">            ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">            ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        ret = preProcess(s)</span><br><span class="line">        n = len(ret)</span><br><span class="line">        P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">        C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">            <span class="keyword">if</span> R &gt; i:</span><br><span class="line">                P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">            <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">                P[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        <span class="comment"># 找到最长回文串的位置</span></span><br><span class="line">        maxLen = <span class="number">0</span> </span><br><span class="line">        cnterIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> P[i] &gt; maxLen:</span><br><span class="line">                maxLen = P[i]</span><br><span class="line">                cnterIndex = i</span><br><span class="line">        start = (cnterIndex - maxLen) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+maxLen]</span><br></pre></td></tr></table></figure><p>下面这个是马拉车算法的一般形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">    ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">    ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manacher</span>(<span class="params">s</span>):</span></span><br><span class="line">    ret = preProcess(s)</span><br><span class="line">    n = len(ret)</span><br><span class="line">    P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">    C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">        i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">        <span class="keyword">if</span> R &gt; i:</span><br><span class="line">            P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">        <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">            P[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">            C = i</span><br><span class="line">            R = i + P[i]</span><br><span class="line"> <span class="comment">#     return P</span></span><br><span class="line">  maxLen = <span class="number">0</span> </span><br><span class="line">    cnterIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> P[i] &gt; maxLen:</span><br><span class="line">        maxLen = P[i]</span><br><span class="line">        cnterIndex = i</span><br><span class="line">    start = (cnterIndex - maxLen) // <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> s[start:start+maxLen]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://segmentfault.com/a/1190000008484167">https://segmentfault.com/a/1190000008484167</a></p><p><a href="https://zhuanlan.zhihu.com/p/70532099">https://zhuanlan.zhihu.com/p/70532099</a></p><p><a href="https://blog.crimx.com/2017/07/06/manachers-algorithm/">https://blog.crimx.com/2017/07/06/manachers-algorithm/</a></p><h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/">6. Z 字形变换</a></h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><p>string convert(string s, int numRows);</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;PAYPALISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;A&quot;, numRows &#x3D; 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 1000</span><br><span class="line">s 由英文字母（小写和大写）、&#39;,&#39; 和 &#39;.&#39; 组成</span><br><span class="line">1 &lt;&#x3D; numRows &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种：过于复杂</p></blockquote><p>这一种就是把Z模拟出来，题目的Z是放倒的，我们这里用正Z来表示，row、col分别表示行、列，这样题目中的numRows与col相对应了。</p><p>这个解答有点复杂，首先考虑两种特殊情况， numRows == 1、2的情况，直接返回对应的结果就可以了。对于其他情况，我们用ans来保存结果，在模拟的过程中需要区分当前需要加入到是Z的一横还是一斜。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span>(<span class="params">self, s: str, numRows: int</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">elif</span> numRows == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(s[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s), <span class="number">2</span>)) + <span class="string">&#x27;&#x27;</span>.join(s[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s), <span class="number">2</span>))</span><br><span class="line">        ans = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        row, col = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, ch <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="comment"># z的一横</span></span><br><span class="line">                ans[col].append(ch)</span><br><span class="line">                col += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> col == numRows:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># z的一斜</span></span><br><span class="line">                col -= <span class="number">1</span></span><br><span class="line">                ans[col].append(ch)</span><br><span class="line">                <span class="keyword">if</span> col<span class="number">-1</span> == <span class="number">0</span>:</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    row += <span class="number">1</span></span><br><span class="line">                    col -= <span class="number">1</span></span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> ans:</span><br><span class="line">            res += <span class="string">&#x27;&#x27;</span>.join(ch)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><blockquote><p>第二种：分别保存每一行</p></blockquote><p>我们用一个result数组来分别保存每一行的结果，如果是一横，说明i是递增的，所以每次i+=1；如果是一斜，说明i是递减的，每次i-=1；我们用flag来表示什么时候反转，+1的时候flag=1，-1的时候flag=-1；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convert(self, s: str, numRows: int) -&gt; str:</span><br><span class="line">        if numRows &lt; 2:</span><br><span class="line">            return s</span><br><span class="line">        result &#x3D; [&#39;&#39; for _ in range(numRows)]</span><br><span class="line">        i, flag &#x3D; 0, -1</span><br><span class="line">        for ch in s:</span><br><span class="line">            result[i] +&#x3D; ch</span><br><span class="line">            if i &#x3D;&#x3D; 0 or i &#x3D;&#x3D; numRows - 1:</span><br><span class="line">                flag &#x3D; -flag</span><br><span class="line">            i +&#x3D; flag</span><br><span class="line">        return &#39;&#39;.join(result)</span><br></pre></td></tr></table></figure><h1 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">-2**31 &lt;&#x3D; x &lt;&#x3D; 2**31 - 1</span><br></pre></td></tr></table></figure><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：简单模拟，翻转一下就可以，直接保存下来</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: int</span>) -&gt; int:</span></span><br><span class="line">        x = str(x)</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> <span class="keyword">or</span> x[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            start = <span class="number">1</span></span><br><span class="line">        n = len(x)</span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, start<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            ans += x[i]</span><br><span class="line">        <span class="keyword">if</span> start == <span class="number">0</span> <span class="keyword">or</span> x[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> int(ans) &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> int(ans)</span><br><span class="line">        <span class="keyword">elif</span> x[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> int(ans) &gt; <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -int(ans)</span><br></pre></td></tr></table></figure><blockquote><p>第二种：数学方法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: int</span>) -&gt; int:</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        x1 = x</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            x = -x</span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            tmp = x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">            num = num * <span class="number">10</span> + tmp</span><br><span class="line">        <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">2</span> ** <span class="number">31</span>:</span><br><span class="line">            <span class="keyword">return</span> -num</span><br><span class="line">        <span class="keyword">elif</span> x1 &gt; <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ul><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code> ，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li><li>返回整数作为最终结果。</li></ul><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>&#39; &#39;</code> 。</li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           ^</span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            ^</span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">             ^</span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               ^</span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             ^</span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;words and 987&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;words and 987&quot;（当前没有读入字符，因为这里不存在 &#39;-&#39; 或者 &#39;+&#39;）</span><br><span class="line">         ^</span><br><span class="line">第 3 步：&quot;words and 987&quot;（由于当前字符 &#39;w&#39; 不是一个数字，所以读入停止）</span><br><span class="line">         ^</span><br><span class="line">解析得到整数 0 ，因为没有读入任何数字。</span><br><span class="line">由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;-91283472332&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         ^</span><br><span class="line">第 2 步：&quot;-91283472332&quot;（读入 &#39;-&#39; 字符，所以结果应该是负数）</span><br><span class="line">          ^</span><br><span class="line">第 3 步：&quot;-91283472332&quot;（读入 &quot;91283472332&quot;）</span><br><span class="line">                     ^</span><br><span class="line">解析得到整数 -91283472332 。</span><br><span class="line">由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 &#x3D; -2147483648 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由英文字母（大写和小写）、数字（<code>0-9</code>）、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li></ul><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>简单的字符串模拟，首先把左侧的空格都去除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, s: str) -&gt; int:</span><br><span class="line">        s &#x3D; s.lstrip(&#39; &#39;)</span><br><span class="line">        res &#x3D; &#39;&#39;</span><br><span class="line">        for ch in s:</span><br><span class="line">            if (ch &#x3D;&#x3D; &#39;+&#39; or ch &#x3D;&#x3D; &#39;-&#39;) and not res:</span><br><span class="line">                res +&#x3D; ch</span><br><span class="line">            elif &#39;0&#39; &lt;&#x3D; ch &lt;&#x3D; &#39;9&#39;:</span><br><span class="line">                res +&#x3D; ch</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        print(res)</span><br><span class="line">        if not res or (len(res) &#x3D;&#x3D; 1 and (res[0] &#x3D;&#x3D; &#39;+&#39; or res[0] &#x3D;&#x3D; &#39;-&#39;)):</span><br><span class="line">            return 0</span><br><span class="line">        if int(res) &gt; 2 ** 31 - 1:</span><br><span class="line">            return 2 ** 31 - 1</span><br><span class="line">        elif int(res) &lt; - 2 ** 31:</span><br><span class="line">            return - 2 ** 31</span><br><span class="line">        else:</span><br><span class="line">            return int(res)</span><br></pre></td></tr></table></figure><h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/">9. 回文数</a></h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x &#x3D; -101</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= x &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：数学模拟</p></blockquote><p>首先判断一下一些特例：例如负数，能够整除10且不为0；</p><p>其次就是把数字的reverse求出来，然后判断一下是否相等；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:</span><br><span class="line">        if x &lt; 0 or (x % 10 &#x3D;&#x3D; 0 and x !&#x3D; 0):</span><br><span class="line">            return False</span><br><span class="line">        reverse &#x3D; 0</span><br><span class="line">        while x &gt; reverse:</span><br><span class="line">            reverse &#x3D; reverse * 10 + x % 10</span><br><span class="line">            x &#x2F;&#x2F;&#x3D; 10</span><br><span class="line">        return x &#x3D;&#x3D; reverse or x &#x3D;&#x3D; reverse &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure><blockquote><p>第二种：转换为字符串</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:</span><br><span class="line">        if x &lt; 0:</span><br><span class="line">            return False</span><br><span class="line">        x &#x3D; str(x)</span><br><span class="line">        left, right &#x3D; 0, len(x) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            if x[left] !&#x3D; x[right]:</span><br><span class="line">                return False</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], n &#x3D; 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], n &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>要删除倒数第N个节点，必须要想找到倒数第N个节点的前驱。想要查找倒数第N个，可以使用快慢指针fast，让快指针先走N步，然后再让慢指针slow出发，这样当fast到达终点之后，慢指针指向的就是倒数第N个节点。</p><p>这一题需要注意的是需要加一个新的头节点，这样在删除头节点的时候，就可以保证不断开，例如[1,2]删除倒数第二个（也就是头节点），就可以保证不断开了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: int</span>) -&gt; ListNode:</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        fast = slow = new_head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast.next:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        slow.next = slow.next.next</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">两个链表的节点数目范围是 [0, 50]</span><br><span class="line">-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</span><br><span class="line">l1 和 l2 均按 非递减顺序 排列</span><br></pre></td></tr></table></figure><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：递归</p></blockquote><p>递归不是很好理解，建议参考下面的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: Optional[ListNode], list2: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &gt;= list2.val:</span><br><span class="line">                list1, list2 = list2, list1</span><br><span class="line">            list1.next = self.mergeTwoLists(list1.next, list2)</span><br><span class="line">        <span class="keyword">return</span> list1 <span class="keyword">or</span> list2</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：双指针</p></blockquote><p>当list1和list2都不为空的时候，我们就可以把两个链表中的小节点加入到新的链表尾部，然后双指针不停后移。</p><p>如果其中一个为空了，说明剩下的那个链表可以直接加入到尾部即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, list1: Optional[ListNode], list2: Optional[ListNode]</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        dummpy = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        cur = dummpy</span><br><span class="line">        <span class="keyword">while</span> list1 <span class="keyword">and</span> list2:</span><br><span class="line">            <span class="keyword">if</span> list1.val &lt;= list2.val:</span><br><span class="line">                cur.next = list1</span><br><span class="line">                list1 = list1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = list2</span><br><span class="line">                list2 = list2.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> list1:</span><br><span class="line">            cur.next = list1</span><br><span class="line">        <span class="keyword">if</span> list2:</span><br><span class="line">            cur.next = list2</span><br><span class="line">        <span class="keyword">return</span> dummpy.next</span><br></pre></td></tr></table></figure><h1 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p> 示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">k &#x3D;&#x3D; lists.length</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 10^4</span><br><span class="line">0 &lt;&#x3D; lists[i].length &lt;&#x3D; 500</span><br><span class="line">-10^4 &lt;&#x3D; lists[i][j] &lt;&#x3D; 10^4</span><br><span class="line">lists[i] 按 升序 排列</span><br><span class="line">lists[i].length 的总和不超过 10^4</span><br></pre></td></tr></table></figure><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：借助小根堆</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        heap = []</span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        cur = new_head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, head <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                heapq.heappush(heap, (head.val, idx))</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            _, idx = heapq.heappop(heap)</span><br><span class="line">            node = lists[idx]</span><br><span class="line">            <span class="comment"># 加入到新链表中</span></span><br><span class="line">            cur.next = node</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> node.next:</span><br><span class="line">                <span class="comment"># 让新加入的头节点位置后移一个，并把当前头节点加入到堆中</span></span><br><span class="line">                lists[idx] = node.next</span><br><span class="line">                heapq.heappush(heap, (lists[idx].val, idx))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><blockquote><p>第二种：借助栈</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        cur = new_head</span><br><span class="line">        <span class="keyword">for</span> head <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                stack.append(head)</span><br><span class="line">        stack.sort(key=<span class="keyword">lambda</span> x: x.val)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node.next:</span><br><span class="line">                stack.append(node.next)</span><br><span class="line">            stack.sort(key=<span class="keyword">lambda</span> x: x.val)</span><br><span class="line">            cur.next = node</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><h1 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h1><p>难度困难1448</p><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>进阶：</strong></p><ul><li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], k &#x3D; 1</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], k &#x3D; 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中节点的数量在范围 <code>sz</code> 内</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种：迭代</p></blockquote><p>这个题目的难度在于对于不满足k个，需要特殊处理一下，其他的都是正常操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: Optional[ListNode], k: int</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        pre = post = new_head</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            cur = head</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">            cur.next = pre.next</span><br><span class="line">            pre.next = cur</span><br><span class="line">            <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                post = cur</span><br><span class="line">            <span class="keyword">elif</span> cnt == k:</span><br><span class="line">                pre = post</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cnt != k:</span><br><span class="line">            head = pre.next</span><br><span class="line">            pre.next = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                start = head</span><br><span class="line">                head = head.next</span><br><span class="line">                start.next = pre.next</span><br><span class="line">                pre.next = start</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><blockquote><p>第二种：递归</p></blockquote><p>reverse函数只负责反转head&gt;tail，然后递归调用，定义一个new_head，然后再递归b后面的元素。</p><p>如果不满足k个，直接返回head。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">self, head: Optional[ListNode], k: int</span>) -&gt; Optional[ListNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        a, b = head, head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            b = b.next</span><br><span class="line">        new_head = self.reverse(a, b)</span><br><span class="line">        a.next = self.reverseKGroup(b, k)</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, head, tail</span>):</span></span><br><span class="line">            pre, cur, post = <span class="literal">None</span>, head, head</span><br><span class="line">            <span class="keyword">while</span> cur != tail:</span><br><span class="line">                post = cur.next</span><br><span class="line">                cur.next = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = post</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        <span class="comment"># return reverse(head)</span></span><br></pre></td></tr></table></figure><h1 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></h1><p>难度简单1245收藏分享切换为英文接收动态反馈</p><p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p><p><strong>说明：</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= haystack.length, needle.length &lt;= 5 * 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：暴力求解</p></blockquote><p>暴力求解就是每次都从needle的开头进行匹配，如果不符合，haystack从上一次开始的下一位置，needle的开头进行继续匹配。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: str, needle: str</span>) -&gt; int:</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line">        <span class="comment"># if haystack == needle:</span></span><br><span class="line">        <span class="comment">#     return 0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m-n+<span class="number">1</span>):</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i+n] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：KMP算法</p></blockquote><p>KMP算法是利用了pattern匹配串的前缀和后缀原理，详情可以看一下下面这个链接中的视频讲解来理解一下，简单易懂，代码我用Python在下面复现了一下。</p><p><a href="https://www.bilibili.com/video/BV18k4y1m7Ar?from=search&seid=11259010841013900216&spm_id_from=333.337.0.0">这个视频是我认为讲解最好的：KMP算法讲解</a></p><p>首先第一步是建立next数组；</p><p>第二步是利用next数组来进行模式匹配，每次如果遇到不匹配的情况，i指针不需要跳转到上一次开头的下一个位置，j指针也不需要跳转到0.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, text: str, pattern: str</span>) -&gt; int:</span></span><br><span class="line">        n, m = len(text), len(pattern)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;建立next数组&quot;&quot;&quot;</span></span><br><span class="line">        next = [<span class="number">0</span>] * m</span><br><span class="line">        i, j = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m:</span><br><span class="line">            <span class="keyword">if</span> pattern[i] == pattern[j]:</span><br><span class="line">                next[i] = j + <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                    j = next[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    next[i] = <span class="number">0</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(next)</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;进行模式匹配&quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> text[i] == pattern[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> j != <span class="number">0</span>:</span><br><span class="line">                    j = next[j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == m:</span><br><span class="line">                <span class="keyword">return</span> i - m</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 0</span><br><span class="line">输出：-1 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><p><strong>进阶：</strong>你可以设计一个时间复杂度为 <code>O(log n)</code> 的解决方案吗？</p><h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><p>我们可以知道左右两侧都是递增有序的，所以我们用mid把[left, right]分为两段，在mid左右两侧，必然有一侧是有序的，我们首先在有序的里面进行查找。根据有序部分，我们再比较target的大小是否在这个有序部分里面，来调整left和right的边界问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        right = len(nums) - <span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = int(left+right)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[right]: <span class="comment"># 右半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &amp; target &lt;= nums[right]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:   <span class="comment"># 左半部分有序</span></span><br><span class="line">                <span class="keyword">if</span> nums[left] &lt;= target &amp; target &lt; nums[mid]:</span><br><span class="line">                    right = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h1><p>难度困难1598</p><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong></p><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ADOBECODEBANC&quot;, t &#x3D; &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;, t &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;a&quot;, t &#x3D; &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#39;a&#39; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><p><strong>进阶：</strong>你能设计一个在 <code>o(n)</code> 时间内解决此问题的算法吗？</p><h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><ul><li><p>定义两个hash，第一个hash_t来存储t中的字母及其数量，第二个hash_s存储滑动窗口中的字母及其数量。</p></li><li><p>定义一个check()函数，来比较这两个hash是否符合要求（hash_s &gt; hash_t）；</p><ul><li>如果不符合返回false，此时right+=1，并且判断s[right]这个字符是否在t中，如果在hash_s对应位置减1；</li><li>如果符合要求返回true，判断s[left]这个字符是否在t中，如果在hash_s对应位置加1，此时left+=1。</li><li>上面两个，对于left和right，是先加1还是先判断字符是否在需要分清。</li></ul></li><li><p>定义left和right来标记窗口的位置；定义start和end来标记子串的位置；</p></li><li><p>定义flag来标记是否发现子串，如果没有发现就返回空，发现了就返回子串。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span>(<span class="params">self, s: str, t: str</span>) -&gt; str:</span></span><br><span class="line">        </span><br><span class="line">        hash_t = collections.defaultdict(int)</span><br><span class="line">        hash_s = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> t:</span><br><span class="line">            hash_t[ch] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> t:</span><br><span class="line">            hash_s[s[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        start, end = <span class="number">0</span>, n - <span class="number">1</span>   <span class="comment"># 记录开始和结束为止</span></span><br><span class="line">        flag = <span class="literal">True</span>     <span class="comment"># 标记是否发现子串</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">if</span> self.check(hash_t, hash_s) <span class="keyword">and</span> left &lt;= right:</span><br><span class="line">                <span class="keyword">if</span> right - left &lt;= end - start:</span><br><span class="line">                    start, end = left, right</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> s[left] <span class="keyword">in</span> t:</span><br><span class="line">                    hash_s[s[left]] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right += <span class="number">1</span> </span><br><span class="line">                <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> s[right] <span class="keyword">in</span> t:</span><br><span class="line">                    hash_s[s[right]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>] <span class="keyword">if</span> <span class="keyword">not</span> flag <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">self, hash_t, hash_s</span>):</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> hash_t.items():</span><br><span class="line">            <span class="keyword">if</span> hash_s[key] &lt; value:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>难度中等1137</p><p>给你单链表的头指针 <code>head</code> 和两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>left &lt;= right</code> 。请你反转从位置 <code>left</code> 到位置 <code>right</code> 的链表节点，返回 <strong>反转后的链表</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4</span><br><span class="line">输出：[1,4,3,2,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1</span><br><span class="line">输出：[5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>链表中节点数目为 <code>n</code></p></li><li><p><code>1 &lt;= n &lt;= 500</code></p></li><li><p><code>-500 &lt;= Node.val &lt;= 500</code></p></li><li><p><code>1 &lt;= left &lt;= right &lt;= n</code></p><p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p></li></ul><h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><blockquote><p> 第一种：采用头插法插入节点</p></blockquote><p>pre：代表需要插入的节点起始位置；post代表已经反转的最后一个位置，post要始终与后面的链表保持连接，不能断链。</p><p>s：代表需要移除的节点，我们每次把这个节点从post后面断开，然后插入到前面的位置中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">self, head: ListNode, left: int, right: int</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> left == right:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre, post = new_head, new_head.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">            post = post.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(right - left):</span><br><span class="line">            s = post.next</span><br><span class="line">            post.next = post.next.next</span><br><span class="line">            s.next = pre.next</span><br><span class="line">            pre.next = s</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><blockquote><p>第二种：递归解法</p></blockquote><p>首先看一下递归反转前n个链表如何实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseN(head, n):</span><br><span class="line">        if n &#x3D;&#x3D; 1:</span><br><span class="line">            sucessor &#x3D; head.next</span><br><span class="line">            return head</span><br><span class="line">        last &#x3D; self.reverseN(head.next, n-1)</span><br><span class="line">        head.next.next &#x3D; head</span><br><span class="line">        head.next &#x3D; sucessor</span><br><span class="line">        return last</span><br></pre></td></tr></table></figure><p>上面是递归反转前n个节点，如果是反转[m, n]节点的话，首先我们判断m是否等于1，如果等于1，相当于把前n个进行反转，如果不等于1，head就一直往后迭代找到知道等于1为止。</p><h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h1><p>难度中等1121收藏分享切换为英文接收动态反馈</p><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><p>回溯算法来实现这个题目的解决。</p><p>定义backtrack(start, end)，边界：start&gt;end找到边界，返回一个空元素；</p><p>我们用i作为根节点，然后left、right分别保存左右子树，然后再遍历left和right把所有的情况组合起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span>(<span class="params">self, n: int</span>) -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">start, end</span>):</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">if</span> start &gt; end:</span><br><span class="line">                res.append(<span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                left = backtrack(start, i<span class="number">-1</span>)</span><br><span class="line">                right = backtrack(i+<span class="number">1</span>, end)</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> right:</span><br><span class="line">                        root = TreeNode(i)</span><br><span class="line">                        root.left = l</span><br><span class="line">                        root.right = r</span><br><span class="line">                        res.append(root)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> backtrack(<span class="number">1</span>, n) <span class="keyword">if</span> n <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>难度中等1533收藏分享切换为英文接收动态反馈</p><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：动态规划</p></blockquote><p>dp[i]表示i个节点能够构成多少种BST二叉搜索树。</p><p>由于题目给的是n个节点，我们用i作为根节点，然后求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">                dp[i] += dp[j<span class="number">-1</span>] * dp[i - j]</span><br><span class="line">        print(dp)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>难度中等1398</p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><p>递归解法，给你一个根节点，以及左右节点的值，只要判断根节点值大于左节点，小于右节点即可；然后再递归判断左右子树。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">BFS</span>(<span class="params">root, left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; root.val &lt; right:</span><br><span class="line">                <span class="keyword">return</span> BFS(root.left, left, root.val) <span class="keyword">and</span> BFS(root.right, root.val, right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> BFS(root, -float(<span class="string">&#x27;inf&#x27;</span>), float(<span class="string">&#x27;inf&#x27;</span>))</span><br></pre></td></tr></table></figure><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><p>难度简单1097</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：递归</p></blockquote><p>边界：如果是空节点，直接返回深度为0；</p><p>递归：递归左侧最大深度；递归右侧最大深度；两者取最大值，然后并返回结果➕1（根节点深度）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftMax = self.maxDepth(root.left)</span><br><span class="line">        rightMax = self.maxDepth(root.right)</span><br><span class="line">        depth = max(leftMax, rightMax) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>难度中等1395</p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder &#x3D; [-1], inorder &#x3D; [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><p>前序和中序构造二叉树：根据前序判断根节点，然后把中序按照根节点分类两段，同时把根据中序的两段把前序分为三段（第一段为根节点-第一个值，以及左子树节点、右子树节点）</p><p>边界：如果preorder为空，说明返回空，已经没有根节点了。</p><p>递归：preorder第一个元素用来构建根节点rootVal，根据rootVal把inorder分为两段，并找到rootVal在inorder中的位置idx；接下来把preorder分为三段，第一段是第一个不用管，第二段的结尾与idx位置相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: List[int], inorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 建立根节点</span></span><br><span class="line">        rootVal = preorder[<span class="number">0</span>]</span><br><span class="line">        idx = inorder.index(rootVal)  <span class="comment"># inorder中的索引</span></span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:idx+<span class="number">1</span>], inorder[:idx])</span><br><span class="line">        root.right= self.buildTree(preorder[idx+<span class="number">1</span>:], inorder[idx+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h1><p>难度中等659</p><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder &#x3D; [-1], postorder &#x3D; [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= inorder.length &lt;= 3000</code></li><li><code>postorder.length == inorder.length</code></li><li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li><li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li><li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li><li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li><li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li></ul><h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><p>根据中序和后序建立二叉树、根绝前序和中序建立二叉树，二者都有相同的地方，唯一的不同就是后序的根节点在最后，前序的根节点在最前面。</p><table><thead><tr><th>构建二叉树（异同）</th><th>中序+前序</th><th>中序+后序</th></tr></thead><tbody><tr><td>根节点</td><td>前序的<strong>第一个节点</strong>为根节点可以把中序分为三段inorder[:idx]、inorder[idx]、inorder[idx+1:]</td><td>后序的<strong>最后一个节点</strong>为根节点可以把中序分为三段inorder[:idx]、inorder[idx]、inorder[idx+1:]</td></tr><tr><td>根据中序根节点位置idx</td><td>可以把前序分为preorder[0]、preorder[1:idx]、preorder[idx+1:]</td><td>可以把前序分为preorder[:idx]、preorder[idx:len(preorder)-1]、preorder[-1]</td></tr></tbody></table><table><thead><tr><th></th><th>根节点</th><th>根据中序根节点位置idx</th></tr></thead><tbody><tr><td>中序+前序</td><td>前序的<strong>第一个节点</strong>为根节点可以把中序分为三段inorder[:idx]、inorder[idx]、inorder[idx+1:]</td><td>可以把前序分为preorder[0]、preorder[1:idx]、preorder[idx+1:]</td></tr><tr><td>中序+后序</td><td>后序的<strong>最后一个节点</strong>为根节点可以把中序分为三段inorder[:idx]、inorder[idx]、inorder[idx+1:]</td><td>可以把前序分为preorder[:idx]、preorder[idx:len(preorder)-1]、preorder[-1]</td></tr><tr><td>前序+后序</td><td>前序第一个节点或后序最后一个节点为根节点</td><td>首先根据前序第二个节点，找到在后序中的位置idx，这样后序可以分为preorder[:idx]、preorder[idx:len(preorder)-1]、preorder[-1]。<br>可以把前序分为preorder[0]、preorder[1:idx]、preorder[idx+1:]</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 建立根节点</span></span><br><span class="line">        rootVal = postorder[<span class="number">-1</span>]</span><br><span class="line">        idx = inorder.index(rootVal)  <span class="comment"># inorder中的索引</span></span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        root.left = self.buildTree(inorder[:idx+<span class="number">1</span>], postorder[:idx])</span><br><span class="line">        root.right= self.buildTree(inorder[idx+<span class="number">1</span>:], postorder[idx:len(postorder)<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h1><p>难度中等1049</p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以使用原地算法（<code>O(1)</code> 额外空间）展开这棵树吗？</p><h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="comment"># 1、把左右子树变成单链表</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        <span class="comment"># 2、把根节点左侧变为空，左子树连接到右子树</span></span><br><span class="line">        left, right = root.left, root.right</span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        root.right = left</span><br><span class="line">        <span class="comment"># 3、原先的右子树连接到当前右子树上</span></span><br><span class="line">        p = root</span><br><span class="line">        <span class="keyword">while</span> p.right:</span><br><span class="line">            p = p.right</span><br><span class="line">        p.right = right</span><br></pre></td></tr></table></figure><h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h1><p>难度中等660</p><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数量在 <code>[0, 212 - 1]</code> 范围内</li><li><code>-1000 &lt;= node.val &lt;= 1000</code></li></ul><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><p>因为是一个完美二叉树，所以每个根节点都会有左右两个字节点。</p><p>对于一行的节点，首先是left.left和left.right，以及right.left和right.right，需要把这一行都连接起来才可以。</p><p>既要考虑相同父节点的节点，也要考虑不同父节点的字节点连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            left.next = right</span><br><span class="line">            left = left.right</span><br><span class="line">            right = right.left</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.connectTwoNode(root.left, root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectTwoNode</span>(<span class="params">self, node1, node2</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">or</span> <span class="keyword">not</span> node2:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        node1.next = node2</span><br><span class="line">        <span class="comment"># 相同的父节点</span></span><br><span class="line">        self.connectTwoNode(node1.left, node1.right)</span><br><span class="line">        self.connectTwoNode(node2.left, node2.right)</span><br><span class="line">        <span class="comment"># 不同的父节点</span></span><br><span class="line">        self.connectTwoNode(node1.right, node2.left)</span><br></pre></td></tr></table></figure><h1 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h1><p>难度中等500</p><p>给定一个二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><p><strong>进阶：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><p><strong>示例：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），&#39;#&#39; 表示每层的末尾。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数小于 <code>6000</code></li><li><code>-100 &lt;= node.val &lt;= 100</code></li></ul><h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><p>这一题用递归会比较麻烦，我用的是层次遍历，把每一层的节点都连接起来就可以了。</p><p>用递归也是可以的，需要考虑太多情况，因为会存在左右节点为空的情况，稍微比上一题复杂很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            n = len(nodeQueue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    node.next = nodeQueue[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodeQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h1><p>难度困难1406</p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        self.ans = float(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 求左边的值，如果为负数就不加入路径，为正数就加入路径</span></span><br><span class="line">            left = max(<span class="number">0</span>, postOrder(root.left))</span><br><span class="line">            <span class="comment"># 求右边的值，如果为负数就不加入路径，正数则加入路径</span></span><br><span class="line">            right = max(<span class="number">0</span>, postOrder(root.right))</span><br><span class="line">            <span class="comment"># 把当前路径与之前最大路径比较</span></span><br><span class="line">            self.ans = max(self.ans, left + right + root.val)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 返回当前节点加入到上一层路径能够给的最大贡献值</span></span><br><span class="line">            <span class="keyword">return</span> max(left, right) + root.val</span><br><span class="line">        postOrder(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 104]</code></li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：快慢指针</p></blockquote><p>同样运用快慢指针，这个理解起来可能稍微有点困难，快指针fast每次走两步，慢指针slow每次走一步，如果存在闭环的话，若干步之后fast和slow一定能够相遇。</p><p>这个原理叫做：「Floyd 判圈算法」，感兴趣的话可以看一下其他博主的解释及证明即可，不是太难理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                print(fast.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：hash表</p></blockquote><p>每次都把节点保存下来，如果下次再遇到这个节点说明这个节点就是环的入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        hash = set()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> hash:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            hash.add(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2], pos &#x3D; 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1], pos &#x3D; -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p><h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种：快慢指针</p></blockquote><p>先找到两个fast和slow碰头的地方，然后让fast从头走，看看下次见面的地方就是了。这个我不太理解具体的解答，放在这里下次思考。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span>(fast <span class="keyword">and</span> fast.next):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast != slow:</span><br><span class="line">            fast, slow = fast.next, slow.next</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure><blockquote><p>第二种：hash表</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        hash = set()</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> hash:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            hash.add(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>难度简单723</p><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h1><p>难度中等1903</p><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache &#x3D; new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1&#125;</span><br><span class="line">lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 &#123;1&#x3D;1, 2&#x3D;2&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 1</span><br><span class="line">lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 &#123;1&#x3D;1, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 &#123;4&#x3D;4, 3&#x3D;3&#125;</span><br><span class="line">lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    &#x2F;&#x2F; 返回 3</span><br><span class="line">lRUCache.get(4);    &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="comment"># 定义一个hashMap以及双向链表</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: int</span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125;   <span class="comment"># 保存的是key和节点（value）对</span></span><br><span class="line">        <span class="comment"># 头指针和尾指针</span></span><br><span class="line">        self.head = ListNode(<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        self.tail = ListNode(<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_node_to_tail</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="comment"># 把某个节点放到尾节点前</span></span><br><span class="line">        node = self.hashmap[key]</span><br><span class="line">        <span class="comment"># 从链表中删除node节点</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 把node插入到tail之前</span></span><br><span class="line">        node.next = self.tail</span><br><span class="line">        node.prev = self.tail.prev</span><br><span class="line">        self.tail.prev.next = node</span><br><span class="line">        self.tail.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># 如果key在hashmap中，需要把可以移到末尾</span></span><br><span class="line">            self.move_node_to_tail(key)</span><br><span class="line">        result = self.hashmap.get(key, <span class="number">-1</span>)  <span class="comment"># 获得key的结果，如果key不存在返回-1</span></span><br><span class="line">        <span class="keyword">if</span> result == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> result.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: int, value: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># 如果key在hashmap中，需要更改key的值，然后把key的节点移到末尾</span></span><br><span class="line">            self.hashmap[key].value = value</span><br><span class="line">            self.move_node_to_tail(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果可以不在hashmap，就需要加入到hashmap以及链表中</span></span><br><span class="line">            <span class="keyword">if</span> len(self.hashmap) == self.capacity:</span><br><span class="line">                <span class="comment"># 超过最大capacity，就需要把头节点后的一个节点值弹出，并且链表也需要删除该节点</span></span><br><span class="line">                self.hashmap.pop(self.head.next.key)</span><br><span class="line">                self.head.next = self.head.next.next</span><br><span class="line">                self.head.next.prev = self.head</span><br><span class="line">            <span class="comment"># 将新key简历一个节点，插入到tail前面</span></span><br><span class="line">            new = ListNode(key, value)</span><br><span class="line">            self.hashmap[key] = new</span><br><span class="line">            new.next = self.tail</span><br><span class="line">            new.prev = self.tail.prev</span><br><span class="line">            self.tail.prev.next = new</span><br><span class="line">            self.tail.prev = new</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><h1 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p>插入排序算法：</p><p>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。<br>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。<br>重复直到所有输入数据插入完为止。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><p>直接建立一个头节点，然后把新的head弹出，插入进来即可。</p><p>第二个代码是把pre和post用pre一个来代替，其他的部分一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node = head</span><br><span class="line">            head = head.next</span><br><span class="line">            node.next = <span class="literal">None</span></span><br><span class="line">            pre, post = new_head, new_head.next</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> post:</span><br><span class="line">                <span class="keyword">if</span> post.val &lt; node.val:</span><br><span class="line">                    pre, post = pre.next, post.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = node</span><br><span class="line">                    node.next = post</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                pre.next = node</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            node = head</span><br><span class="line">            head = head.next</span><br><span class="line">            pre = new_head</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> pre.next:</span><br><span class="line">                <span class="keyword">if</span> pre.next.val &lt; node.val:</span><br><span class="line">                    pre = pre.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node.next = pre.next</span><br><span class="line">                    pre.next = node</span><br><span class="line">                    flag = <span class="literal">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                pre.next = node</span><br><span class="line">                node.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><h1 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h1><p>难度中等651</p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><blockquote><p>二分查找</p></blockquote><p>因为经过了一定的旋转，所以我们在右边有序中，不断右移right，然后最后返回left即有序数组最左边元素最小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                <span class="comment"># 右边有序</span></span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 左边有序</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h1 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></h1><p>难度困难445</p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,4,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,4]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,4,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,5]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><p><strong>进阶：</strong></p><ul><li>这道题是 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/description/">寻找旋转排序数组中的最小值</a> 的延伸题目。</li><li>允许重复会影响算法的时间复杂度吗？会如何影响，为什么？</li></ul><h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><p>为了寻找最小值，我们还是用二分法，首先是如果nums[mid] &lt; nums[right]，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[right]:</span><br><span class="line">                right = mid </span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; nums[right]:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] == nums[right]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>难度简单1516</p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Intersected at &#39;8&#39;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Intersected at &#39;2&#39;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种：求两个链表的长度</p></blockquote><p>分别求出来两个链表的长度l1，l2，然后让长的先走弱干步，最后让两者同时走。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有通过</span></span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> null</span><br><span class="line">        l1 = <span class="number">0</span></span><br><span class="line">        head = headA</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l1 += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">        l2 = <span class="number">0</span></span><br><span class="line">        head = headB</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l2 += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="comment"># 交换，把长的放在headAA，短的放在headB</span></span><br><span class="line">        <span class="keyword">if</span> l2 &gt; l1:</span><br><span class="line">            headA, headB = headB, headA</span><br><span class="line">            l1, l2 = l2, l1</span><br><span class="line">        <span class="comment"># 跳过多余的节点</span></span><br><span class="line">        <span class="keyword">while</span> l1 &gt; l2:</span><br><span class="line">            headA = headA.next</span><br><span class="line">            l1 -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l2 &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> headA == headB:</span><br><span class="line">                <span class="keyword">return</span> headA</span><br><span class="line">            headA = headA.next</span><br><span class="line">            headB = headB.next</span><br><span class="line">        <span class="keyword">return</span> NULL</span><br></pre></td></tr></table></figure><blockquote><p>第二种：双指针</p></blockquote><p>假设A、B相交，且A的长度大于B的长度。首先是让A、B同时走，然后当B走到终点的时候，让B从A的开头继续走；当A走到终点的时候，让A从B的开头继续走。这样两者一定走到相交的位置碰头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A != B:</span><br><span class="line">            <span class="keyword">if</span> A:</span><br><span class="line">                A = A.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A = headB</span><br><span class="line">            <span class="keyword">if</span> B:</span><br><span class="line">                B = B.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                B = headA </span><br><span class="line">            <span class="comment"># A = A.next if A else headB</span></span><br><span class="line">            <span class="comment"># B = B.next if B else headA</span></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/">189. 轮转数组</a></h1><p>难度中等1290</p><p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p> <strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p> <strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 105</code></p></li><li><p><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p></li><li><p><code>0 &lt;= k &lt;= 105</code></p><p><strong>进阶：</strong></p></li><li><p>尽可能想出更多的解决方案，至少有 <strong>三种</strong> 不同的方法可以解决这个问题。</p></li><li><p>你可以使用空间复杂度为 <code>O(1)</code> 的 <strong>原地</strong> 算法解决这个问题吗？</p></li></ul><h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种</p></blockquote><p>先整体逆序，然后把前k逆序，最后把后n-k个逆序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums[:] = nums[::<span class="number">-1</span>]</span><br><span class="line">        nums[:k] = nums[:k][::<span class="number">-1</span>]</span><br><span class="line">        nums[k:] = nums[k:][::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>第二种</p></blockquote><p>新建立数组保存下来前半部分和后半部分，这样在重新放入到nums中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k = k % n</span><br><span class="line">        nums1 = nums[:n-k]</span><br><span class="line">        nums2 = nums[n-k:]</span><br><span class="line">        <span class="comment"># print(nums1, nums2)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            nums[i] = nums2[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(k, n):</span><br><span class="line">            nums[j] = nums1[j - k]</span><br></pre></td></tr></table></figure><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h1><p>难度简单2230</p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种：迭代（头插法）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        post = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            post = head.next</span><br><span class="line">            head.next = pre</span><br><span class="line">            pre = head</span><br><span class="line">            head = post</span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        new_head = ListNode(<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            post = head.next</span><br><span class="line">            head.next = new_head.next</span><br><span class="line">            new_head.next = head</span><br><span class="line">            head = post</span><br><span class="line">        <span class="keyword">return</span> new_head.next</span><br></pre></td></tr></table></figure><blockquote><p>第二种：递归</p></blockquote><p>对于当前head：head.next.next = head这个是形成了一个head&gt;head.next&gt;head的环，head.next = None加上这一句之后就把head&gt;head.next进行反转变成：head.next&gt;head。</p><p>last = self.reverseList(head.next)是为了能够把剩下的部分也实现反转；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        last = self.reverseList(head.next)</span><br><span class="line">        head.next.next = head</span><br><span class="line">        head.next = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure><h1 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h1><p>难度中等1113</p><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 105</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li></ul><h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><p>这个题目是检测是否存在有向环，如果存在环，说明不能够完成；否则就是能够完成；</p><ul><li>第一：题目给的数组需要转换为邻接表，所以我们写一个函数重新建立图结构；</li><li>第二：由于需要判断是否存在环，需要添加一个visited数组来标记当前元素是否访问过；同时需要添加一个onPath数组来标记当前元素是否在路径上，如果访问到一个元素在路径上说明我们找到了一个环；flag是用来标记是否存在环，初始为False，如果存在环就直接跳出循环。</li><li>第三：因为图会有多个起始点，所以为了找到环，我们需要把图的每个顶点都作为起始点来遍历一遍。</li><li></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses: int, prerequisites: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 这个题目是检测是否存在有向环，如果存在环，说明不能够完成；否则就是能够完成；</span></span><br><span class="line">        graph = self.buildGraph(numCourses, prerequisites)</span><br><span class="line">        print(graph)    </span><br><span class="line">        visited = [<span class="literal">False</span>] * numCourses</span><br><span class="line">        onPath = [<span class="literal">False</span>] * numCourses</span><br><span class="line">        self.flag = <span class="literal">False</span>    <span class="comment"># 标记是否找到了环</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> onPath[s]:   </span><br><span class="line">                self.flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> visited[s] <span class="keyword">or</span> self.flag:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            onPath[s] = <span class="literal">True</span></span><br><span class="line">            visited[s] = <span class="literal">True</span>   <span class="comment"># 标记已经访问了</span></span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> graph[s]:</span><br><span class="line">                traverse(p)</span><br><span class="line">            onPath[s] = <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            traverse(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.flag</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span>(<span class="params">self, numCourses, prerequisites</span>):</span></span><br><span class="line">        <span class="comment"># 建立图结构，邻接表法</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="keyword">for</span> e, s <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[s].append(e)</span><br><span class="line">        <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure><h1 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode-cn.com/problems/course-schedule-ii/">210. 课程表 II</a></h1><p>难度中等565</p><p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p><ul><li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li></ul><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 2, prerequisites &#x3D; [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 4, prerequisites &#x3D; [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses &#x3D; 1, prerequisites &#x3D; []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>ai != bi</code></li><li>所有<code>[ai, bi]</code> <strong>互不相同</strong></li></ul><h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：广度优先遍历、Kahn 算法可以看成是BFS</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/69858335">https://zhuanlan.zhihu.com/p/69858335</a></p><p>这个方法需要注意的是建立图结构的算法，不同的算法会产生不一样的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span>(<span class="params">self, numCourses: int, prerequisites: List[List[int]]</span>) -&gt; List[int]:</span></span><br><span class="line">        graph = self.buildGraph(numCourses, prerequisites)</span><br><span class="line">        <span class="comment"># 建立每个顶点的入度关系inDegrees；并把入度为0的顶点加入到队列中</span></span><br><span class="line">        inDegrees = [<span class="number">0</span>] * numCourses</span><br><span class="line">        Queue = []</span><br><span class="line">        Seq = []    <span class="comment"># 记录拓扑排序结果</span></span><br><span class="line">        <span class="keyword">for</span> i, g <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">            inDegrees[i] = len(g)</span><br><span class="line">            <span class="keyword">if</span> inDegrees[i] == <span class="number">0</span>:</span><br><span class="line">                Queue.append(i)</span><br><span class="line">        <span class="keyword">while</span> Queue:</span><br><span class="line">            u = Queue.pop(<span class="number">0</span>)</span><br><span class="line">            Seq.append(u)</span><br><span class="line">            <span class="keyword">for</span> v, g <span class="keyword">in</span> enumerate(graph):</span><br><span class="line">                <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> g:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                inDegrees[v] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDegrees[v] == <span class="number">0</span>:</span><br><span class="line">                    Queue.append(v)</span><br><span class="line">        <span class="keyword">if</span> len(Seq) == numCourses:</span><br><span class="line">            <span class="comment"># 判断队列中的元素是否包括了全部的顶点</span></span><br><span class="line">            <span class="keyword">return</span> Seq</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span>(<span class="params">self, numCourses, prerequisites</span>):</span></span><br><span class="line">        <span class="comment"># 建立图结构，为start指向end</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(numCourses)]</span><br><span class="line">        <span class="keyword">for</span> end, start <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[end].append(start)</span><br><span class="line">        <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure><blockquote></blockquote><h1 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222. 完全二叉树的节点个数"></a><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h1><p>难度中等611</p><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点的数目范围是<code>[0, 5 * 104]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p><h2 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：暴力求解</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.countNodes(root.left)</span><br><span class="line">        right = self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">return</span> left + right + <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            self.cnt += <span class="number">1</span></span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> self.cnt</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：利用满二叉树的性质</p></blockquote><p>具体可以看代码中的注释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.getdepth(root.left)</span><br><span class="line">        right = self.getdepth(root.right)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> left == right:</span><br><span class="line">            <span class="comment"># 左子树为满的，求其节点数量的公式为2 ** left - 1， </span></span><br><span class="line">            <span class="comment"># 加上根节点为1个，由于上面有一个-1，现在有一个+1，所以可以抵消，变为2 ** left</span></span><br><span class="line">            <span class="comment"># 加上递归求右子树，虽然left==right，但是不能够说明右子树也是满的</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> ** left - <span class="number">1</span>) + <span class="number">1</span> + self.countNodes(root.right)</span><br><span class="line">            <span class="comment"># return (1 &lt;&lt; left) + self.countNodes(root.right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 此时左子树比右子树的深度深，说明右子树是满的，左子树是不满的，求右子树的节点数为：2 ** right - 1</span></span><br><span class="line">            <span class="comment"># 加上根节点1，由于上面有一个-1，现在有一个+1，所以可以抵消，变为2 ** right</span></span><br><span class="line">            <span class="comment"># 加上递归求左子树的节点数</span></span><br><span class="line">            <span class="keyword">return</span> self.countNodes(root.left) + <span class="number">1</span> + (<span class="number">2</span> ** right) - <span class="number">1</span> </span><br><span class="line">            <span class="comment"># return self.countNodes(root.left) + (1 &lt;&lt; right)</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getdepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment"># 因为是满二叉树，所以求最大深度的时候要在左子树中进行</span></span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h1><p>难度简单1155</p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h2><p>递归，每次把左右节点递归反转，然后返回的结果分别让右左指针指向左右结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h1><p>难度中等565</p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,3,6,2,4,null,null,1], k &#x3D; 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数为 <code>n</code> 。</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p><h2 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：中序遍历</p></blockquote><p>中序遍历保存结果，最后直接返回第k个值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: Optional[TreeNode], k: int</span>) -&gt; int:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            inorder(root.left)</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：中序遍历，中间每次访问根节点都计数一次。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root: Optional[TreeNode], k: int</span>) -&gt; int:</span></span><br><span class="line">        self.rank = <span class="number">0</span></span><br><span class="line">        self.res = <span class="number">-1</span></span><br><span class="line">        self.inorder(root, k)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.inorder(root.left, k)</span><br><span class="line">        self.rank += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.rank == k:</span><br><span class="line">            self.res = root.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(root.right, k)</span><br></pre></td></tr></table></figure><h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>难度简单1245</p><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2]</span><br><span class="line">输出：false </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li></ul><p><strong>进阶：</strong>你能否用 <code>O(n)</code> 时间复杂度和 <code>O(1)</code> 空间复杂度解决此题？</p><h2 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h2><p>使用双指针，fast和slow，slow最终肯定是走到中间位置，然后走到过程中把slow前面的进行反转。中间需要判断，如果fast不为空，说明为奇数个节点，否则就是偶数个节点，如果是奇数个节点就需要让slow继续多走一步。</p><p>从中间继续走，把slow和反转之后的链表比较值是否相等即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; bool:</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        new_head = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 采用头插法创建链表保存前半部分</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            tmp = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            tmp.next = new_head</span><br><span class="line">            new_head = tmp</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断链表长度为奇数还是偶数</span></span><br><span class="line">        <span class="keyword">if</span> fast:</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">while</span> slow:</span><br><span class="line">            <span class="keyword">if</span> new_head.val != slow.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            new_head = new_head.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h1><p>难度简单759</p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li></ul><h2 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h2><p>三种情况：</p><ul><li>第一种：如果p和q的值都小于root.val，说明需要在右子树中找公共节点；</li><li>第二种：如果p和q的值都大于root.val，说明需要在左子树中找公共节点；</li><li>第三种：如果p和q的值分布在root左右两侧，说明root就是根节点。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h1><p>难度中等1524</p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h2 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h2><p><a href="https://zhuanlan.zhihu.com/p/265525925">LCA问题：讲解的非常好，用到了四种方法解决，都很经典</a></p><p>经典的LCA问题，会在许多应用中使用到。</p><ul><li><p>第一种情况：如果root为空，返回空节点；</p></li><li><p>第二种情况：如果root的值与p或q相等，找到了p/q返回当前节点；</p></li><li><p>第三种情况：递归左右子树left和right，看看能否找到p或q。</p></li></ul><p>最后需要针对上面返回的left和right来判断。</p><ul><li>如果left和right均不为空的话，说明在左右子树中找到了p和q，此时返回root；</li><li>如果left不为空right为空，说明在左子树中找到了p和q，右子树中不存在这两者，此时返回left；</li><li>如果right不为空left为空，说明在右子树中找到了p和q，左子树中不存在这两者，此时返回right；</li><li>最后如果左右都为空，返回空。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="comment"># 根节点为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root.val == p.val <span class="keyword">or</span> root.val == q.val:</span><br><span class="line">            <span class="comment"># 根节点的值与p或q相等，找到了p/q返回当前节点</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h1><p>难度困难754</p><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>提示:</strong> 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 <a href="https://leetcode-cn.com/faq/#binary-tree">LeetCode 序列化二叉树的格式</a>。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,null,null,4,5]</span><br><span class="line">输出：[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 104]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h2><p>采用层序遍历，首先把二叉树序列化，如果是空节点用n表示，节点的值转换为字符串，然后每个节点之间用空格分开；</p><p>反序列化：</p><ul><li>首先，按照空格把字符串拆分，获得每个节点的列表；</li><li>其次，按照层序遍历，首先把根节点入队列，然后每次都弹出一个节点；</li><li>最后，弹出的节点如果为空就跳过，不用考虑左右节点；<ul><li>弹出的节点node如果不为空，就要建立左右节点，建立的时候需要考虑是否是空节点；</li><li>最后再把左右节点加入到队列中去。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res += str(node.val)</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="string">&#x27;n&#x27;</span></span><br><span class="line">            res += <span class="string">&#x27; &#x27;</span></span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tree = data.split()</span><br><span class="line">        <span class="comment"># print(tree)</span></span><br><span class="line">        <span class="keyword">if</span> tree[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        queue = []</span><br><span class="line">        root = TreeNode(int(tree[<span class="number">0</span>]))</span><br><span class="line">        queue.append(root)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="comment"># 当前节点为空，说明其没有左右子节点</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> tree[i] == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                <span class="comment"># 是否有左节点</span></span><br><span class="line">                node.left = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node.left = TreeNode(int(tree[i]))</span><br><span class="line">            <span class="keyword">if</span> tree[i+<span class="number">1</span>] == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">                <span class="comment"># 是否有右节点</span></span><br><span class="line">                node.right = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node.right = TreeNode(int(tree[i+<span class="number">1</span>]))</span><br><span class="line">            i += <span class="number">2</span></span><br><span class="line">            queue.append(node.left)</span><br><span class="line">            queue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># ser = Codec()</span></span><br><span class="line"><span class="comment"># deser = Codec()</span></span><br><span class="line"><span class="comment"># ans = deser.deserialize(ser.serialize(root))</span></span><br></pre></td></tr></table></figure><h1 id="323-无向图中连通分量的数目"><a href="#323-无向图中连通分量的数目" class="headerlink" title="323. 无向图中连通分量的数目"></a><a href="https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/">323. 无向图中连通分量的数目</a></h1><p>难度中等126</p><p>你有一个包含 <code>n</code> 个节点的图。给定一个整数 <code>n</code> 和一个数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示图中 <code>ai</code> 和 <code>bi</code> 之间有一条边。</p><p>返回 <em>图中已连接分量的数目</em> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/conn1-graph.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 5, edges &#x3D; [[0, 1], [1, 2], [3, 4]]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/conn2-graph.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: n &#x3D; 5, edges &#x3D; [[0,1], [1,2], [2,3], [3,4]]</span><br><span class="line">输出:  1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>1 &lt;= edges.length &lt;= 5000</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai &lt;= bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>edges</code> 中不会出现重复的边</li></ul><h2 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h2><p>这个题目的思路很简单，无论是BFS还是DFS，都需要把每个顶点都作为起始点遍历一次。如果该顶点已经被visited，可以直接跳过不用重复遍历；如果还没有被visited，就需要遍历，此时ans需要➕1.</p><blockquote><p>第一种方法：广度优先BFS</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countComponents</span>(<span class="params">self, n: int, edges: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        graph = self.buildGraph(n, edges)</span><br><span class="line">        print(graph)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        visited = [<span class="literal">False</span>] * n</span><br><span class="line">        queue = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> visited[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            queue.append(i)</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                v = queue.pop()</span><br><span class="line">                visited[v] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> visited[u]:</span><br><span class="line">                        visited[u] = <span class="literal">True</span></span><br><span class="line">                        queue.append(u)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span>(<span class="params">self, n, edges</span>):</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> edges:</span><br><span class="line">            graph[s].append(e)</span><br><span class="line">            graph[e].append(s)</span><br><span class="line">        <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：深度优先DFS</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countComponents</span>(<span class="params">self, n: int, edges: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        graph = self.buildGraph(n, edges)</span><br><span class="line">        visited = [<span class="literal">False</span>] * n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> visited[v]:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            visited[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:</span><br><span class="line">                traverse(u)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[i]:</span><br><span class="line">                traverse(i)</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span>(<span class="params">self, n, edges</span>):</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> edges:</span><br><span class="line">            graph[s].append(e)</span><br><span class="line">            graph[e].append(s)</span><br><span class="line">        <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure><blockquote><p>第三种：并查集算法实现</p><p><a href="http://siliconraleigh.com/2018/01/18/Union-Find/">http://siliconraleigh.com/2018/01/18/Union-Find/</a></p></blockquote><h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h1><p>难度中等638收藏分享切换为英文接收动态反馈</p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [], key &#x3D; 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>节点数的范围 <code>[0, 104]</code>.</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li><li>节点值唯一</li><li><code>root</code> 是合法的二叉搜索树</li><li><code>-105 &lt;= key &lt;= 105</code></li></ul><p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><h2 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h2><p>第一种和第二种方法针对第三种情况都是从右子树中找到符合要求的节点；</p><p>第三种方法针对第三种情况是从左子树中找到一个最大的节点替代。</p><blockquote><p>第一种方法</p></blockquote><p>这一种方法针对第三种情况，会略有不同，如果我们找到了minnode最小的右子树节点，不是把这个节点删除替换根节点，而是让root.left连接到minnode的左侧，root.right替换root，这样也是符合要求的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: int</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:   <span class="comment"># 第一种情况：左子树为空，用右子树替换</span></span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:  <span class="comment"># 第二种情况，右子树为空，用左子树替换</span></span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 第三种情况：左右子树都不为空，可以有两种做法</span></span><br><span class="line">            <span class="comment"># 1.用左子树中最大的元素替代，root.left即是符合要求的节点</span></span><br><span class="line">            <span class="comment"># 2.用右子树中最小的元素替代，这一种最小元素一定是叶子结点，会更容易操作，所以选择这一种</span></span><br><span class="line">            min_node = root.right</span><br><span class="line">            <span class="keyword">while</span> min_node.left:</span><br><span class="line">                min_node = min_node.left</span><br><span class="line">            min_node.left = root.left</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：</p></blockquote><p>这一种方法是找到最小的minnode，然后把minnode从右子树中删除，然后替换root。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: int</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:   <span class="comment"># 第一种情况：左子树为空，用右子树替换</span></span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:  <span class="comment"># 第二种情况，右子树为空，用左子树替换</span></span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 第三种情况：左右子树都不为空，可以有两种做法</span></span><br><span class="line">            <span class="comment"># 1.用左子树中最大的元素替代，这一种的话会涉及到多次删除，因为左子树的最大元素可能还会有子节点</span></span><br><span class="line">            <span class="comment"># 2.用右子树中最小的元素替代，这一种最小元素一定是叶子结点，会更容易操作，所以选择这一种</span></span><br><span class="line">            min_node = root.right</span><br><span class="line">            <span class="keyword">while</span> min_node.left:</span><br><span class="line">                min_node = min_node.left</span><br><span class="line">            root.right = self.deleteNode(root.right, min_node.val)</span><br><span class="line">            min_node.left = root.left</span><br><span class="line">            min_node.right = root.right</span><br><span class="line">            root = min_node</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><blockquote><p>第三种方法：从左子树中找到最大的</p></blockquote><p>从左子树中找到一个最大的来替代根节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: Optional[TreeNode], key: int</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key:</span><br><span class="line">            root.right = self.deleteNode(root.right, key)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; key:</span><br><span class="line">            root.left = self.deleteNode(root.left, key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left:   <span class="comment"># 第一种情况：左子树为空，用右子树替换</span></span><br><span class="line">                <span class="keyword">return</span> root.right</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.right:  <span class="comment"># 第二种情况，右子树为空，用左子树替换</span></span><br><span class="line">                <span class="keyword">return</span> root.left</span><br><span class="line">            <span class="comment"># 第三种情况：左右子树都不为空，可以有两种做法</span></span><br><span class="line">            <span class="comment"># 1.用左子树中最大的元素替代，这一种的话会涉及到多次删除，因为左子树的最大元素可能还会有子节点</span></span><br><span class="line">            <span class="comment"># 2.用右子树中最小的元素替代，这一种最小元素一定是叶子结点，会更容易操作，所以选择这一种</span></span><br><span class="line">            node = root.left</span><br><span class="line">            <span class="keyword">while</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">            root.left = self.deleteNode(root.left, node.val)</span><br><span class="line">            node.left = root.left</span><br><span class="line">            node.right = root.right</span><br><span class="line">            root = node</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></h1><p>难度困难494</p><p>请你为 <a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95">最不经常使用（LFU）</a>缓存算法设计并实现数据结构。</p><p>实现 <code>LFUCache</code> 类：</p><ul><li><code>LFUCache(int capacity)</code> - 用数据结构的容量 <code>capacity</code> 初始化对象</li><li><code>int get(int key)</code> - 如果键 <code>key</code> 存在于缓存中，则获取键的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> - 如果键 <code>key</code> 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 <code>capacity</code> 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 <strong>最近最久未使用</strong> 的键。</li></ul><p>为了确定最不常使用的键，可以为缓存中的每个键维护一个 <strong>使用计数器</strong> 。使用计数最小的键是最久未使用的键。</p><p>当一个键首次插入到缓存中时，它的使用计数器被设置为 <code>1</code> (由于 put 操作)。对缓存中的键执行 <code>get</code> 或 <code>put</code> 操作，使用计数器的值将会递增。</p><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, null, -1, 3, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">&#x2F;&#x2F; cnt(x) &#x3D; 键 x 的使用计数</span><br><span class="line">&#x2F;&#x2F; cache&#x3D;[] 将显示最后一次使用的顺序（最左边的元素是最近的）</span><br><span class="line">LFUCache lfu &#x3D; new LFUCache(2);</span><br><span class="line">lfu.put(1, 1);   &#x2F;&#x2F; cache&#x3D;[1,_], cnt(1)&#x3D;1</span><br><span class="line">lfu.put(2, 2);   &#x2F;&#x2F; cache&#x3D;[2,1], cnt(2)&#x3D;1, cnt(1)&#x3D;1</span><br><span class="line">lfu.get(1);      &#x2F;&#x2F; 返回 1</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[1,2], cnt(2)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lfu.put(3, 3);   &#x2F;&#x2F; 去除键 2 ，因为 cnt(2)&#x3D;1 ，使用计数最小</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;1, cnt(1)&#x3D;2</span><br><span class="line">lfu.get(2);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,1], cnt(3)&#x3D;2, cnt(1)&#x3D;2</span><br><span class="line">lfu.put(4, 4);   &#x2F;&#x2F; 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[4,3], cnt(4)&#x3D;1, cnt(3)&#x3D;2</span><br><span class="line">lfu.get(1);      &#x2F;&#x2F; 返回 -1（未找到）</span><br><span class="line">lfu.get(3);      &#x2F;&#x2F; 返回 3</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;1, cnt(3)&#x3D;3</span><br><span class="line">lfu.get(4);      &#x2F;&#x2F; 返回 4</span><br><span class="line">                 &#x2F;&#x2F; cache&#x3D;[3,4], cnt(4)&#x3D;2, cnt(3)&#x3D;3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= capacity &lt;= 104</code></li><li><code>0 &lt;= key &lt;= 105</code></li><li><code>0 &lt;= value &lt;= 109</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code> 方法</li></ul><h2 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：需要针对频率time进行排序</p></blockquote><p>由于需要排序，无法做到O(1)，所以最后一个无法通过测试，超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="comment"># 定义带hashmap的双向链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value, time</span>):</span></span><br><span class="line">        <span class="comment"># 每个节点既要包含value，也要包含一个time记录频率</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.value = value</span><br><span class="line">        self.time = time</span><br><span class="line">        self.prev = <span class="literal">None</span></span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity: int</span>):</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.hashmap = &#123;&#125;</span><br><span class="line">        self.head = ListNode(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">0</span>)</span><br><span class="line">        self.tail = ListNode(<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">10</span> ** <span class="number">9</span>)</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort_node</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        node = self.hashmap[key]    <span class="comment"># 先找到key所在的节点，并从链表中删去该节点</span></span><br><span class="line">        node.prev.next = node.next</span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">        <span class="comment"># 插入排序</span></span><br><span class="line">        cur = self.head</span><br><span class="line">        <span class="keyword">while</span> cur != self.tail <span class="keyword">and</span> cur.time &lt;= node.time:</span><br><span class="line">            cur = cur.next</span><br><span class="line">        node.next = cur</span><br><span class="line">        node.prev = cur.prev</span><br><span class="line">        cur.prev.next = node</span><br><span class="line">        cur.prev = node</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            self.hashmap[key].time += <span class="number">1</span></span><br><span class="line">            self.sort_node(key)</span><br><span class="line">            <span class="keyword">return</span> self.hashmap[key].value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>            </span><br><span class="line">        <span class="comment"># result = self.hashmap.get(key, -1)</span></span><br><span class="line">        <span class="comment"># if result == -1:</span></span><br><span class="line">        <span class="comment">#     return result</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     self.hashmap[key].time += 1</span></span><br><span class="line">        <span class="comment">#     self.sort_node(key)</span></span><br><span class="line">        <span class="comment">#     return result.value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key: int, value: int</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.capacity == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.hashmap:</span><br><span class="line">            <span class="comment"># key存在，就变更其值，然后重新排序</span></span><br><span class="line">            self.hashmap[key].value = value</span><br><span class="line">            self.hashmap[key].time += <span class="number">1</span></span><br><span class="line">            self.sort_node(key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果key不存在，首先需要判断容量还够吗</span></span><br><span class="line">            <span class="keyword">if</span> len(self.hashmap) == self.capacity:</span><br><span class="line">                <span class="comment"># 删去第一个节点，并弹出它的值</span></span><br><span class="line">                self.hashmap.pop(self.head.next.key)</span><br><span class="line">                self.head.next = self.head.next.next</span><br><span class="line">                self.head.next.prev = self.head</span><br><span class="line">            node = ListNode(key, value, <span class="number">1</span>)</span><br><span class="line">            self.hashmap[key] = node</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            cur = self.head</span><br><span class="line">            <span class="keyword">while</span> cur != self.tail <span class="keyword">and</span> cur.time &lt;= node.time:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur</span><br><span class="line">            node.prev = cur.prev</span><br><span class="line">            cur.prev.next = node</span><br><span class="line">            cur.prev = node</span><br><span class="line">            <span class="comment"># self.sort_node(key)</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LFUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><blockquote><p>第二种方法</p></blockquote><p>由于第一种方法只用了一个hashmap，无法做到put能够在O（1）时间范围内完成，所以第二种方法需要用到两个hashmap，一个保存value节点，一个保存频率time所在链表的头节点。</p><h1 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h1><p>难度中等642</p><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><p>提醒一下，二叉搜索树满足下列约束条件：</p><ul><li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li><li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li><li>左右子树也必须是二叉搜索树。</li></ul><p><strong>注意：</strong>本题和 1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li><li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li><li>树中的所有值 <strong>互不相同</strong> 。</li><li>给定的树为二叉搜索树。</li></ul><h2 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h2><p>根据题目的题意，当前节点的值应该为右边所有值的和，利用二叉树的性质，我们只要先递归右边，求出来右边所有节点的和，然后再递归左边就可以得到正确的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        self.sum_ = <span class="number">0</span></span><br><span class="line">        self.inorder(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="comment"># 逆序数处</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        self.inorder(root.right)</span><br><span class="line">        self.sum_ += root.val</span><br><span class="line">        root.val = self.sum_</span><br><span class="line">        self.inorder(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h1><p>难度简单895</p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>示例 :</strong><br>给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F; \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h2 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h2><p>可以参考104二叉树的最大深度这个题目。</p><p>这个题目是求某个节点左侧最大深度+右侧最大深度。然后递归调用maxDepth函数，并保存maxdiameter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.left &#x3D; left</span><br><span class="line">#         self.right &#x3D; right</span><br><span class="line">class Solution:</span><br><span class="line">    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:</span><br><span class="line">        self.maxdiameter &#x3D; 0</span><br><span class="line">        self.maxDepth(root)</span><br><span class="line">        return self.maxdiameter</span><br><span class="line"></span><br><span class="line">    def maxDepth(self, root):</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        leftmax &#x3D; self.maxDepth(root.left)</span><br><span class="line">        rightmax &#x3D; self.maxDepth(root.right)</span><br><span class="line">        mydiameter &#x3D; leftmax + rightmax</span><br><span class="line">        self.maxdiameter &#x3D; max(self.maxdiameter, mydiameter)</span><br><span class="line">        return max(leftmax, rightmax) + 1</span><br></pre></td></tr></table></figure><h1 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h1><p>难度简单219</p><p>给你一个由 <code>n</code> 个元素组成的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p><p>请你找出平均数最大且 <strong>长度为 <code>k</code></strong> 的连续子数组，并输出该最大平均数。</p><p>任何误差小于 <code>10-5</code> 的答案都将被视为正确答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,12,-5,-6,50,3], k &#x3D; 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)&#x2F;4 &#x3D; 51&#x2F;4 &#x3D; 12.75</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5], k &#x3D; 1</span><br><span class="line">输出：5.00000</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= k &lt;= n &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h2 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h2><p>平均数最大也就是意味着k个和最大，所以我们用tmp来表示k个和，用sum_记录最大和，然后遍历过程中，只需要减去当前值，并加上当前值后面的第k个值，这样就可以通过一次遍历得到结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxAverage</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; float:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        tmp = sum(nums[:k])</span><br><span class="line">        sum_ = tmp</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - k):</span><br><span class="line">            tmp = tmp - nums[i] + nums[i + k]</span><br><span class="line">            sum_ = max(sum_, tmp)</span><br><span class="line">        <span class="keyword">return</span> sum_ / k</span><br></pre></td></tr></table></figure><h1 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树</a></h1><p>难度中等364</p><p>给定一棵二叉树 <code>root</code>，返回所有<strong>重复的子树</strong>。</p><p>对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>如果两棵树具有<strong>相同的结构</strong>和<strong>相同的结点值</strong>，则它们是<strong>重复</strong>的。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/16/e1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,null,2,4,null,null,4]</span><br><span class="line">输出：[[2,4],[4]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/16/e2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,1,1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><strong><img src="https://assets.leetcode.com/uploads/2020/08/16/e33.jpg" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,2,2,3,null,3,null]</span><br><span class="line">输出：[[2,3],[3]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的结点数在<code>[1,10^4]</code>范围内。</li><li><code>-200 &lt;= Node.val &lt;= 200</code></li></ul><h2 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h2><p>首先是把一个二叉树序列化保存下来，序列化的时候我们只需要按照根节点、左子树、右子树的顺序来序列化就可以，一颗二叉树的所有根节点都序列化并统计相同的根节点的数量，如果数量为2说明找到了相同的子树，就要加入到结果中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findDuplicateSubtrees</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; List[Optional[TreeNode]]:</span></span><br><span class="line">        self.count = collections.defaultdict(int)</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.traverse(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        left = self.traverse(root.left)</span><br><span class="line">        right = self.traverse(root.right)</span><br><span class="line">        serial = str(root.val) + <span class="string">&#x27;,&#x27;</span> + left + <span class="string">&#x27;,&#x27;</span> + right</span><br><span class="line">        self.count[serial] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.count[serial] == <span class="number">2</span>:</span><br><span class="line">            self.ans.append(root)</span><br><span class="line">        <span class="keyword">return</span> serial</span><br></pre></td></tr></table></figure><h1 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h1><p>难度中等367</p><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p><ol><li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li><li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li><li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li></ol><p>返回 <em><code>nums</code> 构建的</em> <strong><em>最大二叉树\</em></strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h2 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h2><p>递归解法。</p><p>边界：如果nums为空，返回空节点；</p><p>root：获得最大值以及最大值的位置，新建立一个根节点，其值为max_；同时root.left为nums左侧的节点，root.right为nums右侧节点。左节点和右节点均为递归调用构建节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        max_ = max(nums)</span><br><span class="line">        idx = nums.index(max_)</span><br><span class="line">        root = TreeNode(max_, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        root.left = self.constructMaximumBinaryTree(nums[:idx])</span><br><span class="line">        root.right = self.constructMaximumBinaryTree(nums[idx+<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h1><p>难度简单234</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p><p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>数中节点数在 <code>[1, 5000]</code> 范围内</li><li><code>1 &lt;= Node.val &lt;= 107</code></li><li><code>root</code> 是二叉搜索树</li><li><code>1 &lt;= val &lt;= 107</code></li></ul><h2 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h2><blockquote><p>第一种方法：递归</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: int</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.right, val)</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; val:</span><br><span class="line">            <span class="keyword">return</span> self.searchBST(root.left, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法：迭代</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: int</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> root.val == val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> root.val &gt; val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.right</span><br></pre></td></tr></table></figure><h1 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h1><p>难度中等256</p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li><li><code>-108 &lt;= Node.val &lt;= 108</code></li><li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li><li><code>-108 &lt;= val &lt;= 108</code></li><li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li></ul><h2 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h2><p>BST插入节点一定是插入在叶子结点，这个一定要记得浓情。</p><p>如果当前节点为空，就新建一个节点，作为新插入的节点；</p><p>如果根节点值大于val，说明需要插入在左子树中；</p><p>如果根节点值小于val，说明需要插入在右子树中；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: int</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">785. 判断二分图</a></h1><p>难度中等341</p><p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p><ul><li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li><li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li><li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li><li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li></ul><p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p><p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2,3],[0,2],[0,1,3],[0,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,3],[0,2],[1,3],[0,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>graph.length == n</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= graph[u].length &lt; n</code></li><li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li><li><code>graph[u]</code> 不会包含 <code>u</code></li><li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li><li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li></ul><h2 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h2><p>判断二分图就是典型的图的遍历，每次访问到一个节点之后，都访问其邻接点，然后判断邻居是否被访问过，如果没有访问就递归访问；如果访问过就判断一下这两者颜色是否一样。</p><blockquote><p>第一种：深度优先遍历</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        visited = [<span class="literal">False</span>] * n</span><br><span class="line">        self.flag = <span class="literal">True</span>     <span class="comment"># 判断是否符合二分图 </span></span><br><span class="line">        color = [<span class="literal">False</span>] * n</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">v</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.flag:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            visited[v] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> visited[u]:</span><br><span class="line">                    <span class="comment"># u还没有被访问过</span></span><br><span class="line">                    color[u] = <span class="keyword">not</span> color[v]</span><br><span class="line">                    traverse(u)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># u被访问过，判断颜色是否相等</span></span><br><span class="line">                    <span class="keyword">if</span> color[u] == color[v]:</span><br><span class="line">                        self.flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            traverse(i)</span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br></pre></td></tr></table></figure><blockquote><p>第二种：广度优先遍历</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span>(<span class="params">self, graph: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="comment"># 用广度优先遍历实现一下</span></span><br><span class="line">        n = len(graph)</span><br><span class="line">        visited = [<span class="literal">False</span>] * n   <span class="comment"># 是否访问过</span></span><br><span class="line">        color = [<span class="literal">False</span>] * n <span class="comment"># 标记颜色</span></span><br><span class="line">        queue = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            queue.append(i)</span><br><span class="line">            visited[i] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                v = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> visited[u]:</span><br><span class="line">                        visited[u] = <span class="literal">True</span></span><br><span class="line">                        color[u] = <span class="keyword">not</span> color[v]</span><br><span class="line">                        queue.append(u)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> color[u] == color[v]:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="797-所有可能的路径"><a href="#797-所有可能的路径" class="headerlink" title="797. 所有可能的路径"></a><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></h1><p>难度中等248</p><p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p><p> <code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：graph &#x3D; [[4,3,1],[3,2,4],[3],[4],[]]</span><br><span class="line">输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == graph.length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>0 &lt;= graph[i][j] &lt; n</code></li><li><code>graph[i][j] != i</code>（即不存在自环）</li><li><code>graph[i]</code> 中的所有元素 <strong>互不相同</strong></li><li>保证输入为 <strong>有向无环图（DAG）</strong></li></ul><h2 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h2><p>图的遍历，可以当作是回溯或者深度优先遍历来做就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: List[List[int]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">graph, temp, path</span>):</span></span><br><span class="line">            n = len(graph)</span><br><span class="line">            path.append(temp)   <span class="comment"># 路径中加入goal</span></span><br><span class="line">            <span class="keyword">if</span> temp == n<span class="number">-1</span>: <span class="comment"># 找到了一条路径</span></span><br><span class="line">                result.append(path[:])  <span class="comment"># 加入到结果中</span></span><br><span class="line">                path.pop()  <span class="comment"># 弹出最后的这个继续找</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> graph[temp]:<span class="comment"># 递归每个相邻的节点</span></span><br><span class="line">                traverse(graph, p, path)</span><br><span class="line">            path.pop()  <span class="comment"># 弹出最后的继续找</span></span><br><span class="line">            </span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        traverse(graph, <span class="number">0</span>, path)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph: List[List[int]]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">temp</span>):</span></span><br><span class="line">            <span class="keyword">if</span> temp == n<span class="number">-1</span>: <span class="comment"># 找到了一条路径</span></span><br><span class="line">                result.append(path[:])  <span class="comment"># 加入到结果中</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> graph[temp]:</span><br><span class="line">                path.append(p)   <span class="comment"># 路径中加入goal</span></span><br><span class="line">                traverse(p)</span><br><span class="line">                path.pop()  <span class="comment"># 弹出最后的继续找</span></span><br><span class="line">            </span><br><span class="line">        result = []</span><br><span class="line">        path = []</span><br><span class="line">        n = len(graph)</span><br><span class="line">        path.append(<span class="number">0</span>)</span><br><span class="line">        traverse(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。 </p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h2 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleNode</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        fast = slow = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><h1 id="886-可能的二分法"><a href="#886-可能的二分法" class="headerlink" title="886. 可能的二分法"></a><a href="https://leetcode-cn.com/problems/possible-bipartition/">886. 可能的二分法</a></h1><p>难度中等154</p><p>给定一组 <code>n</code> 人（编号为 <code>1, 2, ..., n</code>）， 我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p><p>给定整数 <code>n</code> 和数组 <code>dislikes</code> ，其中 <code>dislikes[i] = [ai, bi]</code> ，表示不允许将编号为 <code>ai</code> 和 <code>bi</code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 4, dislikes &#x3D; [[1,2],[1,3],[2,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 3, dislikes &#x3D; [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, dislikes &#x3D; [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 2000</code></li><li><code>0 &lt;= dislikes.length &lt;= 104</code></li><li><code>dislikes[i].length == 2</code></li><li><code>1 &lt;= dislikes[i][j] &lt;= n</code></li><li><code>ai &lt; bi</code></li><li><code>dislikes</code> 中每一组都 <strong>不同</strong></li></ul><h2 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h2><p>可以参考785，直接把问题转换为求二分图是否存在问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">possibleBipartition</span>(<span class="params">self, n: int, dislikes: List[List[int]]</span>) -&gt; bool:</span></span><br><span class="line">        graph = self.buildGraph(n, dislikes)</span><br><span class="line">        print(graph)</span><br><span class="line">        visited = [<span class="literal">False</span>] * n</span><br><span class="line">        color = [<span class="literal">False</span>] * n</span><br><span class="line">        queue = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                v = queue.pop()</span><br><span class="line">                visited[v] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">for</span> u <span class="keyword">in</span> graph[v]:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> visited[u]:</span><br><span class="line">                        visited[u] = <span class="literal">True</span></span><br><span class="line">                        color[u] = <span class="keyword">not</span> color[v]</span><br><span class="line">                        queue.append(u)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> color[u] == color[v]:</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildGraph</span>(<span class="params">self, n, dislikes</span>):</span></span><br><span class="line">        graph = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> dislikes:</span><br><span class="line">            graph[s<span class="number">-1</span>].append(e<span class="number">-1</span>)</span><br><span class="line">            graph[e<span class="number">-1</span>].append(s<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> graph</span><br></pre></td></tr></table></figure><h1 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">889. 根据前序和后序遍历构造二叉树</a></h1><p>难度中等216</p><p>返回与给定的前序和后序遍历匹配的任何二叉树。</p><p> <code>pre</code> 和 <code>post</code> 遍历中的值是不同的正整数。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pre &#x3D; [1,2,4,5,3,6,7], post &#x3D; [4,5,2,6,7,3,1]</span><br><span class="line">输出：[1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= pre.length == post.length &lt;= 30</code></li><li><code>pre[]</code> 和 <code>post[]</code> 都是 <code>1, 2, ..., pre.length</code> 的排列</li><li>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</li></ul><h2 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h2><table><thead><tr><th></th><th>根节点</th><th>根据中序根节点位置idx</th></tr></thead><tbody><tr><td>中序+前序</td><td>前序的<strong>第一个节点</strong>为根节点可以把中序分为三段inorder[:idx]、inorder[idx]、inorder[idx+1:]</td><td>可以把前序分为preorder[0]、preorder[1:idx]、preorder[idx+1:]</td></tr><tr><td>中序+后序</td><td>后序的<strong>最后一个节点</strong>为根节点可以把中序分为三段inorder[:idx]、inorder[idx]、inorder[idx+1:]</td><td>可以把前序分为preorder[:idx]、preorder[idx:len(preorder)-1]、preorder[-1]</td></tr><tr><td>前序+后序</td><td>前序第一个节点或后序最后一个节点为根节点</td><td>首先根据前序第二个节点，找到在后序中的位置idx，这样后序可以分为preorder[:idx]、preorder[idx:len(preorder)-1]、preorder[-1]。<br>可以把前序分为preorder[0]、preorder[1:idx]、preorder[idx+1:]</td></tr></tbody></table><p>前序+后序构建就相当于是结合了前两种方法构建二叉树。</p><p>需要特殊处理一下，如果preorder为空直接返回空，如果只有一个值，直接返回root，有两个值就是第三种情况，根据前序第二个节点，找到在后序中的位置idx，这样后序可以分为preorder[:idx]、preorder[idx:len(preorder)-1]、preorder[-1]；可以把前序分为preorder[0]、preorder[1:idx]、preorder[idx+1:]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span>(<span class="params">self, preorder: List[int], postorder: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rootVal = preorder[<span class="number">0</span>]</span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        <span class="keyword">if</span> len(preorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        tmp = preorder[<span class="number">1</span>]</span><br><span class="line">        idx = postorder.index(tmp) + <span class="number">1</span></span><br><span class="line">        root = TreeNode(rootVal)</span><br><span class="line">        root.left = self.constructFromPrePost(preorder[<span class="number">1</span>:idx+<span class="number">1</span>], postorder[:idx])</span><br><span class="line">        root.right = self.constructFromPrePost(preorder[idx+<span class="number">1</span>:], postorder[idx:len(postorder)<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="998-最大二叉树-II"><a href="#998-最大二叉树-II" class="headerlink" title="998. 最大二叉树 II"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree-ii/">998. 最大二叉树 II</a></h1><p>难度中等54</p><p>最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。</p><p>给出最大树的根节点 <code>root</code>。</p><p>就像<a href="https://leetcode-cn.com/problems/maximum-binary-tree/">之前的问题</a>那样，给定的树是从列表 <code>A</code>（<code>root = Construct(A)</code>）递归地使用下述 <code>Construct(A)</code> 例程构造的：</p><ul><li>如果 <code>A</code> 为空，返回 <code>null</code></li><li>否则，令 <code>A[i]</code> 作为 A 的最大元素。创建一个值为 <code>A[i]</code> 的根节点 <code>root</code></li><li><code>root</code> 的左子树将被构建为 <code>Construct([A[0], A[1], ..., A[i-1]])</code></li><li><code>root</code> 的右子树将被构建为 <code>Construct([A[i+1], A[i+2], ..., A[A.length - 1]])</code></li><li>返回 <code>root</code></li></ul><p>请注意，我们没有直接给定 A，只有一个根节点 <code>root = Construct(A)</code>.</p><p>假设 <code>B</code> 是 <code>A</code> 的副本，并在末尾附加值 <code>val</code>。题目数据保证 <code>B</code> 中的值是不同的。</p><p>返回 <code>Construct(B)</code>。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png" alt="img"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,1,3,null,null,2], val &#x3D; 5</span><br><span class="line">输出：[5,4,null,1,3,null,null,2]</span><br><span class="line">解释：A &#x3D; [1,4,2,3], B &#x3D; [1,4,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png" alt="img"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,2,4,null,1], val &#x3D; 3</span><br><span class="line">输出：[5,2,4,null,1,null,3]</span><br><span class="line">解释：A &#x3D; [2,1,5,4], B &#x3D; [2,1,5,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png" alt="img"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,2,3,null,1], val &#x3D; 4</span><br><span class="line">输出：[5,2,4,null,1,3]</span><br><span class="line">解释：A &#x3D; [2,1,5,3], B &#x3D; [2,1,5,3,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= B.length &lt;= 100</code></li></ul><h2 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h2><p>边界：首先如果根节点为空的话，就需要把val放入到根节点中，新建一个根节点。</p><p>递归：如果根节点的值小于val，说明需要新建一个根节点；否则的话就需要把新插入的值放到根节点右节点上。（这一点可以这样理解，因为需要把新插入的值放在数组的最后，就相当于是树的右侧。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoMaxTree</span>(<span class="params">self, root: Optional[TreeNode], val: int</span>) -&gt; Optional[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            root = TreeNode(val)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">            root = TreeNode(val, root)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.right = self.insertIntoMaxTree(root.right, val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1 id="1093-大样本统计"><a href="#1093-大样本统计" class="headerlink" title="1093. 大样本统计"></a><a href="https://leetcode-cn.com/problems/statistics-from-a-large-sample/">1093. 大样本统计</a></h1><p>难度中等23</p><p>我们对 <code>0</code> 到 <code>255</code> 之间的整数进行采样，并将结果存储在数组 <code>count</code> 中：<code>count[k]</code> 就是整数 <code>k</code> 的采样个数。</p><p>我们以 <strong>浮点数</strong> 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。</p><p>我们先来回顾一下中位数的知识：</p><ul><li>如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素；</li><li>如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：count &#x3D; [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">输出：[1.00000,3.00000,2.37500,2.50000,3.00000]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：count &#x3D; [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">输出：[1.00000,4.00000,2.18182,2.00000,1.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>count.length == 256</code></li><li><code>1 &lt;= sum(count) &lt;= 10^9</code></li><li>计数表示的众数是唯一的</li><li>答案与真实值误差在 <code>10^-5</code> 以内就会被视为正确答案</li></ol><h2 id="思路-60"><a href="#思路-60" class="headerlink" title="思路"></a>思路</h2><p>这个题目没有太好的方法，只能够手动模拟。我的代码过于笨重，真的是纯暴力了，以后有时间再优化一下，但是也没有题啊好的优化方法了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sampleStats</span>(<span class="params">self, count: List[int]</span>) -&gt; List[float]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        num_zhong = sum_ = <span class="number">0</span></span><br><span class="line">        num = sum(count)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">and</span> count[i] != <span class="number">0</span>:</span><br><span class="line">                min_ = i</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> count[i] != <span class="number">0</span>:</span><br><span class="line">                max_ = i</span><br><span class="line">            sum_ += i * count[i]</span><br><span class="line">            <span class="keyword">if</span> count[i] &gt; num_zhong:</span><br><span class="line">                num_zhong = count[i]</span><br><span class="line">                zhongshu = i</span><br><span class="line">        ans.append(min_)</span><br><span class="line">        ans.append(max_)</span><br><span class="line">        ans.append(sum_ / num)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">True</span></span><br><span class="line">            res.append(int(num // <span class="number">2</span>))</span><br><span class="line">            res.append(int(num // <span class="number">2</span>)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            res.append(int( num // <span class="number">2</span>))</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        flag1 = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>):</span><br><span class="line">            cnt += count[i]</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="comment"># 偶数</span></span><br><span class="line">                <span class="keyword">if</span> flag1 <span class="keyword">and</span> cnt &gt;= res[<span class="number">0</span>]:</span><br><span class="line">                    res[<span class="number">0</span>] = i</span><br><span class="line">                    flag1 = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt;= res[<span class="number">1</span>]:</span><br><span class="line">                    res[<span class="number">1</span>] = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 奇数</span></span><br><span class="line">                <span class="keyword">if</span> cnt &gt; res[<span class="number">0</span>]:</span><br><span class="line">                    res[<span class="number">0</span>] = i</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            zhongwei = sum(res) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            zhongwei = res[<span class="number">0</span>]</span><br><span class="line">        ans.append(zhongwei)</span><br><span class="line">        ans.append(zhongshu)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="1095-山脉数组中查找目标值"><a href="#1095-山脉数组中查找目标值" class="headerlink" title="1095. 山脉数组中查找目标值"></a><a href="https://leetcode-cn.com/problems/find-in-mountain-array/">1095. 山脉数组中查找目标值</a></h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>（这是一个 <strong>交互式问题</strong> ）</p><p>给你一个 <strong>山脉数组</strong> <code>mountainArr</code>，请你返回能够使得 <code>mountainArr.get(index)</code> <strong>等于</strong> <code>target</code> <strong>最小</strong> 的下标 <code>index</code> 值。</p><p>如果不存在这样的下标 <code>index</code>，就请返回 <code>-1</code>。</p><p>何为山脉数组？如果数组 <code>A</code> 是一个山脉数组的话，那它满足如下条件：</p><p><strong>首先</strong>，<code>A.length &gt;= 3</code></p><p><strong>其次</strong>，在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul><p>你将 <strong>不能直接访问该山脉数组</strong>，必须通过 <code>MountainArray</code> 接口来获取数据：</p><ul><li><code>MountainArray.get(k)</code> - 会返回数组中索引为<code>k</code> 的元素（下标从 0 开始）</li><li><code>MountainArray.length()</code> - 会返回该数组的长度</li></ul><p><strong>注意：</strong></p><p>对 <code>MountainArray.get</code> 发起超过 <code>100</code> 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>为了帮助大家更好地理解交互式问题，我们准备了一个样例 “<strong>答案</strong>”：<a href="https://leetcode-cn.com/playground/RKhe3ave%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%E8%BF%99">https://leetcode-cn.com/playground/RKhe3ave，请注意这</a> <strong>不是一个正确答案</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：array &#x3D; [1,2,3,4,5,3,1], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：array &#x3D; [0,1,2,4,2,1], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= mountain_arr.length() &lt;= 10000</code></li><li><code>0 &lt;= target &lt;= 10^9</code></li><li><code>0 &lt;= mountain_arr.get(index) &lt;= 10^9</code></li></ul><h2 id="思路-61"><a href="#思路-61" class="headerlink" title="思路"></a>思路</h2><p>首先我们先用二分查找找到封顶的位置，即数值最大的值在哪；</p><p>然后在分别在左侧寻找target，如果能够找到就返回结果；如果找不到，就在右侧寻找target。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># This is MountainArray&#x27;s API interface.</span></span><br><span class="line"><span class="comment"># You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"># &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#class MountainArray:</span></span><br><span class="line"><span class="comment">#    def get(self, index: int) -&gt; int:</span></span><br><span class="line"><span class="comment">#    def length(self) -&gt; int:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findInMountainArray</span>(<span class="params">self, target: int, mountain_arr: <span class="string">&#x27;MountainArray&#x27;</span></span>) -&gt; int:</span></span><br><span class="line">        n = mountain_arr.length()</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            a, b, c = mountain_arr.get(mid - <span class="number">1</span>), mountain_arr.get(mid), mountain_arr.get(mid + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> a &lt; b &gt; c:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> a &lt; b &lt; c:</span><br><span class="line">                left = mid</span><br><span class="line">            <span class="keyword">elif</span> a &gt; b &gt; c:</span><br><span class="line">                right = mid</span><br><span class="line">        mid_ = mid</span><br><span class="line">        left, right = <span class="number">0</span>, mid_</span><br><span class="line">        <span class="comment"># 寻找左侧</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> mountain_arr.get(mid) &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        left, right = mid_, n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 寻找右侧侧</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mountain_arr.get(mid) == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> mountain_arr.get(mid) &gt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403. 非递增顺序的最小子序列"></a><a href="https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order/">1403. 非递增顺序的最小子序列</a></h1><p>难度简单42</p><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 <strong>严格</strong> 大于未包含在该子序列中的各元素之和。</p><p>如果存在多个解决方案，只需返回 <strong>长度最小</strong> 的子序列。如果仍然有多个解决方案，则返回 <strong>元素之和最大</strong> 的子序列。</p><p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p><p><strong>注意</strong>，题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,3,10,9,8]</span><br><span class="line">输出：[10,9] </span><br><span class="line">解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [4,4,7,6,7]</span><br><span class="line">输出：[7,7,6] </span><br><span class="line">解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 &#x3D; 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  </span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [6]</span><br><span class="line">输出：[6]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="思路-62"><a href="#思路-62" class="headerlink" title="思路"></a>思路</h2><p>因为要求子序列比其他元素和大即可，所以逆序排序并求和，用贪心算法，先把最大值加入ans，然后判断ans内所有元素和是否符合要求，最后返回结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubsequence</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        nums.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            ans.append(num)</span><br><span class="line">            count += num</span><br><span class="line">            <span class="keyword">if</span> count &gt; sum_ - count:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="1669-合并两个链表"><a href="#1669-合并两个链表" class="headerlink" title="1669. 合并两个链表"></a><a href="https://leetcode-cn.com/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。</p><p>请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。</p><p>下图中蓝色边和节点展示了操作后的结果：</p><p>请你返回结果链表的头指针。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 &#x3D; [0,1,2,3,4,5], a &#x3D; 3, b &#x3D; 4, list2 &#x3D; [1000000,1000001,1000002]</span><br><span class="line">输出：[0,1,2,1000000,1000001,1000002,5]</span><br><span class="line">解释：我们删除 list1 中下标为 3 和 4 的两个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：list1 &#x3D; [0,1,2,3,4,5,6], a &#x3D; 2, b &#x3D; 5, list2 &#x3D; [1000000,1000001,1000002,1000003,1000004]</span><br><span class="line">输出：[0,1,1000000,1000001,1000002,1000003,1000004,6]</span><br><span class="line">解释：上图中蓝色的边和节点为答案链表。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">3 &lt;&#x3D; list1.length &lt;&#x3D; 104</span><br><span class="line">1 &lt;&#x3D; a &lt;&#x3D; b &lt; list1.length - 1</span><br><span class="line">1 &lt;&#x3D; list2.length &lt;&#x3D; 104</span><br></pre></td></tr></table></figure><h2 id="思路-63"><a href="#思路-63" class="headerlink" title="思路"></a>思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeInBetween</span>(<span class="params">self, list1: ListNode, a: int, b: int, list2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        pre = list1</span><br><span class="line">        a -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pre.next <span class="keyword">and</span> a:</span><br><span class="line">            a -= <span class="number">1</span></span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            pre = pre.next</span><br><span class="line">        post = pre</span><br><span class="line">        <span class="keyword">while</span> post <span class="keyword">and</span> b:</span><br><span class="line">            b -= <span class="number">1</span></span><br><span class="line">            post = post.next</span><br><span class="line">        pre.next = list2</span><br><span class="line">        <span class="keyword">while</span> list2.next:</span><br><span class="line">            list2 = list2.next</span><br><span class="line">        list2.next = post.next</span><br><span class="line">        <span class="keyword">return</span> list1</span><br></pre></td></tr></table></figure><h1 id="1996-游戏中弱角色的数量"><a href="#1996-游戏中弱角色的数量" class="headerlink" title="1996. 游戏中弱角色的数量"></a><a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量</a></h1><p>难度中等110</p><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：<strong>攻击</strong> 和 <strong>防御</strong> 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attacki, defensei]</code> 表示游戏中第 <code>i</code> 个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级 <strong>都严格高于</strong> 该角色的攻击和防御等级，则认为该角色为 <strong>弱角色</strong> 。更正式地，如果认为角色 <code>i</code> <strong>弱于</strong> 存在的另一个角色 <code>j</code> ，那么 <code>attackj &gt; attacki</code> 且 <code>defensej &gt; defensei</code> 。</p><p>返回 <strong>弱角色</strong> 的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties &#x3D; [[5,5],[6,3],[3,6]]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在攻击和防御都严格高于其他角色的角色。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties &#x3D; [[2,2],[3,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties &#x3D; [[1,5],[10,4],[4,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= properties.length &lt;= 105</code></li><li><code>properties[i].length == 2</code></li><li><code>1 &lt;= attacki, defensei &lt;= 105</code></li></ul><h2 id="思路-64"><a href="#思路-64" class="headerlink" title="思路"></a>思路</h2><p>遇到n行2列的数组，如果用到排序的话，一般都是按照一个正序，一个逆序的方法来排序，然后利用排序后的规律来完成题目的解答。</p><p>我们按照第一个逆序，第二个正序来排序，[[10, 1], [10, 3], [10, 4], [8, 3], [8, 5], [3, 5], [3, 6]]这个序列排序是很有规律的，我们再记录一个maxDefense，即保卫的最大值。</p><p>attack相等时：刚开始的时候attack最大，但是同一个attack的defense最小，所以不符合题意，遍历完10之后，maxDefense=4；</p><p>attack不相等时：之后对于8，就可以找到符合题意的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfWeakCharacters</span>(<span class="params">self, properties: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        properties.sort(key=<span class="keyword">lambda</span> x:(-x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># print(properties)</span></span><br><span class="line">        maxDefense = <span class="number">-1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a, d <span class="keyword">in</span> properties:</span><br><span class="line">            <span class="keyword">if</span> maxDefense &gt; d:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxDefense = max(maxDefense, d)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解：股票问题系列通解</title>
      <link href="2022/01/18/220118%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%E9%80%9A%E8%A7%A3/"/>
      <url>2022/01/18/220118%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97%E9%80%9A%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目</th><th>标签</th><th>难度</th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td><td>动态规划、模拟</td><td>简单</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></td><td>动态规划、模拟</td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></td><td>动态规划、模拟</td><td>困难</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></td><td>动态规划、模拟</td><td>困难</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></td><td></td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/number-of-smooth-descent-periods-of-a-stock/">2110. 股票平滑下跌阶段的数目</a></td><td>动态规划、模拟</td><td>中等</td></tr><tr><td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></td><td>动态规划、模拟</td><td>中等</td></tr></tbody></table><h1 id="1-121-买卖股票的最佳时机"><a href="#1-121-买卖股票的最佳时机" class="headerlink" title="1.121. 买卖股票的最佳时机"></a>1.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; prices.length &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</span><br></pre></td></tr></table></figure><h2 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>这个题的限制是：整个过程中，只能够买入一只股票，然后卖出。</p><p>我们只要保证选择一个最低点买入，然后在最高点卖出即可。</p><p>用max_profit表示最高的利润，用min_price表示当前之前最低的价格，然后再求一下prices[i] - min_price即可，在遍历的过程中不断更新这两个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n)</span><br><span class="line">        max_profit, min_price = <span class="number">0</span>, prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            max_profit = max(max_profit, prices[i] - min_num)</span><br><span class="line">            min_price = min(min_price, prices[i])</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure><h1 id="2-122-买卖股票的最佳时机-II"><a href="#2-122-买卖股票的最佳时机-II" class="headerlink" title="2.122. 买卖股票的最佳时机 II"></a>2.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: prices &#x3D; [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="思路及解法-1"><a href="#思路及解法-1" class="headerlink" title="思路及解法"></a>思路及解法</h2><blockquote><p>第一种：模拟</p></blockquote><p>只要后一天的价格比前一天高，我们就可以在前一天买入，后一天卖出，不断执行这个操作。</p><p>例如：[1, 2, 3, 4, 5, 6]，我们可以在：</p><p>第一天买入，第二天卖出，赚了2-1；</p><p>然后第二天买入，第三天卖出，赚了3-2；</p><p>……</p><p>只要数组在这一阶段是上升的，就可以一直执行这个操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i<span class="number">-1</span>]:</span><br><span class="line">                sum += prices[i] - prices[i<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><blockquote><p>第二种：动态规划及其优化</p></blockquote><p>dp[i] [0]代表第i天不持有股票，dp[i] [1]代表第i天持有股票。</p><p><strong>边界</strong>：dp[0] [0], dp[0] [1] = 0, - prices[0]，因为初始的时候利润是0，不持有股票价格为0，持有股票价格为- prices[0]。</p><p><strong>状态方程</strong> ：</p><p>如果dp[i] [0]代表第i天不持有股票，那么第i天的组成必是以下两者中的最高者：第一个就是前一天不持有的利润dp[i-1] [0]；第二个就是：第i-1天持有股票，第i天不持有股票（相当于把第i-1天的股票卖掉了）dp[i - 1] [1] + prices[i]。<br>$$<br>            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])<br>$$<br>如果dp[i] [1]代表第i天持有股票，那么第i天的组成必是以下两者中的最高者：第一个就是前一天持有的利润dp[i-1] [1]；第二个就是：第i-1天不持有股票，第i天持有股票——买入这只股票，dp[i - 1] [0] - prices[i]。<br>$$<br>dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i天不持有股票, dp[i][1]表示第i天持有股票</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="comment">#print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><blockquote><p>优化动态规划</p></blockquote><p>上面的公式我们可以知道，dp[i] [0] 、dp[i] [1]的结果只与dp[i - 1] [0]、dp[i - 1] [1]两者相关，所以我们就可以通过两个变量来保存这两个值，而不在需要一个数组保存，大大降低空间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="comment"># a表示第i天不持有股票, b表示第i天持有股票</span></span><br><span class="line">        a, b = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            a, b = max(a, b + prices[i]), max(b, a - prices[i])</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h1 id="3-123-买卖股票的最佳时机-III"><a href="#3-123-买卖股票的最佳时机-III" class="headerlink" title="3.123. 买卖股票的最佳时机 III"></a>3.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 </p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 &#x3D; 0）的时候买入，在第 6 天（股票价格 &#x3D; 3）的时候卖出，这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 &#x3D; 1）的时候买入，在第 8 天 （股票价格 &#x3D; 4）的时候卖出，这笔交易所能获得利润 &#x3D; 4-1 &#x3D; 3 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; prices.length &lt;&#x3D; 105</span><br><span class="line">0 &lt;&#x3D; prices[i] &lt;&#x3D; 105</span><br></pre></td></tr></table></figure><h2 id="思路及解法-2"><a href="#思路及解法-2" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>参考官方题解，感觉很多答案虽然能够通过，但是过于复杂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buy1 &#x3D; max(buy1, -prices[i])</span><br><span class="line">sell1 &#x3D; max(sell1, buy1 + prices[i])</span><br><span class="line">buy2 &#x3D; max(buy2, sell1 - prices[i])</span><br><span class="line">sell2 &#x3D; max(sell2, buy2 + prices[i])</span><br></pre></td></tr></table></figure><p>buy1、sell1、buy2、sell2分别代表：第一次买入（持有）、卖出（不持有）、第二次买入（持有）、卖出（不持有）。</p><p>针对每一个我们的都可以假设其作为买入点，然后看看卖出第一个的时候是否赚钱更多；</p><p>在第一个买入的基础上，我们来寻找第二个买入，同样寻找第二个卖出的最赚钱点。</p><p>通过下面的表格可以更好来看这个是否正确，</p><table><thead><tr><th></th><th>3</th><th>3</th><th>5</th><th>0</th><th>0</th><th>3</th><th>1</th><th>4</th></tr></thead><tbody><tr><td>buy1</td><td>-3</td><td>-3</td><td>-3</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>sell1</td><td>0</td><td>0</td><td>2</td><td>2</td><td>2</td><td>3</td><td>3</td><td>4</td></tr><tr><td>buy2</td><td>-3</td><td>-3</td><td>-3</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>sell2</td><td>0</td><td>0</td><td>2</td><td>2</td><td>2</td><td>5</td><td>5</td><td>6</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        buy1 = buy2 = -prices[<span class="number">0</span>]</span><br><span class="line">        sell1 = sell2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            buy1 = max(buy1, -prices[i])</span><br><span class="line">            sell1 = max(sell1, buy1 + prices[i])</span><br><span class="line">            buy2 = max(buy2, sell1 - prices[i])</span><br><span class="line">            sell2 = max(sell2, buy2 + prices[i])</span><br><span class="line">            print(buy1, sell1, buy2, sell2)</span><br><span class="line">        <span class="keyword">return</span> sell2</span><br></pre></td></tr></table></figure><h1 id="4-188-买卖股票的最佳时机-IV"><a href="#4-188-买卖股票的最佳时机-IV" class="headerlink" title="4.188. 买卖股票的最佳时机 IV"></a>4.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 &#x3D; 2) 的时候买入，在第 2 天 (股票价格 &#x3D; 4) 的时候卖出，这笔交易所能获得利润 &#x3D; 4-2 &#x3D; 2 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k &#x3D; 2, prices &#x3D; [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 &#x3D; 2) 的时候买入，在第 3 天 (股票价格 &#x3D; 6) 的时候卖出, 这笔交易所能获得利润 &#x3D; 6-2 &#x3D; 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 &#x3D; 0) 的时候买入，在第 6 天 (股票价格 &#x3D; 3) 的时候卖出, 这笔交易所能获得利润 &#x3D; 3-0 &#x3D; 3 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">0 &lt;&#x3D; k &lt;&#x3D; 100</span><br><span class="line">0 &lt;&#x3D; prices.length &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; prices[i] &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><h2 id="思路及解法-3"><a href="#思路及解法-3" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>思路和上面一样，只是用一个循环把k中情况都要考虑进来，buy[k]的前提都是sell[k-1]。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, k: int, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        buy = [-prices[<span class="number">0</span>]] * k</span><br><span class="line">        sell = [<span class="number">0</span>] * k</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            buy[<span class="number">0</span>] = max(buy[<span class="number">0</span>], -prices[i])</span><br><span class="line">            sell[<span class="number">0</span>] = max(sell[<span class="number">0</span>], buy[<span class="number">0</span>] + prices[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, k):</span><br><span class="line">                buy[j] = max(buy[j], sell[j<span class="number">-1</span>] - prices[i])</span><br><span class="line">                sell[j] = max(sell[j], buy[j] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> sell[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-309-最佳买卖股票时机含冷冻期"><a href="#5-309-最佳买卖股票时机含冷冻期" class="headerlink" title="5.309. 最佳买卖股票时机含冷冻期"></a>5.<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。</p><p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><p>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,0,2]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</span><br></pre></td></tr></table></figure><h2 id="解法及思路"><a href="#解法及思路" class="headerlink" title="解法及思路"></a>解法及思路</h2><p>这一题也是典型的动态规划，就是需要重新定义一下dp[i] [1]，现在表示：第i-1天持有股票（买入），此时买入需要考虑一下dp[i-1] [1]和dp[i-2] [0]因为中间有一个是冷冻期，不能够买入，所以需要回退到前两天。</p><p>边界：我们的dp长度是n+1，dp[1] [0], dp[1] [1] = 0, - prices[0]，</p><p>状态转移方程：<br>$$<br>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i-1])</p><p>$$</p><p>$$<br>dp[i][1] = max(dp[i - 1][1], dp[i - 2][0] - prices[i-1])<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># dp[i][0]表示第i-1天不持有股票, dp[i][1]表示第i-1天持有股票</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>, - prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i<span class="number">-1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">#print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><blockquote><p>优化空间</p></blockquote><p>因为上面的方程式只涉及到三个值，dp[i - 1] [0]、dp[i - 1] [1]、dp[i - 2] [0]，所以用abc代替这三个值即可，这样就可以把空间大大优化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="comment"># a, b表示第i天不持有和持有，c表示上一次不持有</span></span><br><span class="line">        a, b, c = <span class="number">0</span>, -prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            a, b, c = max(a, b + prices[i]), max(b, c-prices[i]), a</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><h1 id="6-2110-股票平滑下跌阶段的数目"><a href="#6-2110-股票平滑下跌阶段的数目" class="headerlink" title="6.2110. 股票平滑下跌阶段的数目"></a>6.<a href="https://leetcode-cn.com/problems/number-of-smooth-descent-periods-of-a-stock/">2110. 股票平滑下跌阶段的数目</a></h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。</p><p>一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。</p><p>请你返回 平滑下降阶段 的数目。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [3,2,1,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：总共有 7 个平滑下降阶段：</span><br><span class="line">[3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1]</span><br><span class="line">注意，仅一天按照定义也是平滑下降阶段。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [8,6,7,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7]</span><br><span class="line">由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1]</span><br><span class="line">输出：1</span><br><span class="line">解释：总共有 1 个平滑下降阶段：[1]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; prices.length &lt;&#x3D; 10**5</span><br><span class="line">1 &lt;&#x3D; prices[i] &lt;&#x3D; 10**5</span><br></pre></td></tr></table></figure><h2 id="思路及解法-4"><a href="#思路及解法-4" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>很简单的一道题目，dp[i]表示前i天有多少个平滑下降阶段。</p><p>边界初始:  dp = [1] * n</p><p>状态方程dp[i] = dp[i-1] + 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getDescentPeriods(self, prices: List[int]) -&gt; int:</span><br><span class="line">        n &#x3D; len(prices)</span><br><span class="line">        dp &#x3D; [1] * n</span><br><span class="line">        for i in range(1, n):</span><br><span class="line">            if prices[i] + 1 &#x3D;&#x3D; prices[i-1]:</span><br><span class="line">                dp[i] &#x3D; dp[i-1] + 1</span><br><span class="line">        return sum(dp)</span><br></pre></td></tr></table></figure><blockquote><p>优化</p></blockquote><p>因为 dp[i]只与dp[i-1]有关，所以我们可以直接不用数组，用变量保存下来即可。</p><p>ans保存最终的结果，cnt保存当前i结尾有多少个平滑下降阶段。如果i-1是平滑下降，i也是平滑下降，那么i的结果就要在i-1的基础上+1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDescentPeriods</span>(<span class="params">self, prices: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> prices[i] + <span class="number">1</span> == prices[i<span class="number">-1</span>]:</span><br><span class="line">                cnt = cnt + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            ans += cnt</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1, 3, 2, 8, 4, 9], fee &#x3D; 2</span><br><span class="line">输出：8</span><br><span class="line">解释：能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] &#x3D; 1</span><br><span class="line">在此处卖出 prices[3] &#x3D; 8</span><br><span class="line">在此处买入 prices[4] &#x3D; 4</span><br><span class="line">在此处卖出 prices[5] &#x3D; 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) &#x3D; 8</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices &#x3D; [1,3,7,5,10,3], fee &#x3D; 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; prices.length &lt;&#x3D; 5 * 104</span><br><span class="line">1 &lt;&#x3D; prices[i] &lt; 5 * 104</span><br><span class="line">0 &lt;&#x3D; fee &lt; 5 * 104</span><br></pre></td></tr></table></figure><h2 id="思路及解法-5"><a href="#思路及解法-5" class="headerlink" title="思路及解法"></a>思路及解法</h2><blockquote><p>第一种解法</p></blockquote><p>这个和第二题思路模拟一样，只是在判断股价是否上升的时候需要加入一个fee。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int], fee: int</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        minPrice = prices[<span class="number">0</span>]</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; minPrice:</span><br><span class="line">                minPrice = prices[i]</span><br><span class="line">            <span class="keyword">elif</span> prices[i] &gt; minPrice + fee:</span><br><span class="line">                sum += prices[i] - minPrice - fee</span><br><span class="line">                minPrice = prices[i] - fee</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><blockquote><p>第二种解法</p></blockquote><p>和第二题思路一模一样，只是加入了一个fee，不做讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[int], fee: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        dp1 = [<span class="number">0</span>] * n   <span class="comment"># 买入</span></span><br><span class="line">        dp2 = [<span class="number">0</span>] * n   <span class="comment"># 卖出</span></span><br><span class="line">        dp1[<span class="number">0</span>] = -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp1[i] = max(dp1[i<span class="number">-1</span>], dp2[i<span class="number">-1</span>] - prices[i])</span><br><span class="line">            dp2[i] = max(dp2[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>] + prices[i] - fee)</span><br><span class="line">        print(dp2[<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp2[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字典树</title>
      <link href="2022/01/18/220118%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>2022/01/18/220118%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>定义</p></blockquote><p>字典树，又称单词查找树，Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>可以稍微简单一些，直接把字典树称之为前缀树更容易理解。例如现在有一些单词{in,ing, ine, iner}，很明显他们可以共同使用一个前缀in，这样在进行查找的时候就可以直接利用公共前缀，而无需多次查找，降低时间复杂度。</p><blockquote><p>基本操作</p></blockquote><p>包括三种，分别是：插入、查找、删除，删除用的是最少的。</p><p><strong>1. 创建 TrieNode 类</strong></p><p>创建一个类，初始化一个TriNode，用字典保存结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nodes = dict()  <span class="comment"># 构建字典</span></span><br><span class="line">        self.is_leaf = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>2. 添加 insert 函数</strong></p><p>插入一个字到字典树中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: str</span>):</span> </span><br><span class="line">        curr = self</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> curr.nodes:</span><br><span class="line">                curr.nodes[char] = TrieNode()</span><br><span class="line">            curr = curr.nodes[char]</span><br><span class="line">        curr.is_leaf = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>3. 添加 insert_many 函数</strong></p><p>插入多个字到字典树中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_many</span>(<span class="params">self, words: [str]</span>):</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            self.insert(word)</span><br></pre></td></tr></table></figure><p><strong>4. 添加 search 函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: str</span>):</span></span><br><span class="line">        curr = self</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> curr.nodes:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr = curr.nodes[char]</span><br><span class="line">        <span class="keyword">return</span> curr.is_leaf</span><br></pre></td></tr></table></figure><p><strong>完整代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nodes = dict()  <span class="comment"># 构建字典</span></span><br><span class="line">        self.is_leaf = <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word: str</span>):</span> </span><br><span class="line">        curr = self</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> curr.nodes:</span><br><span class="line">                curr.nodes[char] = TrieNode()</span><br><span class="line">            curr = curr.nodes[char]</span><br><span class="line">        curr.is_leaf = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_many</span>(<span class="params">self, words: [str]</span>):</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            self.insert(word)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word: str</span>):</span></span><br><span class="line">        curr = self</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> curr.nodes:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            curr = curr.nodes[char]</span><br><span class="line">        <span class="keyword">return</span> curr.is_leaf</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/MasterMonkInTemple/p/11363415.html">https://www.cnblogs.com/MasterMonkInTemple/p/11363415.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解“深度优先遍历”问题</title>
      <link href="2022/01/17/220117%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/"/>
      <url>2022/01/17/220117%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></p><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></p><p><a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></p><h1 id="1-112-路径总和"><a href="#1-112-路径总和" class="headerlink" title="1.112. 路径总和"></a>1.<a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum &#x3D; 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [], targetSum &#x3D; 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">树中节点的数目在范围 [0, 5000] 内</span><br><span class="line">-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</span><br><span class="line">-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><h2 id="解法一：递归、DFS"><a href="#解法一：递归、DFS" class="headerlink" title="解法一：递归、DFS"></a>解法一：递归、DFS</h2><p>递归解法，对任意一个节点，都有三种情况：</p><p>第一种：该节点为空，返回False；</p><p>第二种：该节点为叶子结点（即没有左右子节点），判断当前值与targetSum是否相等；</p><p>第三种：该节点有叶子结点，同时递归调用，判断左右节点，并需要将targetSum减去当前节点的值（即当前节点加入路径中）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: Optional[TreeNode], targetSum: int</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> targetSum == root.val</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val)</span><br></pre></td></tr></table></figure><h2 id="解法二：栈"><a href="#解法二：栈" class="headerlink" title="解法二：栈"></a>解法二：栈</h2><p>每个节点入栈，都会把根节点到当前节点的路径和记录下来，只要判断当遇到叶子结点时，路径和是否相等即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root, sum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        stack.append([root, root.val])</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node, path = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> path == sum:</span><br><span class="line">                <span class="comment"># 叶子节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                <span class="comment"># 左节点加入栈</span></span><br><span class="line">                stack.append([node.left, path + node.left.val])</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="comment"># 右节点加入栈</span></span><br><span class="line">                stack.append([node.right, path + node.right.val])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="2-113-路径总和-II"><a href="#2-113-路径总和-II" class="headerlink" title="2.113. 路径总和 II"></a>2.<a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h1><p>这个题的题目和上面差不多，只是需要把路径和符合要求的路径保存下来，所以需要稍微调整一下。</p><h2 id="解法一：回溯backtrack"><a href="#解法一：回溯backtrack" class="headerlink" title="解法一：回溯backtrack"></a>解法一：回溯backtrack</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: Optional[TreeNode], targetSum: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="comment"># 边界</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                <span class="comment"># 左节点不为空</span></span><br><span class="line">                res.append(root.val)</span><br><span class="line">                targetSum -= root.val</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">                  <span class="comment"># 这个地方位置不能错，因为只有把root加入之后才算是完成了一条完整的路径 </span></span><br><span class="line">                    result.append(res[:])</span><br><span class="line">                backtrack(root.left, targetSum)</span><br><span class="line">                backtrack(root.right, targetSum)</span><br><span class="line">                targetSum += root.val</span><br><span class="line">                res.pop()</span><br><span class="line">                </span><br><span class="line">        result = []</span><br><span class="line">        res = []</span><br><span class="line">        backtrack(root, targetSum)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="3-437-路径总和-III"><a href="#3-437-路径总和-III" class="headerlink" title="3.437. 路径总和 III"></a>3.<a href="https://leetcode-cn.com/problems/path-sum-iii/">437. 路径总和 III</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示:</span><br><span class="line">二叉树的节点个数的范围是 [0,1000]</span><br><span class="line">-109 &lt;&#x3D; Node.val &lt;&#x3D; 109 </span><br><span class="line">-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000 </span><br></pre></td></tr></table></figure><h2 id="解法一：回溯"><a href="#解法一：回溯" class="headerlink" title="解法一：回溯"></a>解法一：回溯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">self, root: TreeNode, targetSum: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            targetSum -= root.val</span><br><span class="line">            <span class="keyword">if</span> targetSum == <span class="number">0</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            res += backtrack(root.left, targetSum)</span><br><span class="line">            res += backtrack(root.right, targetSum)</span><br><span class="line">            targetSum += root.val</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = backtrack(root, targetSum)<span class="comment"># 从根节点出发</span></span><br><span class="line">        ans += self.pathSum(root.left, targetSum)<span class="comment"># 从左节点出发</span></span><br><span class="line">        ans += self.pathSum(root.right, targetSum) <span class="comment"># 从右节点出发</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer系列（一）</title>
      <link href="2022/01/16/220117%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97/"/>
      <url>2022/01/16/220117%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>题目列表</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></td><td></td><td></td><td></td><td></td></tr><tr><td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="1-剑指-Offer-45-把数组排成最小的数"><a href="#1-剑指-Offer-45-把数组排成最小的数" class="headerlink" title="1.剑指 Offer 45. 把数组排成最小的数"></a>1.<a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p> 示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示:</span><br><span class="line">0 &lt; nums.length &lt;&#x3D; 100</span><br><span class="line">说明:</span><br><span class="line">输出结果可能非常大，所以你需要返回一个字符串而不是整数</span><br><span class="line">拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</span><br></pre></td></tr></table></figure><h2 id="思路及解法"><a href="#思路及解法" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>这道题思路经过了一个比较大的转变，首先是直接转换为字符串，进行排序，需要对一些特别的进行处理，例如[5, 51]，排序得到的是这个结果，但是551和515后者更小，所以需要继续排序，我们想到的方法是比较一下合并的结果判断大小，是否需要交换这两个数字。这样只能通过<strong>212/222</strong>，无法完全通过。</p><p>因为会忽略掉一些特殊的情况，例如[5, 5, 51]，排序并交换之后的结果是[5, 51, 5]。很明显不符合题意。</p><p>代码思路如下（不能通过）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums: List[int]</span>) -&gt; str:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums[i] = str(nums[i])</span><br><span class="line">        nums.sort()</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            l = len(nums[i])</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i+<span class="number">1</span>] &gt; nums[i+<span class="number">1</span>] + nums[i]:</span><br><span class="line">                nums[i], nums[i+<span class="number">1</span>] = nums[i+<span class="number">1</span>], nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums)</span><br></pre></td></tr></table></figure><p>这个是没有办法解决了，就想着用sort()函数的lambda函数直接实现排序和交换，定义好排序的顺序。</p><p>定义一个cmp函数，直接在sort排序的时候当作key就可以实现，并且可以通过所有的测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumber</span>(<span class="params">self, nums: List[int]</span>) -&gt; str:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            nums[i] = str(nums[i])</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">cmp</span>(<span class="params">a, b</span>):</span></span><br><span class="line">            <span class="keyword">if</span> a + b &gt; b + a:</span><br><span class="line">                <span class="comment"># a &gt; b</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> a + b == b + a:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        nums.sort(key=cmp_to_key(cmp))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums)</span><br></pre></td></tr></table></figure><h1 id="2-剑指-Offer-04-二维数组中的查找"><a href="#2-剑指-Offer-04-二维数组中的查找" class="headerlink" title="2.剑指 Offer 04. 二维数组中的查找"></a>2.<a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p> 示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure><p>限制：</p><p>0 &lt;= n &lt;= 1000</p><p>0 &lt;= m &lt;= 1000</p><h2 id="思路及解法-1"><a href="#思路及解法-1" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>这题需要利用矩阵的相关性质：从左到右、从上到下都是递增的。</p><p>首先我们如果可以确定target在哪一行，就可以确定它在哪一列，因此我们选定一个元素，如果该元素大于target，说明行需要减少，如果小于target，说明列需要增加。</p><p>接下来就是初始从哪里开始，矩阵一定是从四个角开始，如果从左上角[0, 0]（记为A）开始肯定不符合要求，因为如果A&gt;target，我们不知道增加行还是增加列，同理如果从右下角[n-1,n -1]开始也不符合要求；</p><p>如果从右上角[0, n-1]开始，我们同样无法找到符合要求的，但是从左下角[n-1, 0]开始就可以找到符合题意的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix: List[List[int]], target: int</span>) -&gt; bool:</span></span><br><span class="line">        x, y = len(matrix) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> y &lt; len(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &gt; target:</span><br><span class="line">                x -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &lt; target:</span><br><span class="line">                y += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="3-剑指-Offer-14-I-剪绳子"><a href="#3-剑指-Offer-14-I-剪绳子" class="headerlink" title="3.剑指 Offer 14- I. 剪绳子"></a>3.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h1><p>这一题与<a href="https://leetcode-cn.com/problems/integer-break/">343. 整数拆分</a>是同一个题目</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 58</span><br></pre></td></tr></table></figure><h2 id="思路及解法-2"><a href="#思路及解法-2" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>首先我们需要知道，如果把一个数字拆分成多个，要想让积最大，一定要尽可能保证每个数字都与平均值接近，如果要证明的话可以用数学的算术几何均值不等式证明，结果是正确的。</p><p>基于上面的原则，我们就可以尝试，假设拆分成i个，p1代表n//i的整除，如果不能够整除，假设余数为j，就把j平分为1，放到i个里面，最终就会有i-j个p1，以及j个p2=p1+1。</p><p>例如，10，我们分成3个，i=3;p1 = 10 // 3 = 3; j = 10 % 3 = 1; 最终就会有i-j = 2个p1=3， 以及j=1个p2=4；乘积为36.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            j = n % i</span><br><span class="line">            p1 = n // i</span><br><span class="line">            p2 = n // i + <span class="number">1</span></span><br><span class="line">            tmp = (p1 ** (i-j)) * (p2 ** j)</span><br><span class="line">            ans = max(ans, tmp)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="4-剑指-Offer-14-II-剪绳子-II"><a href="#4-剑指-Offer-14-II-剪绳子-II" class="headerlink" title="4.剑指 Offer 14- II. 剪绳子 II"></a>4.<a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/">剑指 Offer 14- II. 剪绳子 II</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><h2 id="思路及解法-3"><a href="#思路及解法-3" class="headerlink" title="思路及解法"></a>思路及解法</h2><p>和上面一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            j = n % i</span><br><span class="line">            p1 = n // i</span><br><span class="line">            p2 = n // i + <span class="number">1</span></span><br><span class="line">            tmp = (p1 ** (i-j)) * (p2 ** j)</span><br><span class="line">            ans = max(ans, tmp)</span><br><span class="line">        <span class="keyword">if</span> ans &gt; <span class="number">1000000007</span>:</span><br><span class="line">            ans %= <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">return</span> int(ans)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第276场周赛</title>
      <link href="2022/01/16/220116-276%E5%91%A8%E8%B5%9B/"/>
      <url>2022/01/16/220116-276%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-5980-将字符串拆分为若干长度为-k-的组"><a href="#1-5980-将字符串拆分为若干长度为-k-的组" class="headerlink" title="1.5980. 将字符串拆分为若干长度为 k 的组"></a>1.<a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">5980. 将字符串拆分为若干长度为 k 的组</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>字符串 s 可以按下述步骤划分为若干长度为 k 的组：</p><p>第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。<br>对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。<br>注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</p><p>给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdefghi&quot;, k &#x3D; 3, fill &#x3D; &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">解释：</span><br><span class="line">前 3 个字符是 &quot;abc&quot; ，形成第一组。</span><br><span class="line">接下来 3 个字符是 &quot;def&quot; ，形成第二组。</span><br><span class="line">最后 3 个字符是 &quot;ghi&quot; ，形成第三组。</span><br><span class="line">由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。</span><br><span class="line">因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdefghij&quot;, k &#x3D; 3, fill &#x3D; &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;]</span><br><span class="line">解释：</span><br><span class="line">与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br><span class="line">对于最后一组，字符串中仅剩下字符 &#39;j&#39; 可以用。为了补全这一组，使用填充字符 &#39;x&#39; 两次。</span><br><span class="line">因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 100</span><br><span class="line">s 仅由小写英文字母组成</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 100</span><br><span class="line">fill 是一个小写英文字母</span><br></pre></td></tr></table></figure><h2 id="解法：简单模拟"><a href="#解法：简单模拟" class="headerlink" title="解法：简单模拟"></a>解法：简单模拟</h2><p>首先判断一下长度，然后把需要填充的fill数量计算出来并加进去，最后遍历每k个输出即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divideString</span>(<span class="params">self, s: str, k: int, fill: str</span>) -&gt; List[str]:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        m = n % k</span><br><span class="line">        s += fill * (k - m)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n, k):</span><br><span class="line">            ans.append(s[i:i+k])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="2-5194-得到目标值的最少行动次数"><a href="#2-5194-得到目标值的最少行动次数" class="headerlink" title="2.5194. 得到目标值的最少行动次数"></a>2.<a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">5194. 得到目标值的最少行动次数</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。</p><p>在一次行动中，你可以做下述两种操作之一：</p><p>递增，将当前整数的值加 1（即， x = x + 1）。<br>加倍，使当前整数的值翻倍（即，x = 2 * x）。<br>在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。</p><p>给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 5, maxDoubles &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line">解释：一直递增 1 直到得到 target 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 19, maxDoubles &#x3D; 2</span><br><span class="line">输出：7</span><br><span class="line">解释：最初，x &#x3D; 1 。</span><br><span class="line">递增 3 次，x &#x3D; 4 。</span><br><span class="line">加倍 1 次，x &#x3D; 8 。</span><br><span class="line">递增 1 次，x &#x3D; 9 。</span><br><span class="line">加倍 1 次，x &#x3D; 18 。</span><br><span class="line">递增 1 次，x &#x3D; 19 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 10, maxDoubles &#x3D; 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最初，x &#x3D; 1 。 </span><br><span class="line">递增 1 次，x &#x3D; 2 。 </span><br><span class="line">加倍 1 次，x &#x3D; 4 。 </span><br><span class="line">递增 1 次，x &#x3D; 5 。 </span><br><span class="line">加倍 1 次，x &#x3D; 10 。 </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; target &lt;&#x3D; 10**9</span><br><span class="line">0 &lt;&#x3D; maxDoubles &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><h2 id="解法：反向dp"><a href="#解法：反向dp" class="headerlink" title="解法：反向dp"></a>解法：反向dp</h2><p>刚开始想着能不能用回溯做，结果是正确的，但是超时，因为数据比较大10**9；后来想着用动态规划，结果正确，但是会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">        dp[int(target / <span class="number">2</span>)] = dp[target] + <span class="number">1</span></span><br><span class="line">        target = int(target / <span class="number">2</span>)</span><br><span class="line">        maxDoubles -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dp[target - <span class="number">1</span>] = min(dp[target] + <span class="number">1</span>, dp[target - <span class="number">1</span>])</span><br><span class="line">        target -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就想着优化，需要从后面出发（原来的乘以2变为除以2，原来的加1变为减1），遇到合适的就先利用double除以2，不合适的就递减即可。</p><p>如果走到中间maxDoubles用完了，就说明剩下的全部都是-1操作，直接跳出循环即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, target: int, maxDoubles: int</span>) -&gt; int:</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">                pre = pre + <span class="number">1</span></span><br><span class="line">                target = int(target / <span class="number">2</span>)</span><br><span class="line">                maxDoubles -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">                pre = pre + <span class="number">1</span></span><br><span class="line">                target -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> maxDoubles == <span class="number">0</span>:</span><br><span class="line">                pre += target - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h1 id="3-5982-解决智力问题"><a href="#3-5982-解决智力问题" class="headerlink" title="3.5982. 解决智力问题"></a>3.<a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">5982. 解决智力问题</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。</p><p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p><p>比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：<br>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。<br>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br>请你返回这场考试里你能获得的 最高 分数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions &#x3D; [[3,2],[4,3],[4,4],[2,5]]</span><br><span class="line">输出：5</span><br><span class="line">解释：解决问题 0 和 3 得到最高分。</span><br><span class="line"></span><br><span class="line">- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 1 和 2</span><br><span class="line">- 解决问题 3 ：获得 2 分</span><br><span class="line">  总得分为：3 + 2 &#x3D; 5 。没有别的办法获得 5 分或者多于 5 分。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]]</span><br><span class="line">输出：7</span><br><span class="line">解释：解决问题 1 和 4 得到最高分。</span><br><span class="line">- 跳过问题 0</span><br><span class="line">- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 2 和 3</span><br><span class="line">- 解决问题 4 ：获得 5 分</span><br><span class="line">  总得分为：2 + 5 &#x3D; 7 。没有别的办法获得 7 分或者多于 7 分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; questions.length &lt;&#x3D; 105</span><br><span class="line">questions[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; pointsi, brainpoweri &lt;&#x3D; 105</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>第三题和第二题，解决思路是差不多的，因为都存在一个选择和不选择问题，就想着用回溯，结果是不行的；然后就用动态规划，超出时间限制，就需要不停优化。这个题目没有做出来，参考了一下其他人的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span>(<span class="params">self, questions: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(questions)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            q = questions[i]</span><br><span class="line">            j = i + q[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            dp[i] = max(dp[i + <span class="number">1</span>], q[<span class="number">0</span>] + (dp[j] <span class="keyword">if</span> j &lt; n <span class="keyword">else</span> <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>下面这个解法就是递归（回溯），用的非常好，但是更好的地方是用了一个@functools.lru_cache(None)，还是第一次遇到，如果没有这一行代码是无法通过的，会超时，用了之后就可以通过。</p><p>在functools这个模块中，有lru_cache这个一个神奇的<a href="https://so.csdn.net/so/search?q=%E8%A3%85%E9%A5%B0%E5%99%A8&spm=1001.2101.3001.7020">装饰器</a>存在。functools.lru_cache的作用主要是用来做缓存，他能把相对耗时的函数结果进行保存，避免传入相同的参数重复计算。同时，缓存并不会无限增长，不用的缓存会被释放。</p><p>具体用法可以参考这里：<a href="https://blog.csdn.net/wzqnls/article/details/78506022">https://blog.csdn.net/wzqnls/article/details/78506022</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span>(<span class="params">self, questions: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">t=<span class="number">0</span></span>) :</span></span><br><span class="line">            <span class="keyword">if</span> t &gt;= len(questions) :</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            points, brainpower = questions[t]</span><br><span class="line">            <span class="keyword">return</span> max(points+solve(t+brainpower+<span class="number">1</span>), solve(t+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> solve()</span><br></pre></td></tr></table></figure><p>第四题有时间就整理吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解：堆（优先队列）应用</title>
      <link href="2022/01/15/220115%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
      <url>2022/01/15/220115%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-堆的相关操作"><a href="#1-堆的相关操作" class="headerlink" title="1. 堆的相关操作"></a>1. 堆的相关操作</h1><table><thead><tr><th>函 数</th><th>函 数</th></tr></thead><tbody><tr><td>heappush(heap, x)</td><td>将x压入堆中</td></tr><tr><td>heappop(heap)</td><td>从堆中弹出最小的元素</td></tr><tr><td>heapify(heap)</td><td>让列表具备堆特征</td></tr><tr><td>heapreplace(heap, x)</td><td>弹出最小的元素，并将x压入堆中</td></tr><tr><td>nlargest(n, iter)</td><td>返回iter中n个最大的元素</td></tr><tr><td>nsmallest(n, iter)</td><td>返回iter中n个最小的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># 将x压入堆中</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="comment"># 建立堆，把列表的元素放如到堆heap中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="comment"># 把元素压入到堆中</span></span><br><span class="line">    heapq.heappush(heap, x[i])</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 从堆中弹出最小的元素</span></span><br><span class="line">print(heapq.heappop(heap))</span><br><span class="line"><span class="comment"># 通过heapify建立堆，可以执行尽可能少的操作</span></span><br><span class="line">heap = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 弹出最小的元素，并将10压入堆中</span></span><br><span class="line">heapq.heapreplace(heap, <span class="number">10</span>)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 返回heap中n=4个最大的元素</span></span><br><span class="line">print(heapq.nlargest(<span class="number">4</span>, heap))</span><br><span class="line"><span class="comment"># 返回iter中n=3个最小的元素</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">4</span>, heap))</span><br></pre></td></tr></table></figure><p>heapq只能够建立小根堆，有时候我们需要建立大根堆，这个时候我们只需要把需要加入的值乘-1，就相当于是建立大根堆了。</p><h1 id="2-面试题-17-09-第-k-个数"><a href="#2-面试题-17-09-第-k-个数" class="headerlink" title="2.面试题 17.09. 第 k 个数"></a>2.<a href="https://leetcode-cn.com/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 5</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><h2 id="解法一：堆"><a href="#解法一：堆" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>题目已经指定素因子只有3，5，7三个数字，我们先把这三个数字压入堆中，每次弹出一个数字，然后把弹出的数字分别乘3，5，7再压入堆中，以此类推即可。</p><p>需要注意的是，压入堆中的元素会存在重复，例如弹出3的时候会压入9，15，21；弹出5的时候，会压入15，25，35；这里就会存在15的重复。</p><p>所以我们每次弹出一个最小元素的时候，需要判断一下堆中当前最小元素与之前弹出的最小元素是否相等，如果相等就需要把其弹出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthMagicNumber</span>(<span class="params">self, k: int</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> res == heap[<span class="number">0</span>]:  <span class="comment">#去除重复元素</span></span><br><span class="line">                <span class="comment"># 我们只需要往里面加元素即可，当弹出最小元素的时候，我们判断弹出的元素与堆最小的第元素是否相等</span></span><br><span class="line">                <span class="comment"># 如果相等就继续弹出，直至不想等</span></span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            <span class="comment"># 把当前元素的相关元素压入堆中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]:</span><br><span class="line">                heapq.heappush(heap, res * num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划（三指针）"><a href="#解法二：动态规划（三指针）" class="headerlink" title="解法二：动态规划（三指针）"></a>解法二：动态规划（三指针）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthMagicNumber</span>(<span class="params">self, k: int</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        idx3, idx5, idx7 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            a, b, c = res[idx3] * <span class="number">3</span>, res[idx5] * <span class="number">5</span>, res[idx7] * <span class="number">7</span></span><br><span class="line">            res.append(min(a, b, c))</span><br><span class="line">            <span class="comment"># 三个if一定要都执行，不能够用elif，这样就可以保证如果有相同的数字，都可以执行+1操作</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == a:</span><br><span class="line">                idx3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == b:</span><br><span class="line">                idx5 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == c:</span><br><span class="line">                idx7 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-264-丑数-II"><a href="#3-264-丑数-II" class="headerlink" title="3.264. 丑数 II"></a>3.<a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 1690</span><br></pre></td></tr></table></figure><h2 id="解法一：堆-1"><a href="#解法一：堆-1" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>方法和上面一题一模一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> res == heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]:</span><br><span class="line">                heapq.heappush(heap, res * num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划（三指针）-1"><a href="#解法二：动态规划（三指针）-1" class="headerlink" title="解法二：动态规划（三指针）"></a>解法二：动态规划（三指针）</h2><p>这个思路不是很好想出来。</p><p>可以这样理解：</p><p>初始的时候，idx2, idx3, idx5 = 0, 0, 0，第一轮之后会把2加入到队列，然后</p><table><thead><tr><th></th><th>a,b,c</th><th>res</th><th>idx2， idx3， idx5</th></tr></thead><tbody><tr><td>初始的时候</td><td></td><td>1</td><td>0， 0， 0</td></tr><tr><td>第一轮</td><td>2，3，5</td><td>1，2</td><td>1， 0， 0</td></tr><tr><td>第二轮</td><td>4，3，5</td><td>1，2，3</td><td>1，1，0</td></tr><tr><td>第三轮</td><td>4，6，5</td><td>1，2，3，5</td><td>1，1，1</td></tr></tbody></table><p>这样推导一下就可以很清晰看出来，每次用idx2， idx3， idx5来标记当前需要加入的最小值，而且保证每个数都可以乘2，3，5，只是先后顺序受到控制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        idx2, idx3, idx5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            a, b, c = res[idx2] * <span class="number">2</span>, res[idx3] * <span class="number">3</span>, res[idx5] * <span class="number">5</span></span><br><span class="line">            res.append(min(a, b, c))</span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == a:</span><br><span class="line">                idx2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == b:</span><br><span class="line">                idx3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == c:</span><br><span class="line">                idx5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="4-313-超级丑数"><a href="#4-313-超级丑数" class="headerlink" title="4.313. 超级丑数"></a>4.<a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p><p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p><p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12, primes &#x3D; [2,7,13,19]</span><br><span class="line">输出：32 </span><br><span class="line">解释：给定长度为 4 的质数数组 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1, primes &#x3D; [2,3,5]</span><br><span class="line">输出：1</span><br><span class="line">解释：1 不含质因数，因此它的所有质因数都在质数数组 primes &#x3D; [2,3,5] 中。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 106</span><br><span class="line">1 &lt;&#x3D; primes.length &lt;&#x3D; 100</span><br><span class="line">2 &lt;&#x3D; primes[i] &lt;&#x3D; 1000</span><br><span class="line">题目数据 保证 primes[i] 是一个质数</span><br><span class="line">primes 中的所有值都 互不相同 ，且按 递增顺序 排列</span><br></pre></td></tr></table></figure><h2 id="解法一：堆（超出时间限制）"><a href="#解法一：堆（超出时间限制）" class="headerlink" title="解法一：堆（超出时间限制）"></a>解法一：堆（超出时间限制）</h2><p>思路和上面讲的一模一样。</p><p>时间超时，应该是不太好优化了，尝试了第二种方法优化，减少了一些执行次数，但是还是不能够通过，参考几个解答可能都是之前的解法，后面增加了测试数据之后，还是无法通过，但是整体的思路是正确的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> res == heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> primes:</span><br><span class="line">                heapq.heappush(heap, res * num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125; <span class="comment"># 把已经出现的数字加入进来，防止重复加入</span></span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> primes:</span><br><span class="line">                next_ = res * num</span><br><span class="line">                <span class="keyword">if</span>  next_ <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    heapq.heappush(heap, next_)</span><br><span class="line">                    seen.add(next_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>这个题和上面的丑数2类似，但是现在因子变成了一个动态的primes，所以需要我们转变一下思路，设置一个index来标记每个因子的位置代替上面的idx，设置一个nums来代替上面的abc，依然是从nums中取出一个最小的加入到res中，然后把idx对应+1操作。</p><p>但是不能够用两层循环来实现，因为会出现超时的情况，下面这个版本就是把nums和index分开循环，最终提交的结果会超时报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        m = len(primes)</span><br><span class="line">        index = [<span class="number">0</span>] * m</span><br><span class="line">        nums = [<span class="number">1</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                nums[j] = res[index[j]] * primes[j]</span><br><span class="line">            min_ = min(nums)</span><br><span class="line">            res.append(min_)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == min_:</span><br><span class="line">                    index[j] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>既然思路已经有了，我们就可以想办法进行优化，依然是上面的思路，我们把第二层for循环合并为一个，只要我们初始化的时候先把nums最小值放进来，然后再同时执行index+1操作以及求下一次的nums就可以完美解决这个问题了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        m = len(primes)</span><br><span class="line">        index = [<span class="number">0</span>] * m</span><br><span class="line">        nums = [<span class="number">1</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            min_ = min(nums)</span><br><span class="line">            res[i] = min_</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == min_:</span><br><span class="line">                    index[j] += <span class="number">1</span></span><br><span class="line">                    nums[j] = res[index[j]] * primes[j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 堆（优先队列） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解：求“第k小”相关问题</title>
      <link href="2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></p><p><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></p><p><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></p><p><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a></p><p><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></p><p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></p><h1 id="1-378-有序矩阵中第-K-小的元素"><a href="#1-378-有序矩阵中第-K-小的元素" class="headerlink" title="1.378. 有序矩阵中第 K 小的元素"></a>1.<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8</span><br><span class="line">输出：13</span><br><span class="line">解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[-5]], k &#x3D; 1</span><br><span class="line">输出：-5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 300</span><br><span class="line">-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109</span><br><span class="line">题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n**2</span><br></pre></td></tr></table></figure><h2 id="解法一：暴力求解"><a href="#解法一：暴力求解" class="headerlink" title="解法一：暴力求解"></a>解法一：暴力求解</h2><p>暴力求解很简单，只需要把二维数组降维为一维数组，然后排序返回结果即可；</p><p><strong>sum(matrix, [])这个是直接降维的方法，后面遇到类似的记得学习。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        nums = sorted(sum(matrix, []))</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：使用堆来解决问题"><a href="#解法二：使用堆来解决问题" class="headerlink" title="解法二：使用堆来解决问题"></a>解法二：使用堆来解决问题</h2><p>关于堆的方法讲解可以参考下面这个题解，非常详细。</p><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/shi-yong-dui-heapde-si-lu-xiang-jie-ling-fu-python/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/shi-yong-dui-heapde-si-lu-xiang-jie-ling-fu-python/</a></p><p>大致思想就是，每次我们都从matrix中选择一个最小的元素弹出，当弹出到第k个的时候就是我们需要的。因此我们需要用堆来维护<strong>一组最小候选人</strong>，每次弹出一个最小的，就把最小元素的下一个元素加入到堆中，这样就继续从堆中选择最小元素弹出即可。</p><p>我们选取第一列作为最小候选人，第一列的每一个元素都是当前行最小的元素，每次弹出一个元素，然后把该行的下一个元素加入到堆中，知道弹出k个元素为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(matrix) <span class="comment">#注：题目中这个矩阵是n*n的，所以长宽都是n</span></span><br><span class="line">        <span class="comment">#取出第一列候选人，每个候选人组成一个三元组，当前元素以及当前元素的位置</span></span><br><span class="line">        <span class="comment">#matrix[i][0]是具体的值，后面的(i,0)是在记录候选人在矩阵中的位置，方便每次右移添加下一个候选人</span></span><br><span class="line">        heap = [(matrix[i][<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] </span><br><span class="line">        heapq.heapify(heap) <span class="comment">#变成一个heap</span></span><br><span class="line">        print(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k - <span class="number">1</span>): <span class="comment">#一共弹k次：这里k-1次，return的时候1次</span></span><br><span class="line">            num, x, y = heapq.heappop(heap) <span class="comment">#弹出候选人里最小一个</span></span><br><span class="line">            <span class="keyword">if</span> y != n - <span class="number">1</span>: <span class="comment">#如果这一行还没被弹完</span></span><br><span class="line">                heapq.heappush(heap, (matrix[x][y + <span class="number">1</span>], x, y + <span class="number">1</span>)) <span class="comment">#加入这一行的下一个候选人</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="堆的相关操作"><a href="#堆的相关操作" class="headerlink" title="堆的相关操作"></a>堆的相关操作</h2><table><thead><tr><th>函 数</th><th>函 数</th></tr></thead><tbody><tr><td>heappush(heap, x)</td><td>将x压入堆中</td></tr><tr><td>heappop(heap)</td><td>从堆中弹出最小的元素</td></tr><tr><td>heapify(heap)</td><td>让列表具备堆特征</td></tr><tr><td>heapreplace(heap, x)</td><td>弹出最小的元素，并将x压入堆中</td></tr><tr><td>nlargest(n, iter)</td><td>返回iter中n个最大的元素</td></tr><tr><td>nsmallest(n, iter)</td><td>返回iter中n个最小的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># 将x压入堆中</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="comment"># 建立堆，把列表的元素放如到堆heap中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="comment"># 把元素压入到堆中</span></span><br><span class="line">    heapq.heappush(heap, x[i])</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 从堆中弹出最小的元素</span></span><br><span class="line">print(heapq.heappop(heap))</span><br><span class="line"><span class="comment"># 通过heapify建立堆，可以执行尽可能少的操作</span></span><br><span class="line">heap = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 弹出最小的元素，并将10压入堆中</span></span><br><span class="line">heapq.heapreplace(heap, <span class="number">10</span>)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 返回heap中n=4个最大的元素</span></span><br><span class="line">print(heapq.nlargest(<span class="number">4</span>, heap))</span><br><span class="line"><span class="comment"># 返回iter中n=3个最小的元素</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">4</span>, heap))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解法三：二分查找"><a href="#解法三：二分查找" class="headerlink" title="解法三：二分查找"></a>解法三：二分查找</h2><p>上面的堆只是利用了矩阵的当前行元素是逐渐增大这个条件，如果我们把当前列元素也是逐渐增大这个条件用上的话就可以更优化。</p><p>矩阵中的最小值为left = matrix[0] [0]，最大值为right = matrix[-1] [-1]，我们取中间值mid = (left + right) // 2，如果我们在矩阵中把大于mid的值和小于mid的值分开就会发现可以把矩阵分为两个部分。</p><img src="/2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.png" class><p>所以我们只需要统计mid左边的数量，以及mid右边的数量，然后比较一下就可以知道，当前的mid是大了还是笑了，如果左边的数量&gt;k那么说明mid太大了，需要减小；如果右边的数量&gt;k那么说明mid太小了，需要增大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">mid</span>):</span></span><br><span class="line">            <span class="comment"># 从左下角开始查找，这样可以保证mid始终比自己左上角的值大</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            i, j = n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &lt;= mid:</span><br><span class="line">                    num += i + <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= k <span class="comment"># 判断num是否大于等于k</span></span><br><span class="line">        left, right = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left                </span><br></pre></td></tr></table></figure><h1 id="2-373-查找和最小的-K-对数字"><a href="#2-373-查找和最小的-K-对数字" class="headerlink" title="2.373. 查找和最小的 K 对数字"></a>2.<a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。</p><p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</p><p>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  …  (uk,vk) 。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,1],[1,1]</span><br><span class="line">解释: 返回序列中的前 2 对数：</span><br><span class="line">     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3 </span><br><span class="line">输出: [1,3],[2,3]</span><br><span class="line">解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]</span><br></pre></td></tr></table></figure><p>提示:</p><p>1 &lt;= nums1.length, nums2.length &lt;= 105<br>-109 &lt;= nums1[i], nums2[i] &lt;= 109<br>nums1 和 nums2 均为升序排列<br>1 &lt;= k &lt;= 1000</p><h2 id="解法一：堆"><a href="#解法一：堆" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>以数对和来建立堆，每个堆中还需要保存当前数对的位置，同时需要注意的是：判断循环的条件，需要考虑到两个数组组成的数对小于k个的问题，例如：[1,2] 、[3]、3。所以需要加一个必须堆不为空的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSmallestPairs</span>(<span class="params">self, nums1: List[int], nums2: List[int], k: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        m, n = len(nums1), len(nums2)</span><br><span class="line">        heap = [(nums1[i] + nums2[<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(min(k, m))]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> len(ans) &lt; k:</span><br><span class="line">            _, x, y = heapq.heappop(heap)</span><br><span class="line">            ans.append([nums1[x], nums2[y]])</span><br><span class="line">            <span class="keyword">if</span> y + <span class="number">1</span> &lt; n:</span><br><span class="line">                heapq.heappush(heap, (nums1[x] + nums2[y+<span class="number">1</span>], x, y+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="3-668-乘法表中第k小的数"><a href="#3-668-乘法表中第k小的数" class="headerlink" title="3.668. 乘法表中第k小的数"></a>3.<a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？</p><p>给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。</p><p>例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 3, k &#x3D; 5</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">乘法表:</span><br><span class="line">123</span><br><span class="line">246</span><br><span class="line">369</span><br><span class="line">第5小的数字是 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure><p>例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 2, n &#x3D; 3, k &#x3D; 6</span><br><span class="line">输出: 6</span><br><span class="line">解释: </span><br><span class="line">乘法表:</span><br><span class="line">123</span><br><span class="line">246</span><br><span class="line">第6小的数字是 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">m 和 n 的范围在 [1, 30000] 之间。</span><br><span class="line">k 的范围在 [1, m * n] 之间。</span><br></pre></td></tr></table></figure><h2 id="解法一：堆（超出时间限制）"><a href="#解法一：堆（超出时间限制）" class="headerlink" title="解法一：堆（超出时间限制）"></a>解法一：堆（超出时间限制）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNumber</span>(<span class="params">self, m: int, n: int, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 如果m大于k说明堆有一部分用不到，所以取两者中最小的</span></span><br><span class="line">        heap = [(i, i, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>)]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            num, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> y != n:</span><br><span class="line">                <span class="comment"># 这里结束应该是n，而不是n-1</span></span><br><span class="line">                heapq.heappush(heap, (x * (y + <span class="number">1</span>), x, y + <span class="number">1</span>))</span><br><span class="line">        ans, _, _ = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNumber</span>(<span class="params">self, m: int, n: int, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">mid</span>):</span></span><br><span class="line">            <span class="comment"># 从左下角开始查找，这样可以保证mid始终比自己左上角的值大</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            i, j = m, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> j &lt;= n:</span><br><span class="line">                <span class="keyword">if</span> i * j &lt;= mid:</span><br><span class="line">                    num += i</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= k <span class="comment"># 判断num是否大于等于k</span></span><br><span class="line">        left, right = <span class="number">1</span> * <span class="number">1</span>, m * n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left                </span><br></pre></td></tr></table></figure><h1 id="4-719-找出第-k-小的距离对"><a href="#4-719-找出第-k-小的距离对" class="headerlink" title="4.719. 找出第 k 小的距离对"></a>4.<a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums &#x3D; [1,3,1]</span><br><span class="line">k &#x3D; 1</span><br><span class="line">输出：0 </span><br><span class="line">解释：</span><br><span class="line">所有数对如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示:</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; len(nums) &lt;&#x3D; 10000.</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; len(nums) * (len(nums) - 1) &#x2F; 2.</span><br></pre></td></tr></table></figure><h2 id="解法一：堆（超出时间限制）-1"><a href="#解法一：堆（超出时间限制）-1" class="headerlink" title="解法一：堆（超出时间限制）"></a>解法一：堆（超出时间限制）</h2><p>首先针对nums按照升序排序，然后我们以[1, 2, 3, 4]为例，来推演一下结果：</p><p>对角线为空，对于左下角和右上角会存在重复，所以我们只需要考虑一个即可，中间的结果是绝对值。</p><table><thead><tr><th align="center">nums</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>通过这个表格我们会发现，最小的值是按照对角线排列，所以我们可以先把结果为1的加入到堆中，然后每次遇到最小值，就把当前最小值弹出，并把当前结果右侧的一个结果放入到堆中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDistancePair</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        heap = [(abs(nums[i<span class="number">-1</span>] - nums[i]), i<span class="number">-1</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n)]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            _, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> y != n - <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(heap, (abs(nums[x] - nums[y+<span class="number">1</span>]), x, y + <span class="number">1</span>))</span><br><span class="line">        num, _, _ = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h2 id="解法二：二分查找-1"><a href="#解法二：二分查找-1" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><p>由于堆排序会出现超时情况，所以我们在这里考虑二分查找。</p><p><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/solution/719-zhao-chu-di-k-xiao-de-ju-chi-dui-er-g1i76/">https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/solution/719-zhao-chu-di-k-xiao-de-ju-chi-dui-er-g1i76/</a></p><img src="/2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.png" class><p>看上面这张图，我们用二分查找的时候，需要统计小于等于mid的值有多少个，距离对的所有值是上图红色标记的部分，我们来推导一个check(mid)这个过程。</p><p>建设初始的mid为1，</p><p>第一轮:r=0, l=0,while不执行，此时cnt=0</p><p>第二轮:r=1, l=0, 此时while执行l=1，cnt=1</p><p>第三轮:r=2,l=1,此时while执行l=2, cnt=2</p><p>第四轮:r=3,l=2,此时while执行l=3，cnt= 3</p><p>返回结果判断cnt的值是否大于k，如果大于k说明mid太大了，right右边界降低，否则left左边界提高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDistancePair</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">mid</span>):</span></span><br><span class="line">            cnt = l = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">while</span> nums[r] - nums[l] &gt; mid:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                cnt += r - l</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        left, right = <span class="number">0</span>, nums[<span class="number">-1</span>] - nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h1 id="5-658-找到-K-个最接近的元素"><a href="#5-658-找到-K-个最接近的元素" class="headerlink" title="5.658. 找到 K 个最接近的元素"></a>5.<a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。</p><p>整数 a 比整数 b 更接近 x 需要满足：</p><p>|a - x| &lt; |b - x| 或者<br>|a - x| == |b - x| 且 a &lt; b</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 4, x &#x3D; 3</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 4, x &#x3D; -1</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; arr.length</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 104</span><br><span class="line">数组里的每个元素与 x 的绝对值不超过 104</span><br></pre></td></tr></table></figure><h2 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h2><p>采用双指针，从两边往中间逼近，如果从左边距离x的距离大于右边的话，那么就需要把左边的往右移动，否则就需要把右边的往左边移动。同时需要注意循环条件，保证中间又k个元素存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span>(<span class="params">self, arr: List[int], k: int, x: int</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 采用双指针，从两边往中间逼近</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(arr)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> (right-left+<span class="number">1</span>) &gt; k:</span><br><span class="line">            l_dis, r_dis = abs(x-arr[left]), abs(x-arr[right])</span><br><span class="line">            <span class="keyword">if</span> l_dis &gt; r_dis:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[left : right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="6-786-第-K-个最小的素数分数"><a href="#6-786-第-K-个最小的素数分数" class="headerlink" title="6.786. 第 K 个最小的素数分数"></a>6.<a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。</p><p>对于每对满足 0 &lt;= i &lt; j &lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。</p><p>那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,5], k &#x3D; 3</span><br><span class="line">输出：[2,5]</span><br><span class="line">解释：已构造好的分数,排序后如下所示: </span><br><span class="line">1&#x2F;5, 1&#x2F;3, 2&#x2F;5, 1&#x2F;2, 3&#x2F;5, 2&#x2F;3</span><br><span class="line">很明显第三个最小的分数是 2&#x2F;5</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,7], k &#x3D; 1</span><br><span class="line">输出：[1,7]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; arr.length &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 3 * 104</span><br><span class="line">arr[0] &#x3D;&#x3D; 1</span><br><span class="line">arr[i] 是一个 素数 ，i &gt; 0</span><br><span class="line">arr 中的所有数字 互不相同 ，且按 严格递增 排序</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; arr.length * (arr.length - 1) &#x2F; 2</span><br></pre></td></tr></table></figure><h2 id="解法一：堆-1"><a href="#解法一：堆-1" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>这个题和上面的题目都有异曲同工之处，如果用示例 1写出来就会发现，每一行元素从右到左是递增的，从上到下是递增的。</p><p>所以我们就可以用堆，先把最后一列的元素加入到堆里面，然后再逐渐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallestPrimeFraction</span>(<span class="params">self, arr: List[int], k: int</span>) -&gt; List[int]:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        heap = [(arr[i] / arr[n<span class="number">-1</span>], i, n<span class="number">-1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>)]</span><br><span class="line">        <span class="comment"># print(heap)</span></span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            _, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> y != <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(heap, (arr[x] / arr[y - <span class="number">1</span>], x, y - <span class="number">1</span>))</span><br><span class="line">        _, x, y = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> [arr[x], arr[y]]</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></li><li><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></li><li><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/comments/">373. 查找和最小的K对数字</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">632. 最小区间</a></li><li><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a></li><li><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></li><li><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">1439. 有序矩阵中的第 k 个最小数组和</a></li><li><a href="https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/">1508. 子数组和排序后的区间和</a></li><li><a href="https://leetcode-cn.com/problems/minimize-deviation-in-array/">1675. 数组的最小偏移量</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 堆（优先队列） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解“最长递增子序列及其变形”</title>
      <link href="2022/01/12/220112%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2022/01/12/220112%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><strong>LeetCode刷题是很有规律的，我们在此称之为”子母题“，通过多个子题我们可以归纳总结出一个母题，通过一个母题我们可以演绎推理出多个子题。</strong></p><p>今天的第一个题目就是母题，后面的几个题目就是子题，我们通过这个系列来加快刷题速度，快速掌握一个相关类型的题目。</p><h1 id="1-300-最长递增子序列"><a href="#1-300-最长递增子序列" class="headerlink" title="1.300. 最长递增子序列"></a>1.<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 2500<br>-104 &lt;= nums[i] &lt;= 104</p><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>以nums=[10,9,2,5,3,7,101,18]为例，我们采用动态规划来解决这个问题，首先dp初始值全部为1，dp[i]代表以nums[i]为结尾的递增子序列长度为dp[i]。</p><p>我们把nums[i]与前i-1个元素比较，如果<code>nums[i] &gt; nums[j]</code>就更新dp[i]，因此我们可以得到状态转移方程为：<code>dp[i] = max(dp[i], dp[j] + 1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><p>$$<br>时间复杂度：O(n^2),空间复杂度：O(n)<br>$$</p><h2 id="解法二：动态规划-二分查找"><a href="#解法二：动态规划-二分查找" class="headerlink" title="解法二：动态规划+二分查找"></a>解法二：动态规划+二分查找</h2><p>我们可以用一个数组tail，来动态保存一个递增子序列，tail在任意时刻都是保存当前最长子序列的结果，同时我们利用贪心思想，既让tail为递增子序列，有保证尽可能让后一个元素比前一个元素更接近。</p><p>我们来动态模拟一下这个过程，更方便理解：</p><p>当i=0时，由于tail初始为空，所以10进入tail，此时tail=[10]</p><p>当i=1时，由于9&lt;10，所以我们让9替换10，此时tail=[9]；</p><p>当i=2时，由于2&lt;9，所以我们让2替换9，此时tail=[2]</p><p>当i=3时，由于5&gt;2，所以让5进入tail，此时tail=[2, 5]</p><p>当i=4时，由于3&lt;5，而且3如果替换5的话依然可以保证tail递增，所以利用贪心思想，我们让3替换5，此时tail= [2, 3]；</p><p>当i=5时，由于7&gt;3，所以让7进入tail，此时tail=[2, 3, 7]</p><p>当i=6时，由于101&gt;7，所以让101进入tail，此时tail=[2, 3, 7, 101]</p><p>当i=7时，由于18&lt;101，而且18如果替换101的话依然可以保证tail递增，所以利用贪心思想，我们让18替换101，此时tail=[2, 3, 7, 101]</p><blockquote><p>通过上面的模拟我们可以得到更新tail的两个原则：</p></blockquote><p>第一：时刻保证tail是递增的序列；第二：尽可能让后一个元素与前一个元素相接近，就是如果当前元素可以比原有的tail元素接近的话，就用当前元素替换原有的元素。</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>nums[i]</td><td>10</td><td>9</td><td>2</td><td>5</td><td>3</td><td>7</td><td>101</td><td>18</td></tr><tr><td>tail</td><td>[10]</td><td>[9]</td><td>[2]</td><td>[2, 5]</td><td>[2, 3]</td><td>[2, 3, 7]</td><td>[2, 3, 7, 101]</td><td>[2, 3, 7, 18]</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># tail为空或当前num大于tail的最后一个元素</span></span><br><span class="line">                tail.append(num)</span><br><span class="line">            l, r = <span class="number">0</span>, len(tail) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 用当前的num更新tail数组，贪心思想来用num替换tail中的一个元素</span></span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tail[mid] &lt; num:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid</span><br><span class="line">            tail[l] = num</span><br><span class="line">        <span class="keyword">return</span> len(tail)</span><br></pre></td></tr></table></figure><p>$$<br>时间复杂度：O(NlogN)，遍历数组使用了 O(N)，二分查找法使用了 O(logN)<br>$$</p><p>$$<br>空间复杂度：O(N)，开辟数组的长度至多和nums长度一样长<br>$$</p><h1 id="2-334-递增的三元子序列"><a href="#2-334-递增的三元子序列" class="headerlink" title="2.334. 递增的三元子序列"></a>2.<a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 5 * 105<br>-231 &lt;= nums[i] &lt;= 231 - 1</p><p>进阶：你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？</p><h2 id="解法一：基于最长递增子序列的变形"><a href="#解法一：基于最长递增子序列的变形" class="headerlink" title="解法一：基于最长递增子序列的变形"></a>解法一：基于最长递增子序列的变形</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># tail为空或当前num大于tail的最后一个元素</span></span><br><span class="line">                tail.append(num)</span><br><span class="line">            l, r = <span class="number">0</span>, len(tail) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 用当前的num更新tail数组，贪心思想来用num替换tail中的一个元素</span></span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tail[mid] &lt; num:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid</span><br><span class="line">            tail[l] = num</span><br><span class="line">            <span class="keyword">if</span> len(tail) == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>时间复杂度与空间复杂度同上</p><h2 id="解法二：数学法（进阶）"><a href="#解法二：数学法（进阶）" class="headerlink" title="解法二：数学法（进阶）"></a>解法二：数学法（进阶）</h2><p>通过数学法，首先我们令a记录一个最小值，b记录次小值，如果在a，b之后存在一个元素比b大的话，就说明可以满足条件；<strong>a，b的初始值均为边界最大值；</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        a = (<span class="number">2</span> ** <span class="number">31</span>)</span><br><span class="line">        b = (<span class="number">2</span> ** <span class="number">31</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= a:</span><br><span class="line">                a = num</span><br><span class="line">            <span class="keyword">elif</span> num &lt;= b:</span><br><span class="line">                b = num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="3-354-俄罗斯套娃信封问题"><a href="#3-354-俄罗斯套娃信封问题" class="headerlink" title="3.354. 俄罗斯套娃信封问题"></a>3.<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[1,1],[1,1],[1,1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= envelopes.length &lt;= 5000<br>envelopes[i].length == 2<br>1 &lt;= wi, hi &lt;= 104</p><h2 id="题目预处理"><a href="#题目预处理" class="headerlink" title="题目预处理"></a>题目预处理</h2><p>因为是二维数组，一般遇到这样的题目，都需要考虑先排序，要么是按照升序排序，要么是按照降序排序，或者是升序与降序结合的方式来排序。</p><p>在这个题目中，我们采用两者结合的方法，先按照x[0]升序，在按照x[1]降序，降序的时候只要按照-x[1]升序即可；</p><h2 id="解法一：动态规划-1"><a href="#解法一：动态规划-1" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>由于已经按照上面的预处理进行排序，所以我们用动态规划的思想，就类似于<strong>最长递增子序列</strong>这个题目，第一列已经有序，所以只需要考虑第二列是否符合要求即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        n = len(envelopes)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划-二分查找-1"><a href="#解法二：动态规划-二分查找-1" class="headerlink" title="解法二：动态规划+二分查找"></a>解法二：动态规划+二分查找</h2><p>这个思路理解起来有些困难，</p><p>我们envelops=[[2, 5], [2, 3], [5, 4], [5, 3], [6, 7], [6, 4]]</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>envelops[i]</td><td>[2, 5]</td><td>[2, 3]</td><td>[5, 4]</td><td>[5, 3]</td><td>[6, 7]</td><td>[6, 4]</td></tr><tr><td>tail</td><td>5</td><td>3</td><td>3, 4</td><td>3, 4</td><td>3, 4, 7</td><td></td></tr></tbody></table><p>对于第一列是2开始的有[2, 5]和  [2, 3]，我么首先把5加入tail，然后由于3&lt;5，所以把3加入tail。</p><p>接下来对于第一列是5开始的有[5, 4]和[5, 3]，我们必须要找一个第二列比3大的才可以加入tail，最后找到了4；</p><p>然后对于第一列是6开始的有[6, 7]和 [6, 4]，同上。</p><p>根据上面的表格推理一遍就可以发现上面题目排序的方式的妙处在哪里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(envelopes)</span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            num = envelopes[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                tail.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &lt;= tail[<span class="number">-1</span>]:</span><br><span class="line">                l, r = <span class="number">0</span>, len(tail) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    mid = (l + r) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> tail[mid] &lt; num:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = mid</span><br><span class="line">                tail[l] = num</span><br><span class="line">        <span class="keyword">return</span> len(tail)</span><br></pre></td></tr></table></figure><p>针对上面的代码在二分查找这一部分进行优化，直接调用函数来实现，这样可以大大优化时间和代码量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(envelopes)</span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            num = envelopes[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                tail.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &lt;= tail[<span class="number">-1</span>]:</span><br><span class="line">                l = bisect.bisect_left(tail, num)</span><br><span class="line">                tail[l] = num</span><br><span class="line">        <span class="keyword">return</span> len(tail)</span><br></pre></td></tr></table></figure><h1 id="4-673-最长递增子序列的个数"><a href="#4-673-最长递增子序列的个数" class="headerlink" title="4.673. 最长递增子序列的个数"></a>4.<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></pre></td></tr></table></figure><p>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p><h2 id="解法一：动态规划-2"><a href="#解法一：动态规划-2" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>在第一个题目最长递增子序列的基础上，我们需要修改一下，dp的含义依然不变：以nums[i]结尾的最长子序列的长度；</p><p>新增一个cnt数组，其含义是以nums[i]结尾的最长子序列的个数；</p><p>有了长度数组dp和个数数组cnt，我们只需要每次遍历的时候比较一下max_len和max_ans就可以得到最终的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        cnt = [<span class="number">1</span>] * n</span><br><span class="line">        max_len, max_ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                        cnt[i] = cnt[j]</span><br><span class="line">                    <span class="keyword">elif</span> dp[j] + <span class="number">1</span> == dp[i]:</span><br><span class="line">                        cnt[i] += cnt[j]</span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; max_len:</span><br><span class="line">                max_len = dp[i]</span><br><span class="line">                max_ans = cnt[i]</span><br><span class="line">            <span class="keyword">elif</span> dp[i] == max_len:</span><br><span class="line">                max_ans += cnt[i]</span><br><span class="line">        <span class="keyword">return</span> max_ans</span><br></pre></td></tr></table></figure><p>上面这个可以稍微优化一下，既然cnt是以nums[i]结尾的最长子序列的个数，只要我们在nums后面增加一个2 ** 31这个数，这样我们的最长子序列一定是以最后增加的这个数为结尾，这样就不需要设置max_len来标记最长长度。在代码量上会有很大的优化空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums = nums + [<span class="number">2</span> ** <span class="number">31</span>]</span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        cnt = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                        cnt[i] = cnt[j]</span><br><span class="line">                    <span class="keyword">elif</span> dp[j] + <span class="number">1</span> == dp[i]:</span><br><span class="line">                        cnt[i] += cnt[j]</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-646-最长数对链"><a href="#5-646-最长数对链" class="headerlink" title="5.646. 最长数对链"></a>5.<a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p><p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p><p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2], [2,3], [3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：最长的数对链是 [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure><p>提示：</p><p>给出数对的个数在 [1, 1000] 范围内。</p><h2 id="解法一：动态规划-3"><a href="#解法一：动态规划-3" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span>(<span class="params">self, pairs: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        print(pairs)</span><br><span class="line">        n = len(pairs)</span><br><span class="line">        dp = [<span class="number">1</span>] * n    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划-二分"><a href="#解法二：动态规划-二分" class="headerlink" title="解法二：动态规划+二分"></a>解法二：动态规划+二分</h2><h2 id="解法三：贪心"><a href="#解法三：贪心" class="headerlink" title="解法三：贪心"></a>解法三：贪心</h2><p>这个解法稍微难理解一些，我们举个例子来看就更容易理解：</p><p>初始时：pairs = [[2,3], [2,5], [2,7], [2,10], [3,4], [6,7], [8,9]]</p><p>排序之后：[[2, 3], [3, 4], [2, 5], [2, 7], [6, 7], [8, 9], [2, 10]]</p><p>这样我们就可以发现，对于第一列是2的情况，第二列我们通过贪心原则优先选择最小的，这样可以保证后面的尽可能多；</p><p>通过上面的结果我们可以看出最后形成对链的有：[2,3], [6,7], [8,9]</p><p>因此我们按照第二列升序排序之后，然后用一个position记录上一次的结尾数字是哪个，而且这个结尾数字是尽可能小（贪心），这样只需要遍历一遍数组就可以找到所有满足要求的对链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span>(<span class="params">self, pairs: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(pairs)</span><br><span class="line">        pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        print(pairs)</span><br><span class="line">        position = pairs[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> pairs[i][<span class="number">0</span>] &gt; position:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                position = pairs[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解“最长回文子串”（中心扩展算法、马拉车算法）</title>
      <link href="2022/01/06/220107%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
      <url>2022/01/06/220107%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-5-最长回文子串"><a href="#1-5-最长回文子串" class="headerlink" title="1.5. 最长回文子串"></a>1.<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="解法一：中心扩展算法"><a href="#解法一：中心扩展算法" class="headerlink" title="解法一：中心扩展算法"></a>解法一：中心扩展算法</h2><img src="/2022/01/06/220107%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/1.jpeg" class><p>由于回文串是对称的，对于中心扩展算法来说，我们每次选择从回文串的中心向左右两侧扩展，对应位置的元素一定是相同的。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>b</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一种情况：回文串长度为奇数，对于abbba这个回文串来说，它的中心是b（2）；</p><p>第二种情况：回文串长度为偶数，对于baab这个回文串来说，它的中心就是aa(4\5);</p><p>所以我们遍历一个字符串，只需要把把当前位置作为中心，向两侧进行扩展来判断以当前位置为中心的回文串的最大长度是多少就可以了。</p><p>首先定义一个expandAroundCenter函数，来判断制定字符串以及中心的位置，判断以当前位置为中心的最长回文串；</p><p>其次，遍历所有的中心，然后把当前中心的回文串长度与最长长度比较，同时需要更新最长回文串的起始和结束为止；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span>(<span class="params">s, left, right</span>):</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> right - left - <span class="number">1</span>  </span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            len1 = expandAroundCenter(s, i, i)</span><br><span class="line">            len2 = expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">            l = max(len1, len2)</span><br><span class="line">            <span class="keyword">if</span> l &gt; end - start:</span><br><span class="line">                start = i - (l - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                end = i + l // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>时间复杂度：$O（n²）$。两层循环，每层循环都是遍历每个字符。</p><p>空间复杂度：$O（1）$。</p><h2 id="解法二：马拉车算法"><a href="#解法二：马拉车算法" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>具体的讲解请参考这位博主的整理<a href="https://zhuanlan.zhihu.com/p/70532099">https://zhuanlan.zhihu.com/p/70532099</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">            ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">            ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        ret = preProcess(s)</span><br><span class="line">        n = len(ret)</span><br><span class="line">        P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">        C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">            <span class="keyword">if</span> R &gt; i:</span><br><span class="line">                P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">            <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">                P[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        <span class="comment"># 找到最长回文串的位置</span></span><br><span class="line">        maxLen = <span class="number">0</span> </span><br><span class="line">        cnterIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> P[i] &gt; maxLen:</span><br><span class="line">                maxLen = P[i]</span><br><span class="line">                cnterIndex = i</span><br><span class="line">        start = (cnterIndex - maxLen) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+maxLen]</span><br></pre></td></tr></table></figure><p>下面这个是马拉车算法的一般形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">    ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">    ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manacher</span>(<span class="params">s</span>):</span></span><br><span class="line">    ret = preProcess(s)</span><br><span class="line">    n = len(ret)</span><br><span class="line">    P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">    C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">        i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">        <span class="keyword">if</span> R &gt; i:</span><br><span class="line">            P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">        <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">            P[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">            C = i</span><br><span class="line">            R = i + P[i]</span><br><span class="line"> <span class="comment">#     return P</span></span><br><span class="line">  maxLen = <span class="number">0</span> </span><br><span class="line">    cnterIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> P[i] &gt; maxLen:</span><br><span class="line">        maxLen = P[i]</span><br><span class="line">        cnterIndex = i</span><br><span class="line">    start = (cnterIndex - maxLen) // <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> s[start:start+maxLen]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://segmentfault.com/a/1190000008484167">https://segmentfault.com/a/1190000008484167</a></p><p><a href="https://zhuanlan.zhihu.com/p/70532099">https://zhuanlan.zhihu.com/p/70532099</a></p><p><a href="https://blog.crimx.com/2017/07/06/manachers-algorithm/">https://blog.crimx.com/2017/07/06/manachers-algorithm/</a></p><h1 id="2-647-回文子串"><a href="#2-647-回文子串" class="headerlink" title="2.647. 回文子串"></a>2.<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 由小写英文字母组成</p><h2 id="解法一：中心扩展法"><a href="#解法一：中心扩展法" class="headerlink" title="解法一：中心扩展法"></a>解法一：中心扩展法</h2><p>这里有一个小技巧，我们把n扩大到2 * n - 1，同时令l, r = i // 2, i // 2 + i % 2就可以使得所有的情况都得到遍历。</p><p>以s = “abc”为例：</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>l</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>r</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> * n - <span class="number">1</span>):</span><br><span class="line">            l, r = i // <span class="number">2</span>, i // <span class="number">2</span> + i % <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="解法二：马拉车算法-1"><a href="#解法二：马拉车算法-1" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>这一题依然可以用马拉车算法，只是最后求数量的时候需要做一下特殊的处理，对于P，如果P[i] == 1说明有一个长度为1的回文串，如果P[i] &gt; 1说明回文串长度大于1的有P[i] % 2个，例如deed，此时长度为4，回文串长度大于1的个数有2个分别是deed和ee。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">            ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">            ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        ret = preProcess(s)</span><br><span class="line">        n = len(ret)</span><br><span class="line">        P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">        C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">            <span class="keyword">if</span> R &gt; i:</span><br><span class="line">                P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">            <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">                P[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> P:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                ans += num // <span class="number">2</span></span><br><span class="line">        ans += len(s)</span><br><span class="line">        <span class="keyword">return</span> ans        </span><br></pre></td></tr></table></figure><h1 id="4-1143-最长公共子序列"><a href="#4-1143-最长公共子序列" class="headerlink" title="4.1143. 最长公共子序列"></a>4.<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>dp[i] [j]代表text1前i个元素，text2前j个元素的公共子序列长度为多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: str, text2: str</span>) -&gt; int:</span></span><br><span class="line">        m, n = len(text1), len(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] </span><br></pre></td></tr></table></figure><h1 id="3-516-最长回文子序列"><a href="#3-516-最长回文子序列" class="headerlink" title="3.516. 最长回文子序列"></a>3.<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><p>这个部分可以参考一下这个链接 有很详细的关于动态规划的讲解，以及如何优化问题。</p><p><a href="https://sanduohou.github.io/2021/12/31/211231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">动态规划之背包问题</a></p><p>首先是问题转换，把求回文子序列转换为求最长公共子序列，对于s，我们用r表示s的反转，由于是最长回文子序列，所以s的最长回文子序列一定等于r的最长回文子序列。</p><h2 id="解法一：动态规划（转换为最长公共子序列）"><a href="#解法一：动态规划（转换为最长公共子序列）" class="headerlink" title="解法一：动态规划（转换为最长公共子序列）"></a>解法一：动态规划（转换为最长公共子序列）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        r = s[::<span class="number">-1</span>]</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == r[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划（优化空间，滚动数组）"><a href="#解法二：动态规划（优化空间，滚动数组）" class="headerlink" title="解法二：动态规划（优化空间，滚动数组）"></a>解法二：动态规划（优化空间，滚动数组）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        r = s[::<span class="number">-1</span>]</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == r[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># if s[i-1] == s[n-j]:这样也可以 就不需要复制s了</span></span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j], dp[i&amp;<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp[<span class="number">0</span>][<span class="number">-1</span>], dp[<span class="number">1</span>][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 滚动数组优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = dp[(i + <span class="number">1</span>)&amp;<span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = max(dp[(i + <span class="number">1</span>)&amp;<span class="number">1</span>][j], dp[i&amp;<span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp[<span class="number">0</span>][<span class="number">-1</span>], dp[<span class="number">1</span>][<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 经典算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二/N叉树深度问题</title>
      <link href="2022/01/05/220105%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>2022/01/05/220105%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1.知识讲解"></a>1.知识讲解</h1><h1 id="2-104-二叉树的最大深度"><a href="#2-104-二叉树的最大深度" class="headerlink" title="2.104. 二叉树的最大深度"></a>2.104.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"> 二叉树的最大深度</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过递归获得左右子树的深度，然后取两者中最大的，再加上当前节点1，就会得到结果；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftMax = self.maxDepth(root.left)</span><br><span class="line">        rightMax = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        depth = max(leftMax, rightMax) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><h1 id="3-559-N-叉树的最大深度"><a href="#3-559-N-叉树的最大深度" class="headerlink" title="3.559. N 叉树的最大深度"></a>3.<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示：</p><p>树的深度不会超过 1000 。<br>树的节点数目位于 [0, 104] 之间。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>N叉树的在递归的时候需要把每个节点都遍历一遍，可以参考上面二叉树的思路；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">            ans = max(ans, self.maxDepth(chl))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="4-111-二叉树的最小深度"><a href="#4-111-二叉树的最小深度" class="headerlink" title="4.111. 二叉树的最小深度"></a>4.<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点数的范围在 [0, 105] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>分三种情况考虑：</p><p>第一种情况：如果左右孩子均为空，说明是叶子结点，返回为1；</p><p>第二种情况：如果左右孩子只有一个为空，则返回两者中最小的一个；</p><p>第三种情况：边界问题，如果当前节点为空，则返回0；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left = self.minDepth(root.left)</span><br><span class="line">        right = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> left + right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        ans = <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            ans = min(self.minDepth(root.left), ans)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            ans = min(self.minDepth(root.right), ans)</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之多重背包问题</title>
      <link href="2022/01/04/220104%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
      <url>2022/01/04/220104%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1.知识讲解"></a>1.知识讲解</h1><blockquote><p>01、完全、多重背包的异同</p></blockquote><table><thead><tr><th></th><th>01背包</th><th>完全背包</th><th>多重背包</th><th></th></tr></thead><tbody><tr><td>目的</td><td>求最大价值</td><td>求最大价值</td><td>求最大价值</td><td></td></tr><tr><td><strong>每件物品数量</strong></td><td>一件</td><td>无限件</td><td>有限件</td><td></td></tr></tbody></table><p>01背包是后两种背包问题的基础，唯一的变化就是每件物品的数量是不同的。而完全背包与多重背包存在更大的相似性，唯一的改变就是<strong>每件物品的数量是有限件，相当于对完全背包中的k进行了限定。</strong></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>其中N为物品种类数，V为背包体积，v为每个物品占用的体检，w为物品的价值，s为每个物品的数量；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 4, V &#x3D; 10, v &#x3D; [1,2,3,4], w &#x3D; [1,4,5,10], s &#x3D; [1, 2, 5, 2, 3]</span><br><span class="line">输出: 24</span><br><span class="line">解释: 选一件物品2，再选两件物品 4，可使价值最大。</span><br></pre></td></tr></table></figure><blockquote><p>定义状态</p></blockquote><p>前n个物品的在体积V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题。</p><p><strong>dp[i] [j]定义 为前i个物品放入到体积为j的背包中可以获得的最大价值。</strong></p><blockquote><p>状态方程</p></blockquote><p>由于每个物品i可以被选择多次，因此对于dp[i] [j]来说，它的可能取值为：</p><ul><li><p>选择0件物品i的价值，即dp[i-1] [j]</p></li><li><p>选择1件物品i的价值，即dp[i-1] [j - 1 * v[i]] + 1 * w[i]</p></li><li><p>选择2件物品i的价值，即dp[i-1] [j - 2 * v[i]] + 2 * w[i]</p><p>……</p></li><li><p>选择s[i]件物品i的价值，即dp[i-1] [j - s[i]* v[i]] + s[i] * w[i]</p></li></ul><p>状态转移方程为所有可能取值中的最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - k * v[i]] + k * w[i]), 0 &lt; k * v[j] &lt;&#x3D; j and k &lt;&#x3D; s[i]</span><br></pre></td></tr></table></figure><blockquote><p>边界</p></blockquote><p>先考虑dp[0] [j]的情况，对于容量为j的背包，把v[0]放进去，最大的价值是多少 ，需要满足条件：*<em>0 &lt; k * v[0] &lt;= j and k &lt;= s[0]。*</em></p><h2 id="解法一：N为数组"><a href="#解法一：N为数组" class="headerlink" title="解法一：N为数组"></a>解法一：N为数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiplePack</span>(<span class="params">N, V, v, w, s</span>):</span></span><br><span class="line">    <span class="comment"># N维数组</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="comment"># 初始状态， 前0件的最大价值为j//v[0]（背包可以放）和s[0]之间的最小者</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = min(j // v[<span class="number">0</span>], s[<span class="number">0</span>]) * w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= k * v[i] <span class="keyword">and</span> k &lt;= s[i]:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-k*v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：二维数组"><a href="#解法二：二维数组" class="headerlink" title="解法二：二维数组"></a>解法二：二维数组</h2><p>采用滚动数组的方法，我们把N为数组降维到二维数组；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiplePack</span>(<span class="params">N, V, v, w, s</span>):</span></span><br><span class="line">    <span class="comment"># 滚动数组，优化为二维数组</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="comment"># 初始状态， 前0件的最大价值为j//v[0]（背包可以放）和s[0]之间的最小者</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = min(j // v[<span class="number">0</span>], s[<span class="number">0</span>]) * w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= k * v[i] <span class="keyword">and</span> k &lt;= s[i]:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[i &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-k*v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法三：一维数组"><a href="#解法三：一维数组" class="headerlink" title="解法三：一维数组"></a>解法三：一维数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiplePack</span>(<span class="params">N, V, v, w, s</span>):</span></span><br><span class="line">    <span class="comment"># 优化为一维数组</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= k * v[i] <span class="keyword">and</span> k &lt;= s[i]:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-k*v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="2-474-一和零"><a href="#2-474-一和零" class="headerlink" title="2.474. 一和零"></a>2.<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= strs.length &lt;= 600<br>1 &lt;= strs[i].length &lt;= 100<br>strs[i] 仅由 ‘0’ 和 ‘1’ 组成<br>1 &lt;= m, n &lt;= 100</p><h2 id="解法一：dp-N-m-1-n-1-三维度数组"><a href="#解法一：dp-N-m-1-n-1-三维度数组" class="headerlink" title="解法一：dp[N] [m+1] [n+1]三维度数组"></a>解法一：dp[N] [m+1] [n+1]三维度数组</h2><p>因为需要考虑0和1的数量，所以之前的二维数组不能够解决这个问题了，所以需要使用三维数组。dp[k] [i] [j]代表，前k个元素在i个0和j个1的情况下，最大价值是多少。</p><p>每个元素的成本为（0和1的个数），价值为1；</p><blockquote><p>状态转移方程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k][i][j] &#x3D; max(dp[k-1][i][j], dp[k-1][i-zero][j-one]) 其中zero、one代表当前k的0和1的个数</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[str], m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 首先保存0 1 的个数</span></span><br><span class="line">        cnt = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            cnt.append([s.count(<span class="string">&#x27;0&#x27;</span>), s.count(<span class="string">&#x27;1&#x27;</span>)])</span><br><span class="line">        N = len(strs)</span><br><span class="line">        <span class="comment"># 创建dp数组三维，前k个元素在i和j的情况下有多少种子集</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= cnt[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">and</span> j &gt;= cnt[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            zero, one = cnt[k][<span class="number">0</span>], cnt[k][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                    a = dp[k<span class="number">-1</span>][i][j]</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= zero <span class="keyword">and</span> j &gt;= one:</span><br><span class="line">                        b = dp[k<span class="number">-1</span>][i-zero][j-one] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        b = <span class="number">0</span></span><br><span class="line">                    dp[k][i][j] = max(a, b)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：滚动数组，优化空间"><a href="#解法二：滚动数组，优化空间" class="headerlink" title="解法二：滚动数组，优化空间"></a>解法二：滚动数组，优化空间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[str], m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 首先保存0 1 的个数</span></span><br><span class="line">        cnt = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            cnt.append([s.count(<span class="string">&#x27;0&#x27;</span>), s.count(<span class="string">&#x27;1&#x27;</span>)])</span><br><span class="line">        N = len(strs)</span><br><span class="line">        <span class="comment"># 创建dp数组三维，前k个元素在i和j的情况下有多少种子集</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= cnt[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">and</span> j &gt;= cnt[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            zero, one = cnt[k][<span class="number">0</span>], cnt[k][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                    a = dp[(k<span class="number">-1</span>) &amp; <span class="number">1</span>][i][j]</span><br><span class="line">                    b = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt;= zero <span class="keyword">and</span> j &gt;= one:</span><br><span class="line">                        b = dp[(k<span class="number">-1</span>) &amp; <span class="number">1</span>][i-zero][j-one] + <span class="number">1</span></span><br><span class="line">                    dp[k &amp; <span class="number">1</span>][i][j] = max(a, b)</span><br><span class="line">        <span class="keyword">return</span> dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法三：转化为01背包问题"><a href="#解法三：转化为01背包问题" class="headerlink" title="解法三：转化为01背包问题"></a>解法三：转化为01背包问题</h2><blockquote><p>本题的状态转移方程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> dp[k][i][j] &#x3D; max(dp[k-1][i][j], dp[k-1][i-zero][j-one])</span><br><span class="line">#通过这个可以看出dp[k][i][j]与其上方元素以及上方左侧元素有关</span><br><span class="line"></span><br><span class="line">dp[i][j] &#x3D; max(dp[i][j], dp[i-zero][j-one]) </span><br></pre></td></tr></table></figure><blockquote><p>01背包的状态转移方程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1] [j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><p>通过对比上面两个状态转移方程，可以看出两种具有很多共同的地方，两者当前的值都是由当前元素上一行对应的值以及上一行左边的值决定的，所以我们就可以简化，降低维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[str], m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 首先保存0 1 的个数</span></span><br><span class="line">        cnt = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            cnt.append([s.count(<span class="string">&#x27;0&#x27;</span>), s.count(<span class="string">&#x27;1&#x27;</span>)])</span><br><span class="line">        N = len(strs)</span><br><span class="line">        <span class="comment"># 创建dp数组三维，前k个元素在i和j的情况下有多少种</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">            zero, one = cnt[k][<span class="number">0</span>], cnt[k][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m, zero<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n, one<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                     dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-879-盈利计划"><a href="#3-879-盈利计划" class="headerlink" title="3.879. 盈利计划"></a>3.<a href="https://leetcode-cn.com/problems/profitable-schemes/">879. 盈利计划</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p><p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。</p><p>有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, minProfit &#x3D; 3, group &#x3D; [2,2], profit &#x3D; [2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。</span><br><span class="line">总的来说，有两种计划。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10, minProfit &#x3D; 5, group &#x3D; [2,3,5], profit &#x3D; [6,7,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。</span><br><span class="line">有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= n &lt;= 100<br>0 &lt;= minProfit &lt;= 100<br>1 &lt;= group.length &lt;= 100<br>1 &lt;= group[i] &lt;= 100<br>profit.length == group.length<br>0 &lt;= profit[i] &lt;= 100</p><h2 id="解法一：多维数组"><a href="#解法一：多维数组" class="headerlink" title="解法一：多维数组"></a>解法一：多维数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span>(<span class="params">self, n: int, minProfit: int, group: List[int], profit: List[int]</span>) -&gt; int:</span></span><br><span class="line">        m = len(group)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># N为个数，n为背包大小 minProfit为</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (minProfit + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>) ]<span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当利润为0时</span></span><br><span class="line">            dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i的下标从1开始</span></span><br><span class="line">            a, b = group[i<span class="number">-1</span>], profit[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(minProfit+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k]</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= a:</span><br><span class="line">                        dp[i][j][k] += dp[i<span class="number">-1</span>][j-a][max(<span class="number">0</span>, k-b)]</span><br><span class="line">                        <span class="keyword">if</span> dp[i][j][k] &gt;= mod:</span><br><span class="line">                            dp[i][j][k] -= mod</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：优化空间，滚动数组"><a href="#解法二：优化空间，滚动数组" class="headerlink" title="解法二：优化空间，滚动数组"></a>解法二：优化空间，滚动数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span>(<span class="params">self, n: int, minProfit: int, group: List[int], profit: List[int]</span>) -&gt; int:</span></span><br><span class="line">        m = len(group)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># N为个数，n为背包大小 minProfit为</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (minProfit + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>) ]<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当利润为0时</span></span><br><span class="line">            dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i的下标从1开始</span></span><br><span class="line">            a, b = group[i<span class="number">-1</span>], profit[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(minProfit+<span class="number">1</span>):</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j][k] = dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][k]</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= a:</span><br><span class="line">                        dp[i&amp;<span class="number">1</span>][j][k] += dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-a][max(<span class="number">0</span>, k-b)]</span><br><span class="line">                        <span class="keyword">if</span> dp[i&amp;<span class="number">1</span>][j][k] &gt;= mod:</span><br><span class="line">                            dp[i&amp;<span class="number">1</span>][j][k] -= mod</span><br><span class="line">        <span class="keyword">return</span> dp[m &amp; <span class="number">1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法三：降低维度"><a href="#解法三：降低维度" class="headerlink" title="解法三：降低维度"></a>解法三：降低维度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span>(<span class="params">self, n: int, minProfit: int, group: List[int], profit: List[int]</span>) -&gt; int:</span></span><br><span class="line">        m = len(group)</span><br><span class="line">        MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># N为个数，n为背包大小 minProfit为</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="number">1</span> + minProfit) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span> + n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="comment"># i的下标从1开始</span></span><br><span class="line">            a, b = group[i], profit[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n, a<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(minProfit, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    dp[j][k] += dp[j-a][max(<span class="number">0</span>, k-b)] % MOD</span><br><span class="line"></span><br><span class="line">        ans = sum(dp[i][minProfit] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>+n))</span><br><span class="line">        <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之完全背包问题</title>
      <link href="2022/01/02/220103CompletePack/"/>
      <url>2022/01/02/220103CompletePack/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1.知识讲解"></a>1.知识讲解</h1><blockquote><p>回顾一下01背包</p></blockquote><p>有N种物品和一个容量为V的背包，每种物品只有一种。第i件物品的体积是v[i] ，价值是w[i]。</p><blockquote><p>完全背包</p></blockquote><p>有N种物品和一个容量为V的背包，每种物品都有无限多种。第i件物品的体积是v[i] ，价值是w[i]。</p><blockquote><p>两者的区别</p></blockquote><p><strong><u>完全背包</u>**是在</strong><u>01背包</u><strong>的基础上增加了一个条件：</strong>每种物品可以取无限多次（在背包容量满足的条件下）**。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 4, V &#x3D; 10, v &#x3D; [1,2,3,4], w &#x3D; [1,4,5,10]</span><br><span class="line">输出: 24</span><br><span class="line">解释: 选一件物品2，再选两件物品 4，可使价值最大。</span><br></pre></td></tr></table></figure><h2 id="解法一：定义数组dp-N-V-1"><a href="#解法一：定义数组dp-N-V-1" class="headerlink" title="解法一：定义数组dp[N] [V+1]"></a>解法一：定义数组dp[N] [V+1]</h2><blockquote><p>定义状态</p></blockquote><p>前n个物品的在体积V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题。</p><p><strong>dp[i] [j]定义 为前i个物品放入到体积为j的背包中可以获得的最大价值。</strong></p><blockquote><p>状态方程</p></blockquote><p>由于每个物品i可以被选择多次，因此对于dp[i] [j]来说，它的可能取值为：</p><ul><li><p>选择0件物品i的价值，即dp[i-1] [j]</p></li><li><p>选择1件物品i的价值，即dp[i-1] [j - 1 * v[i]] + 1 * w[i]</p></li><li><p>选择2件物品i的价值，即dp[i-1] [j - 2 * v[i]] + 2 * w[i]</p><p>……</p></li><li><p>选择k件物品i的价值，即dp[i-1] [j - k * v[i]] + k * w[i]</p></li></ul><p>状态转移方程为所有可能取值中的最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - k * v[i]] + k * w[i]), 0 &lt; k * v[j] &lt;&#x3D; j</span><br></pre></td></tr></table></figure><blockquote><p>边界</p></blockquote><p>先考虑dp[0] [j]的情况，对于容量为j的背包，把v[0]放进去，最大的价值是多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">completepack</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j // v[<span class="number">0</span>] * w[<span class="number">0</span>]</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= v[i] * k:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：定义数组dp-2-V-1-，采用滚动数组"><a href="#解法二：定义数组dp-2-V-1-，采用滚动数组" class="headerlink" title="解法二：定义数组dp[2] [V+1]，采用滚动数组"></a>解法二：定义数组dp[2] [V+1]，采用滚动数组</h2><p>根据状态方程我们可以知道，dp[i] [j]的结果只与dp[i-1]相关，因此我们可以参考01背包的方法来优化空间，只需要用一个二维的数组即可解决问题。dp[0]和dp[1]轮流交替使用，例如i=1时，dp[1]根据dp[0]的结果获得；i=2时，dp[2]可以转换为dp[0]， 然后再根据dp[1]的结果获得；</p><p>需要做的就是判断当前i是奇数还是偶数即可，一种方法是用i % 2 == 0?来判断；一种方法是让i&amp;1进行与运算判断；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">completepack</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j // v[<span class="number">0</span>] * w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= v[i] * k:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[i &amp; <span class="number">1</span>][j], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：定义数组-V-1-、一维空间"><a href="#解法二：定义数组-V-1-、一维空间" class="headerlink" title="解法二：定义数组[V+1]、一维空间"></a>解法二：定义数组[V+1]、一维空间</h2><blockquote><p>01背包：优化为一维空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - v[i]] + w[i])</span><br></pre></td></tr></table></figure><p>dp[i] [j]的结果只与dp[i-1] [j],  dp[i-1] [j - v[i]]这两个元素有关，因此我们可以把从0到V遍历求解改为从V到0遍历求解，这样就可以每次先把上一次的dp[j-v[i]]保存下来，然后当前再遍历的时候比较一下结果是否发生改变，取最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><blockquote><p>完全背包：优化为一维度空间</p></blockquote><p>对于完全背包可以参照01背包进行类似推导，详情参考下图，（图源：宫水三叶的刷题笔记）</p><img src="/2022/01/02/220103CompletePack/1.png" class><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 原始状态转移方程</span><br><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - k * v[i]] + k * w[i]), 0 &lt; k * v[j] &lt;&#x3D; j</span><br><span class="line"># 第一次优化</span><br><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - v[i]] + w[i])</span><br><span class="line"># 一维优化</span><br><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">completepack</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - v[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-v[i]] + w[i])</span><br><span class="line">        print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="2-279-完全平方数"><a href="#2-279-完全平方数" class="headerlink" title="2.279. 完全平方数"></a>2.<a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 &#x3D; 4 + 9</span><br></pre></td></tr></table></figure><h2 id="思路（以示例1为例）"><a href="#思路（以示例1为例）" class="headerlink" title="思路（以示例1为例）"></a>思路（以示例1为例）</h2><p>这是一个典型的完全背包问题，根据题意我们可以把问题转换重新描述一下：</p><p><strong><u>有三种物品N=3，体积为V=12，物品体积v=[1, 4, 9]，由于是求最小可能的组合数量，因此w=[1,1,1]，每个物品选择一次价值为1。</u></strong></p><p><strong>定义数组</strong>：dp = [100000] * (n + 1)，这里是求最小的组合数量，所以dp的初始值设置大一点（也可以设置为无穷大），<strong>dp[j]含义</strong>代表当体积为j时组合的数量为dp[j]。</p><p><strong>定义状态方程</strong>：dp[j] = min(dp[j], dp[j-v[i]] + w[i])，因为w[i] = 1,所以这里可以直接写为1，也可以写w[i]，由于是求最小值，所以用min而不是max。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [n + <span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 由于v需要我们自己生成，所以用循环判断平方即可</span></span><br><span class="line">        <span class="keyword">while</span> j * j &lt;= n:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= j * j:</span><br><span class="line">                    dp[i] = min(dp[i], dp[i-j*j] + <span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">       </span><br></pre></td></tr></table></figure><p>也可以用下面这种解法遍历，两种遍历的结果一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [n + <span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                dp[i] = min(dp[i], dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-322-零钱兑换"><a href="#3-322-零钱兑换" class="headerlink" title="3.322. 零钱兑换"></a>3.<a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个是比较典型的完全背包问题，但是需要注意的是，因为最终并不一定能够是的coins中的钱可以成功兑换为amount，例如coins = [2], amount = 3，所以我们需要加入一个value数组，其中value[j]=j的时候说明可以coins中的钱可以兑换为总金额为j的钱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[int], amount: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        value = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i] <span class="keyword">and</span> value[j-coins[i]] + coins[i] == j:</span><br><span class="line">                    dp[j] = min(dp[j], dp[j-coins[i]] + <span class="number">1</span>)</span><br><span class="line">                    value[j] = j</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> value[<span class="number">-1</span>] == amount <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="优化时空复杂度"><a href="#优化时空复杂度" class="headerlink" title="优化时空复杂度"></a>优化时空复杂度</h2><p>为了能够降低时空复杂度，我们可以考虑不使用value数组，而是根据dp数组判断。</p><p>dp数组初始值定义为无穷大∞，因为我们要求的是最小值，所以要定义为无穷大；同样如果题目求的是最大值，我们就可以直接定义为0。</p><p>为了判断最终dp[amount]这个是否能够通过coins凑齐，只要判断dp[amount]的值是否发生变化，只要不再是float(‘inf’)就说明发生了变化，可以凑齐；否则就是不能凑齐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[int], amount: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [float(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] = min(dp[j], dp[j-coins[i]] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != float(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="4-518-零钱兑换-II"><a href="#4-518-零钱兑换-II" class="headerlink" title="4.518. 零钱兑换 II"></a>4.<a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 10, coins &#x3D; [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先，定义dp[j] 代表能够构成金额j的方法有dp[j]种；</p><p>接着，定义边界，dp[0] = 1构成金额0的有一种；</p><p>接着，定义状态方程，dp[j] += dp[j-coins[i]] 这里我们不用管dp[j-coins[i]]是否为0，如果dp[j-coins[i]]不为0，说明可以在dp[j-coins[i]]的基础上加coins[i]构成dp[j]；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: int, coins: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j-coins[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-1449-数位成本和为目标值的最大数字"><a href="#5-1449-数位成本和为目标值的最大数字" class="headerlink" title="5.1449. 数位成本和为目标值的最大数字"></a>5.<a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/">1449. 数位成本和为目标值的最大数字</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：</p><p>给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。<br>总成本必须恰好等于 target 。<br>添加的数位中没有数字 0 。<br>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [4,3,2,5,6,7,2,5,5], target &#x3D; 9</span><br><span class="line">输出：&quot;7772&quot;</span><br><span class="line">解释：添加数位 &#39;7&#39; 的成本为 2 ，添加数位 &#39;2&#39; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 &#x3D; 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  1  -&gt;   4</span><br><span class="line">  2  -&gt;   3</span><br><span class="line">  3  -&gt;   2</span><br><span class="line">  4  -&gt;   5</span><br><span class="line">  5  -&gt;   6</span><br><span class="line">  6  -&gt;   7</span><br><span class="line">  7  -&gt;   2</span><br><span class="line">  8  -&gt;   5</span><br><span class="line">  9  -&gt;   5</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [7,6,5,5,5,6,8,7,8], target &#x3D; 12</span><br><span class="line">输出：&quot;85&quot;</span><br><span class="line">解释：添加数位 &#39;8&#39; 的成本是 7 ，添加数位 &#39;5&#39; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [2,4,6,2,4,6,4,4,4], target &#x3D; 5</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [6,10,15,40,40,40,40,40,40], target &#x3D; 47</span><br><span class="line">输出：&quot;32211&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p>cost.length == 9<br>1 &lt;= cost[i] &lt;= 5000<br>1 &lt;= target &lt;= 5000</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这一题就是典型的完全背包问题，首先我们进行问题转换：</p><p>总共有9个物体，每个物体占用的体积是cost[i]，背包大小为target，每个物体的价值为i，最后用所有的i来组成的数字最大。</p><p>我们直接写一维数组，每次数组中保存的是前i个数字中在背包大小为j的情况下能组成的最大数字。由于遍历是从1-9，但是组成数字的时候我们要写成：**tmp = str(i) + dp[j - cost[i]]**，这样的意思是后面加入的数字比较大，作为一个数的高位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, cost: List[int], target: int</span>) -&gt; str:</span></span><br><span class="line">        cost = [<span class="number">0</span>] + cost</span><br><span class="line">        dp = [<span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cost[i], target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j - cost[i]] != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    tmp = str(i) + dp[j - cost[i]]</span><br><span class="line">                    dp[j] = self.compare(dp[j], tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self, a: str, b: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(a) == len(b):    </span><br><span class="line">            <span class="keyword">return</span> max(a, b)</span><br><span class="line">        <span class="keyword">elif</span> len(a) &gt; len(b):   </span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:                   </span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247486107&amp;idx=1&amp;sn=e5fa523008fc5588737b7ed801caf4c3&amp;chksm=fd9ca184caeb28926959c0987208a3932ed9c965267ed366b5b82a6fc16d42f1ff40c29db5f1&amp;token=990510480&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247486107&amp;idx=1&amp;sn=e5fa523008fc5588737b7ed801caf4c3&amp;chksm=fd9ca184caeb28926959c0987208a3932ed9c965267ed366b5b82a6fc16d42f1ff40c29db5f1&amp;token=990510480&amp;lang=zh_CN#rd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode周赛1月2日</title>
      <link href="2022/01/02/220102%E5%91%A8%E8%B5%9B/"/>
      <url>2022/01/02/220102%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一题：5967-检查是否所有-A-都在-B-之前"><a href="#第一题：5967-检查是否所有-A-都在-B-之前" class="headerlink" title="第一题：5967. 检查是否所有 A 都在 B 之前"></a>第一题：<a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">5967. 检查是否所有 A 都在 B 之前</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>仅</strong> 由字符 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 组成的字符串 <code>s</code> 。如果字符串中 <strong>每个</strong> <code>&#39;a&#39;</code> 都出现在 <strong>每个</strong> <code>&#39;b&#39;</code> 之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaabbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">&#39;a&#39; 位于下标 0、1 和 2 ；而 &#39;b&#39; 位于下标 3、4 和 5 。</span><br><span class="line">因此，每个 &#39;a&#39; 都出现在每个 &#39;b&#39; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abab&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">存在一个 &#39;a&#39; 位于下标 2 ，而一个 &#39;b&#39; 位于下标 1 。</span><br><span class="line">因此，不能满足每个 &#39;a&#39; 都出现在每个 &#39;b&#39; 之前，所以返回 false 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">不存在 &#39;a&#39; ，因此可以视作每个 &#39;a&#39; 都出现在每个 &#39;b&#39; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code> 为 <code>&#39;a&#39;</code> 或 <code>&#39;b&#39;</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设置一个flag，初始为False，如果遇到b则为True，只要判断再次遇到a就直接返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkString</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="第二题：5968-银行中的激光束数量"><a href="#第二题：5968-银行中的激光束数量" class="headerlink" title="第二题：5968. 银行中的激光束数量"></a>第二题：<a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">5968. 银行中的激光束数量</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 ‘0’ 和若干 ‘1’ 组成。’0’ 表示单元格是空的，而 ‘1’ 表示单元格有一个安全设备。</p><p>对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：</p><p>两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 &lt; r2 。<br>满足 r1 &lt; i &lt; r2 的 所有 行 i ，都 没有安全设备 。<br>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p><p>返回银行中激光束的总数量。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank &#x3D; [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]</span><br><span class="line">输出：8</span><br><span class="line">解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank &#x3D; [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在两个位于不同行的设备</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>m == bank.length<br>n == bank[i].length<br>1 &lt;= m, n &lt;= 500</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们先把每一行bank[i]中的1统计出来放到一个result数组，例如示例 1中统计之后的result=[3,0,2,1]。这样我们只要遍历这个数组即可：3 * 2 + 2 * 1 = 8；令start为result[0]，然后找到bank[i]不为0的时候就可以找到一组激光，更新start为bank[i]直到遍历结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBeams</span>(<span class="params">self, bank: List[str]</span>) -&gt; int:</span></span><br><span class="line">        m, n = len(bank), len(bank[<span class="number">0</span>])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> bank[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">            result.append(res)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        start = result[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> start != <span class="number">0</span> <span class="keyword">and</span> result[i] != <span class="number">0</span>:</span><br><span class="line">                ans += start * result[i]</span><br><span class="line">                start = result[i]</span><br><span class="line">            <span class="keyword">elif</span> start == <span class="number">0</span> <span class="keyword">and</span> result[i] != <span class="number">0</span>:</span><br><span class="line">                start = result[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="第三题：5969-摧毁小行星"><a href="#第三题：5969-摧毁小行星" class="headerlink" title="第三题：5969. 摧毁小行星"></a>第三题：<a href="https://leetcode-cn.com/problems/destroying-asteroids/">5969. 摧毁小行星</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。</p><p>你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。</p><p>如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：mass &#x3D; 10, asteroids &#x3D; [3,9,19,5,21]</span><br><span class="line">输出：true</span><br><span class="line">解释：一种安排小行星的方式为 [9,19,5,3,21] ：</span><br><span class="line"></span><br><span class="line">- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 &#x3D; 19</span><br><span class="line">- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 &#x3D; 38</span><br><span class="line">- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 &#x3D; 43</span><br><span class="line">- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 &#x3D; 46</span><br><span class="line">- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 &#x3D; 67</span><br><span class="line">  所有小行星都被摧毁。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mass &#x3D; 5, asteroids &#x3D; [4,9,23,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。</span><br><span class="line">行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 &#x3D; 22 。</span><br><span class="line">它比 23 小，所以无法摧毁最后一颗小行星。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= mass &lt;= 105<br>1 &lt;= asteroids.length &lt;= 105<br>1 &lt;= asteroids[i] &lt;= 105</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>把数组排序</p><p>首先判断一下不能够将所有小行星摧毁的条件：mass不能比最小的小行星小；行星合并除了最大小行星之外的小行星之后的质量不能够比最大小行星小，即2 * asteroids[-1] &gt; sum(asteroids) + mass；</p><p>其次，我们只需要遍历数组即可，每次遇到一个小星星，如果符合要求就摧毁它，并获得它的质量，否则就反悔False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asteroidsDestroyed</span>(<span class="params">self, mass: int, asteroids: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        asteroids.sort()</span><br><span class="line">        <span class="keyword">if</span> mass &lt; asteroids[<span class="number">0</span>] <span class="keyword">or</span> <span class="number">2</span> * asteroids[<span class="number">-1</span>] &gt; sum(asteroids) + mass:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">            <span class="keyword">if</span> mass &gt;= asteroids[i]:</span><br><span class="line">                mass += asteroids[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="第四题：5970-参加会议的最多员工数"><a href="#第四题：5970-参加会议的最多员工数" class="headerlink" title="第四题：5970. 参加会议的最多员工数"></a>第四题：<a href="https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/">5970. 参加会议的最多员工数</a></h1><p>这一题不会做，还需要继续加强，做出来三个题的速度大概在25min，由于最后一个题，条件少加一个等于号，导致提交判错加时一次，争取下次可以获得更好的成绩。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之01背包问题</title>
      <link href="2021/12/31/211231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/12/31/211231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-01背包dp-N-V-1-（第一讲）"><a href="#1-01背包dp-N-V-1-（第一讲）" class="headerlink" title="1.01背包dp[N] [V+1]（第一讲）"></a>1.01背包dp[N] [V+1]（第一讲）</h1><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的体积是 v[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大，求出最大总价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 3, V &#x3D; 5, v &#x3D; [4,2,3], w &#x3D; [4,2,3]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。</span><br></pre></td></tr></table></figure><p>考虑上面的这个输入，我们用表格来思考一下，我们考虑放入前i件物品获得的最大价值是多少</p><table><thead><tr><th>i\V</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4</td><td>4</td></tr><tr><td>2</td><td>0</td><td>0</td><td>2</td><td>2</td><td>4</td><td>4</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td></tr></tbody></table><blockquote><p>定义状态</p></blockquote><p>前n个物品的在体积V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题，定义dp[i] [j] 为前i个物品放入到体积为j的背包中可以获得的最大价值。</p><blockquote><p>状态方程</p></blockquote><p>对于每个<strong>物品i（体积v[i]价值w[i]）</strong>我们都有两种选择：<strong>放入背包或不放入背包</strong>，是否放入取决于两个条件，第一：背包的容量是否足够；第二：放入之后的总价值与不放入到总价值哪个更大。</p><ul><li><strong>空间不足的时候</strong>，第i个物品放不进去，那么最大价值就是前i-1个物品的价值：<ul><li>dp[i] [j] = dp[i-1] [j]</li></ul></li><li><strong>空间充足的时候</strong>，能够放入第i个物品，但是我们必须要判断是选择放还是不放，<strong>判断的依据就是不放进去和放进去的价值大小</strong>，并选择两者中较大者：<ul><li>不放为：dp[i-1] [j]</li><li>放进去为：dp[i-1] [j - v[i]] + w[i] （因为要放进去，所以留给前i-1个物品的大小只有j-v[i]了，然后再加上w[i]）</li><li>最终dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j - v[i]] + w[i])</li></ul></li></ul><blockquote><p>边界条件</p></blockquote><p>当只放入第一件物品的时候，只需要判断当前的空间j是否能够放入v[0]即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">self, N, V, v, w</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j] = w[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; v[i]:</span><br><span class="line">                    <span class="comment"># 空间不足</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 空间充足</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-v[i]] + w[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][V]</span><br></pre></td></tr></table></figure><h1 id="2-01背包优化为二维dp-2-V-1"><a href="#2-01背包优化为二维dp-2-V-1" class="headerlink" title="2.01背包优化为二维dp[2] [V+1]"></a>2.01背包优化为二维dp[2] [V+1]</h1><p>通过上面的表格我们可以发现，当前行的结果只与上一行的结果有关，因此我们可以用一个二维数组来保存结果，这样可以更加节省空间。只需要判断当前行是奇数行还是偶数行即可，这里我们用的是i &amp; 1 这个操作，也可以用i%2这个来做判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> j &gt;= v[<span class="number">0</span>]:</span><br><span class="line">            dp[<span class="number">0</span>][j] = w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 空间不足</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; v[i]:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-v[i]] + w[i])</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[(N<span class="number">-1</span>)&amp;<span class="number">1</span>][V]</span><br></pre></td></tr></table></figure><h1 id="3-01背包优化一维dp-V-1"><a href="#3-01背包优化一维dp-V-1" class="headerlink" title="3.01背包优化一维dp[V+1]"></a>3.01背包优化一维dp[V+1]</h1><p>根据状态转移方程 $dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j - v[i]] + w[i])$ 我们可以看出，dp[i] [j]只与dp[i-1] [j] 、dp[i-1] [j - v[i]] 这两个元素相关，<strong>即第i行的数值只与第i-1行的<u>第j个格子以及第j-v[i]个格子相关</u>。</strong></p><p>对于第i行，我们此时遍历的顺序是<strong>从0到V</strong>，只需要改为<strong>从V到0</strong>就可以不用到这两个元素，这样就可以从二维降低到一维。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, v[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-v[i]] + w[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="4-416-分割等和子集"><a href="#4-416-分割等和子集" class="headerlink" title="4.416. 分割等和子集"></a>4.<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 100</p><p>我们以这个题目为例，来体验一下01背包问题的三种解法，把思路再过一遍。</p><h2 id="第一种解法：dp-N-V-1-解法"><a href="#第一种解法：dp-N-V-1-解法" class="headerlink" title="第一种解法：dp[N] [V+1]解法"></a>第一种解法：dp[N] [V+1]解法</h2><ul><li>因为需要把一个数组分成两个等和子集，所以数组之和必须是偶数才能够保证分成两个，每个子集的和定义为target；</li><li>然后接下来的过程就是从数组中可以选元素，但是我们背包的大小是target；</li><li>状态转移函数和边界条件都和上面的推理过程一样；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-nums[i]] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="第二种解法：dp-2-V-1-解法"><a href="#第二种解法：dp-2-V-1-解法" class="headerlink" title="第二种解法：dp[2] [V+1]解法"></a>第二种解法：dp[2] [V+1]解法</h2><p>这种解法只需要在前者的基础上加一个判断i为0还是1即可；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-nums[i]] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="第三种解法：dp-V-1-解法"><a href="#第三种解法：dp-V-1-解法" class="headerlink" title="第三种解法：dp [V+1]解法"></a>第三种解法：dp [V+1]解法</h2><p>这是第三种解法，依然类似与上面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h2><p>由于题目只需要返回能否分割等和子集（true or false）因此在我们定义dp数组的时候可以定义为bool类型，这样可以节省计算的时间；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-nums[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-494-目标和"><a href="#5-494-目标和" class="headerlink" title="5.494. 目标和"></a>5.<a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 20<br>0 &lt;= nums[i] &lt;= 1000<br>0 &lt;= sum(nums[i]) &lt;= 1000<br>-1000 &lt;= target &lt;= 1000</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>问题转换</p></blockquote><p>因为需要向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，所以最终我们得到的结果就是：正数之和+负数之和==target。<br>我们假设P是正子集，N是负子集，sum(P)代表正子集之和，sum(N)代表负子集之和。<br>例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]。</p><p>那么让我们看看如何将其转换为子集求和问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                  sum(P) - sum(N) &#x3D; target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) &#x3D; target + sum(nums)</span><br></pre></td></tr></table></figure><p>最终，我们可以得到sum(P)=(target + sum(nums))/2，<strong>所以我们的最终问题转换为求从数组nums中找到一组数，让其之和为sum(P)。</strong></p><blockquote><p>需要注意几个条件：</p></blockquote><p>第一：因为数组都是整数，所以target + sum(nums)必须是偶数；<br>第二：targe可能为负数，所以sum(nums)&lt;abs(target)即数组之和小于target的绝对值，例如：nums = [200], target=-100就是无法满足，返回0；（target为负数这个条件应该是题目最近新改的，我看很多题解都没有考虑到这个）</p><blockquote><p>状态转移</p></blockquote><p>动态规划定义dp长度为sum(P) + 1即可；<br>定义dp[j]为组成和为j的组合又dp[j]种， dp[j] += dp[j-nums[i]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        sum_ = sum(nums) + target</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> <span class="keyword">or</span> sum(nums) &lt; abs(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, nums[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] += dp[j-nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>此为本人学习笔记，整理方便回顾，会参考到部分博主，尽可能会一一列明，如有遗漏请见谅。</p><p>参考资料：</p><p>宫水三叶的相关题解以及LeetCode相关题解</p><p><a href="https://blog.csdn.net/weixin_45594025/article/details/106112195">https://blog.csdn.net/weixin_45594025/article/details/106112195</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解回溯算法</title>
      <link href="2021/12/29/211229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2021/12/29/211229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h1><p>回溯算法需要考虑三个问题：</p><ul><li>结束条件：递归在什么时候终止，返回结果；</li><li>已有路径：已经加入到结果中的元素；</li><li>待选路径：还有哪些元素可以加入到路径中来；</li></ul><p>核心有两个，一个是什么时候结束，一个是什么时候做选择以及回溯（递归）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">res = [] <span class="comment"># 记录中间结果（保存路径）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">res, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(res)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        res.append(选择)</span><br><span class="line">        backtrack(res, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        res.pop()</span><br></pre></td></tr></table></figure><h1 id="以46-全排列为例分析："><a href="#以46-全排列为例分析：" class="headerlink" title="以46. 全排列为例分析："></a>以<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>为例分析：</h1><img src="/2021/12/29/211229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.png" class><p>当输入为nums = [1,2,3]，我们进行全排列的过程是：首先固定第一个元素，然后在剩下的元素里选择一个固定第二个元素，最后固定第三个元素。例如，首先选择1作为第一个元素，然后就只有2、3可以作为第二个元素，如果选择2作为第二个元素，就只有3可以作为第三个元素；反之如果选择3作为第二个元素，就只有2作为第三个元素。</p><p>我们看一下这一题的三个问题：</p><ul><li><p>首先是结束条件：如果遍历到第三个元素说明递归终止；</p></li><li><p>其次是已有路径：当前元素如果是2，我们想要把当前元素选3，只需要交换2和3即可；</p></li><li><p>最后是待选路径：待选路径就是nums中没有加入到已有路径中的元素；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bacaktrack</span>():</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> len(res) == n:</span><br><span class="line">              <span class="comment"># 结束条件，长度为n的时候结束</span></span><br><span class="line">                result.append(res[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                  <span class="comment"># 做选择前需要判断nums[i]是否已经加入到res中，如果没有加入就选择加入</span></span><br><span class="line">                  <span class="comment"># 做选择</span></span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    bacaktrack()</span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    res.pop()</span><br><span class="line">        result = []<span class="comment"># result保存最终结果</span></span><br><span class="line">        res = []<span class="comment"># res 保存中间结果</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        bacaktrack()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上面的代码可以优化一下，因为我们得到的最终结果只需要在nums中进行交换元素即可，不需要每次都从头遍历保存在res中，这样既可以节省时间也可以节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bacaktrack</span>(<span class="params">start</span>):</span></span><br><span class="line">          <span class="comment"># start表示下一次递归从nums中的开始位置</span></span><br><span class="line">            <span class="keyword">if</span> start == n:</span><br><span class="line">              <span class="comment"># 结束条件，如果开始位置start==n结束为止就终止</span></span><br><span class="line">                result.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n):</span><br><span class="line">              <span class="comment"># 做选择（把start开始位置与i位置交换元素）</span></span><br><span class="line">                nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">                bacaktrack(start + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销选择（两次交换就相当于撤销选择了）</span></span><br><span class="line">                nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">        result = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        bacaktrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">m &#x3D;&#x3D; board.length</span><br><span class="line">n &#x3D; board[i].length</span><br><span class="line">1 &lt;&#x3D; m, n &lt;&#x3D; 6</span><br><span class="line">1 &lt;&#x3D; word.length &lt;&#x3D; 15</span><br><span class="line">board 和 word 仅由大小写英文字母组成</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>用回溯来做，首先backtrack(i, j, k)代表代表board[i] [j] == word[k]吗，如果相等就选择[i, j]，否则就不选择；</p><p>定义一个visited数组，用来表示[i, j]是否已经访问，如果选择就把[i, j]加入到visited中，否则就弹出[i, j]。</p><p>当我们选择[i, j]之后，就有判断下一步往哪走，因为有上下左右四个方向，所以需要回溯四个方向。</p><p>接下来就是初始：初始的位置可以是board中的任意一个元素，所以需要把每个位置都遍历一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: List[List[str]], word: str</span>) -&gt; bool:</span></span><br><span class="line">        directions = [[<span class="number">0</span>,<span class="number">-1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">i, j, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> board[i][j] != word[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># i, j 为board中的位置，k为word中的位置</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 边界，word找到了返回True</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            visited.append([i, j])</span><br><span class="line">            <span class="comment"># 选择(i, j)</span></span><br><span class="line">            result = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">for</span> di, dj <span class="keyword">in</span> directions:</span><br><span class="line">                newi, newj = i + di, j + dj</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= newi &lt; len(board) <span class="keyword">and</span> <span class="number">0</span> &lt;= newj &lt; len(board[<span class="number">0</span>]):</span><br><span class="line">                    <span class="keyword">if</span> [newi, newj] <span class="keyword">not</span> <span class="keyword">in</span> visited <span class="keyword">and</span> backtrack(newi, newj, k+<span class="number">1</span>):</span><br><span class="line">                        result = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">            visited.pop() <span class="comment"># 不选择i， j</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        visited = []</span><br><span class="line">        m, n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> [i, j] <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">if</span> backtrack(i, j , <span class="number">0</span>):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="相关题目目录"><a href="#相关题目目录" class="headerlink" title="相关题目目录"></a>相关题目目录</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></p><p><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></p><p><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></p><p><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></p><p>题目还有很多，可以直接去回溯标签下找一些，做几个熟悉一下即可。</p><p>参考文献：<a href="https://www.cnblogs.com/looyee/articles/12084932.html">https://www.cnblogs.com/looyee/articles/12084932.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二叉树的层序遍历</title>
      <link href="2021/12/27/211227-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/12/27/211227-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-层序遍历讲解"><a href="#1-层序遍历讲解" class="headerlink" title="1.层序遍历讲解"></a>1.层序遍历讲解</h1><blockquote><p>基本用法</p></blockquote><p>层序遍历就是按二叉树从上到下，从左到右依次访问每个节点。</p><ul><li>首先将二叉树的根节点push到队列中，判断队列不为NULL，就输出队头的元素， </li><li>判断节点如果有孩子，就将孩子push到队列中， </li><li>遍历过的节点出队列， </li><li>循环以上操作，直到Tree == NULL。</li></ul><p>在使用python实现的过程中，我可以借助列表来模拟队列操作；在每次访问队头元素的时候，可以用pop(0)来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                nodeQueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>进阶用法</p></blockquote><h4 id="102-叉树的层序遍历"><a href="#102-叉树的层序遍历" class="headerlink" title="102.叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102.叉树的层序遍历</a></h4><p>层序遍历的基础用法基本上不会涉及到，因为仅仅只是实现了遍历元素的功能，更多的是进阶用法：题目中一般是让你访问每一层，然后把每一层单独保存下来。LeetCode中的层序遍历变形基本都是基于这一种操作。</p><p>进阶用法在前者的基础上新增加一个队列来保存每一层的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            <span class="comment"># 用res和nextQueue来保存每一层的节点和结果 </span></span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextQueue.append(node.right)</span><br><span class="line">            result.append(res)</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="2-相关题目变形"><a href="#2-相关题目变形" class="headerlink" title="2.相关题目变形"></a>2.相关题目变形</h1><h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> chl <span class="keyword">in</span> node.children:</span><br><span class="line">                    nextQueue.append(chl)</span><br><span class="line">            result.append(res)</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。</p><p>这个题目是在题目102的基础上，只是输出结果是先输出底层在输出顶层，所以代码只需要修改一行即可。把结果逆序输出即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result[::-1]</span><br></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>这个题目也是基于102的基础，只是输出的时候中间每一层的res奇数层从左到右，偶数层从右到左。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextQueue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(res[::<span class="number">-1</span>])</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h2><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>这个题目也是经典变形，只需要修改一下代码即可。</p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>通过层序遍历一遍即可，需要注意因为next初始为空，所以只需要处理每一层的前n-1个节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            n = len(nodeQueue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    node.next = nodeQueue[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodeQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><p>提供了两种方式，第一种是水平连接，第二种是纵深连接，之后有时间画个图来讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.next = root.right</span><br><span class="line">            <span class="keyword">if</span> root.next:</span><br><span class="line">                root.right.next = root.next.left</span><br><span class="line">            self.connect(root.left)</span><br><span class="line">            self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            left.next = right</span><br><span class="line">            left = left.right</span><br><span class="line">            right = right.left</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h2 id="BFS广度优先遍历"><a href="#BFS广度优先遍历" class="headerlink" title="BFS广度优先遍历"></a>BFS广度优先遍历</h2><p>典型的层序遍历，直接用层序遍历，然后把每一层最右边的节点值保存下来即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = [root]</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            n = len(nodeQueue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == n<span class="number">-1</span>:</span><br><span class="line">                    result.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodeQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h2><p>在进行深度优先遍历的时候需要注意：第一，访问顺序是根节点、右节点、左节点这个顺序，这样可以确保访问右节点在左节点前面；第二，每次访问根节点的时候只要判断一下是否res的长度与二叉树当前节点深度是否一致即可判断是否把当前节点值加入到res中来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.left &#x3D; left</span><br><span class="line">#         self.right &#x3D; right</span><br><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        def DFS(root, depth):</span><br><span class="line">            if not root:</span><br><span class="line">                return</span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line">            if len(res) &lt; depth:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">            DFS(root.right, depth)</span><br><span class="line">            DFS(root.left, depth)</span><br><span class="line">            return res</span><br><span class="line">        DFS(root, 0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二叉树的三种遍历方式（前序、中序、后序）</title>
      <link href="2021/12/24/211225-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>2021/12/24/211225-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、三种遍历方式讲解"><a href="#1、三种遍历方式讲解" class="headerlink" title="1、三种遍历方式讲解"></a>1、三种遍历方式讲解</h2><blockquote><p>LeetCode题目链接</p></blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><blockquote><p>三种遍历讲解</p></blockquote><table><thead><tr><th>名称</th><th align="left">节点遍历方式（左根右）</th><th>题目难度</th></tr></thead><tbody><tr><td>二叉树的先序遍历</td><td align="left">根节点、左节点、右节点</td><td>Easy</td></tr><tr><td>二叉树的中序遍历</td><td align="left">左节点、根节点、右节点</td><td>Easy</td></tr><tr><td>二叉树的后序遍历</td><td align="left">根节点、左节点、右节点</td><td>Easy</td></tr></tbody></table><p>只要弄清楚三者的区别在做题的时候就可以更好的实现和理解，实现方法可以分为递归和非递归两种方式，代码可以参考下面。</p><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="2、前序遍历代码实现"><a href="#2、前序遍历代码实现" class="headerlink" title="2、前序遍历代码实现"></a>2、前序遍历代码实现</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(nodeStack) != <span class="number">0</span>:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line">        result = []</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的中序遍历"><a href="#3-二叉树的中序遍历" class="headerlink" title="3.二叉树的中序遍历"></a>3.二叉树的中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> nodeStack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                nodeStack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = nodeStack.pop()</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        result = []</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="4-二叉树的后序遍历"><a href="#4-二叉树的后序遍历" class="headerlink" title="4.二叉树的后序遍历"></a>4.二叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><blockquote><p>非递归方式</p></blockquote><p>后序遍历的稍微有一点不一样，因为在访问左右根的时候，比较难操作，我们可以实现先访问<strong>根右左</strong>，然后再逆序输出就可以得到<strong>左右根</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(nodeStack) != <span class="number">0</span>:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">        result = []</span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="5-N叉树的前序遍历"><a href="#5-N叉树的前序遍历" class="headerlink" title="5.N叉树的前序遍历"></a>5.N叉树的前序遍历</h2><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">                pre(chl)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        pre(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><p>递归方式需要注意，遍历的时候是先保存后面的，再保存前面的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = [root]</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> node.children[::<span class="number">-1</span>]:</span><br><span class="line">                nodeStack.append(chl)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-N叉树的后序遍历"><a href="#6-N叉树的后序遍历" class="headerlink" title="6.N叉树的后序遍历"></a>6.N叉树的后序遍历</h2><blockquote><p>非递归方式</p></blockquote><p>N叉树并没有什么太大的区别，只需要在遍历的时候用for循环考虑多个子节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> node.children:</span><br><span class="line">                nodeStack.append(chl)</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">                post_(chl)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">        result = []</span><br><span class="line">        post_(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研经验贴】本科双非上岸复旦大学计算机学院</title>
      <link href="2021/04/21/210421-%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>2021/04/21/210421-%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<p>去年指导一位本科学弟，成功上岸复旦大学计算机学院，特邀请他写下此贴。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我本科就读于双非院校，初试成绩分别为<strong>政治69，英语71，数学126，408计算机基础综合112，总分378</strong>。</p><p>在前面我很想说，其实我认为考研有一个很重要的方面是找到属于自己的复习方式以及节奏，别人的经验包括我的也更多的是一种参考，就像政治讲的实事求是，根据自己的情况，找到属于自己的学习方法。</p><p>比如我个人如果早期起来的很早，下午会没有精神，那我就八点多到教室也完全可以；我也有一个朋友考的科软，每天八九点来，晚上学到九点就不学，最后成绩441，四千人成绩前五，虽然天赋有一定成分，但是也可以说明，并不是每天必须呆在自习室多久才能有多好的成绩。</p><p>所以还是强调，考研不能仅靠别人推荐的学习安排，更重要的是实事求是，根据自身情况找到属于自己的方法。</p><h1 id="分科介绍"><a href="#分科介绍" class="headerlink" title="分科介绍"></a>分科介绍</h1><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>我其实对最后的政治成绩并不是很满意，我客观题应该是44，这次主观题有点失误。</p><p>客观题重要的是多刷题，我也是听完了徐涛的课程，刷的是肖老的1000题、肖八、肖四，后期在手机上刷了各种模拟卷，比如余等人的（其实我觉得徐涛、腿姐的模拟卷质量不是很高），在小程序上，学累了就刷一下题，分数不重要，到后期甚至模拟卷我都可能35分不到，更重要的是这些知识不断地会重复，而且真题一定会简单一些，刷题刷多了最后做真题能明显地感觉到哪些选项是对的，哪些是干扰项，从哪个地方干扰的。最后有时间也要看几套真题，模拟卷和真题还是有一定差距，最像真题风格的选择题目也就肖四肖八。</p><p>主观题是因为今年肖老发挥超神，大题都预测到了，而我当时是看了研木易的主观题，最后并没有按照肖四中全部背下来写，更多的是用自己的话整理出来。但是可能由于上海的判卷尺度，让老师误认为我并没有背肖四，只是记住了大概；还有就是也不一定要写满，我觉得我是把肖老提到的点写完之后自己又补充，每道题都写满，最后成绩不是很理想，如果考旱区的可以注意一下。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>英语今年英二比较难，我是按照往年的题目难度去准备的，英语并不是我的强项，也没花费很多时间，最后的结果还比较差强人意。</p><p>暑假的时候利用王江涛那本十天背完考研词汇，大概十几天每天花四五个小时，背会了大概七、八成的单词，接下来就是用扇贝每天手机复习一点。 暑假开始做真题，只做阅读理解，一开始做的英一，后来时间不太够就做的英二。到十一月的时候开始看一些作文以及做一些完型等题型。</p><p>总的来说只要坚持背单词，做好阅读，英语不会成为拖累的科目，但如果想要在这方面考的高一点，就需要基础比较好或者复习比较努力。 </p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>今年数二的题目非常简单，按照往年经验一般有一道难题压轴，但是今年并没有出现难题，只要计算基础过关都能拿到一个不错的分数。</p><p>我的数学进度不太值得参考，大概就是在网上看到的进度往后推一个月左右。三四月份我是在家复习，看完了张宇的基础三十讲当中的高数部分，五月份到学校之后，一段时间不学习导致忘记了很多，又重新开始看武忠翔的基础班，到七月底才开始线代，强化甚至也是暑假结束了还没有看完高数的强化。不过我想说的是，如果自己真的进度没有很快，那么看到别人进度快不要着急，一定要打好基础，最后来得及的。</p><p>后期我做的模拟题是张八，李六和李四，比较推荐李林的试卷，包括李林的习题集880也很推荐，只不过我后期才发现，只做了880的线代部分。李林的题目和真题比较像，不会出现很偏很怪的题目，做好之后遇到基础的题目应该不会没有思路，如果想要成绩高一点，那就需要大量的刷题。</p><p>再说一下考试的时候，杭州考场时只给两张16开的草稿纸，根本不够用的，而且考试当天也最好喝杯咖啡什么提提神，我考试的时候有点晕晕乎乎，导致一道填空题写对了，往答题卡上写的时候漏抄了，就直接丢掉了五分。同时也证明大量的刷题也十分重要，我是三个小时刚好做完，甚至一点检查的时间都没有，而我朋友刷题多，他两个小时就做完了，所以最后就成绩比较高。</p><h2 id="408计算机基础综合"><a href="#408计算机基础综合" class="headerlink" title="408计算机基础综合"></a>408计算机基础综合</h2><p>​      我是从暑假开始看408的，先看了天勤的数据结构，直接看书看完了，发现收获不是很多。之后再看的王道全家桶，看视频以及做书上的习题。408这种东西一开始学的时候会觉得很痛苦，因为很多知识记不住，但是没关系，一遍一遍的看，到最后会觉得做408的真题是一件比较轻松愉悦的事情。</p><p>​    总的来说408应该看书，第一遍可以看视频，然后之后就可以直接看书，看三到四遍的时候就会发现没那么难，没有什么太难理解的东西，更多的在于能不能记得住，如果想要125+甚至更高的话，只看王道是不够的，应该结合考纲所指出的具体书籍进行学习。</p><h1 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h1><ul><li><p>政治：《肖秀荣全家桶》，徐涛的《精讲精练》（如果看课可以选择这个）</p></li><li><p>英语：我是只用的张剑的《黄皮书》，单词用的是王江涛《十天背会考研词汇》</p></li><li><p>数学：我跟的武忠翔，书用的是《高等数学辅导讲义》《线性代数辅导讲义》，习题集我只推荐他们的《660》（《330》不太推荐），还有李林的《880》编的也比较有真题味。模拟卷李六和李四一定要做，都是基础的题目，22的试题可能比21难的情况下，可以适当看张宇的张八和张四，然后就是合工大共创以及超越。（汤家凤和李永乐团队的模拟题不推荐）</p></li><li><p>408：《王道全家桶》</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实即便从现在开始，也不用太紧张，只考虑初试的话也是完全来的及的。不要总盯着别人的进度以及攻略帖子的时间表，如果实在比较慢还是要稳扎稳打，不能为了赶进度而马马虎虎做完，这样后期也要花费时间来填坑。考研从来不是比谁学的久，而是比谁学的多，比谁考场发挥的好的比赛。心态也是考研很重要的一部分，希望大家可以稳住心态慢慢来，最终考上理想的学校和专业！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 经验贴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】计算机考研复习指导（简易版）</title>
      <link href="2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/"/>
      <url>2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍了408计算机考研复习的基本过程，关于时间、资料、真题都会有介绍，大家可以参考一下，整个属于简易版，后期我会推出一个更加详细的版本。</p><h1 id="考研资料准备"><a href="#考研资料准备" class="headerlink" title="考研资料准备"></a>考研资料准备</h1><img src="/2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/1.png" class><p><strong>对于辅导书</strong>，并没有太多的选择，除了王道的辅导书就是天勤，除此之外并没有其他可以选择的了，由于我身边考研的同学中，大多数都是选择王道的，所以在此处也就统一推荐王道了，各位可以根据自己的喜好来从两个机构的辅导书中自行决定。</p><p><strong>对于教材</strong>，我推荐的这四本也是网上大家用到的比较多的，这些教材可以在网上找一些PDF即可，因为使用的频率比较低。计算机组成原理有一些章节可以参考一下教材，其他的三门看辅导书已经足够了。复习过程中，可以直接看辅导书进行复习，遇到不会的知识点、重难点可以翻看一下教材，或者是去看一下王道的视频讲解。<strong>不建议全程看王道的视频或者教材，只要针对性的去看即可。</strong></p><p><strong>对于真题</strong>，真题是十分重要的，甚至可以说是最重要的复习资料，从真题里面你可以分析出出题类型、难度、方向、综合性。真题做题方法可以按照四个科目单独做，也可以按照整套试卷的方式来做。</p><p>对于模拟题，无论是王道还是天勤的模拟题，质量都是无法和真题相媲美，只能拿来做个参考，不用过于在意分数，毕竟408复习过程中的能做的题目并不是很多。</p><h1 id="408复习指导"><a href="#408复习指导" class="headerlink" title="408复习指导"></a>408复习指导</h1><p>408复习大致上需要4-5轮，每一轮都要侧重点不同</p><h2 id="第一轮复习-60天-75天"><a href="#第一轮复习-60天-75天" class="headerlink" title="第一轮复习(60天-75天)"></a>第一轮复习(60天-75天)</h2><blockquote><p>复习过程</p></blockquote><ul><li>第一轮的复习需要<strong>全面复习</strong>，无论是重点知识点还是非重点都要全部看一遍，大纲上提到的知识点都必须要复习到；</li><li>对于一些难点，如果实在看不懂也不用怕，可以先做个标记，可以先放下，等之后第二轮再特意攻克；</li><li><strong>做题</strong>，<strong>可以先做选择题以及一部分分析题</strong>，这样安排是因为选择题一般涉及到的知识点比较单一，可以起到巩固知识点的作用；分析题一般会涉及到多个知识点，有的甚至是多个学科，所以做不出来是很正常的，能做出来多少就做多少；</li><li><strong>时间</strong>：408四个科目，难度和内容都不一样，一般来说需要2个月时间才能复习完一轮，平均2天复习一章，有一些章节比较简单，花费的时间就相对减少（例如数据结构的第1、2、3章，计组的第1章，操作系统第1、5章，计网的第1、6章）这些章节复习的时候就自己把握时间，有些章节就会比较难，内容也会很多，可能需要安排3天时间复习一章；</li><li>常遇到的问题：408四个科目会出现后一门的时候忘记了前一门的知识，这个很多人都会遇到，我建议是通过<strong>我的笔记</strong>来快速回顾一下整个一门课的知识点。</li></ul><h2 id="第二轮复习（50-60天）"><a href="#第二轮复习（50-60天）" class="headerlink" title="第二轮复习（50-60天）"></a>第二轮复习（50-60天）</h2><blockquote><p>复习过程</p></blockquote><ul><li>第二轮复习依然是全面为主，但是在复习速度会快很多，因为简单的知识点只要看一下回顾一下就可以了，难点以及自己做出特殊标记的地方需要重点回顾；</li><li>在这一轮，选择题的问题要全部解决或者尽可能全部解决；分析题要基本上能够做出来，做不出来的也要看答案去理解，学习解题方法；</li><li>通过这一轮的复习，要基本上做到所有题型都遇到了也能做出来，为接下来第三轮作准备，同时要熟悉考试的题型，不仅仅是纯粹做题，把出题的套路也要解决掉；</li><li>这一轮复习时间上可能会比第一轮少一点，一个半月至两个月，反正就是尽可能压缩，提高复习速度和效率，人总是会拖延的，如果你给自己定了时间点就会自然而然提高效率；</li></ul><h2 id="第三轮复习"><a href="#第三轮复习" class="headerlink" title="第三轮复习"></a>第三轮复习</h2><blockquote><p>复习过程</p></blockquote><ul><li>这一轮的<strong>重点是真题</strong>，408是统考，所以考试的题目、出题方向都不会有太大的变化，因为要照顾到全国的学生，真题的重要性不言而喻；</li><li>真题可以按照整套试卷来做，也可以按照单独科目来做，可以先拿出来三年的做一下测试一下，最后建议流出后三年的试卷先不要做，可以留着后面测试一下（这个后面并不是考试前，大概十一月份就要做完所有的真题）；</li><li>分析真题，这个是至关重要的，因为你只做题目是没有用的，必须要分析自己做错的原因，出题的方向，横向对比以及纵向对比出题的类型，最后要总结一下哪些题型每年都考，哪些自己做到还不够好，哪些还需要加强；</li><li>通过真题查漏补缺，做题遇到不会的知识点，做完就赶紧复习一下，看看书和笔记，然后记住，通过不断查漏补缺来提升分数和实力。</li></ul><h2 id="第四轮复习"><a href="#第四轮复习" class="headerlink" title="第四轮复习"></a>第四轮复习</h2><ul><li>复习到这阶段距离考试估计还有一个月左右，这段时间也没有太多题目可以做，网上会有一些模拟题，可以参考看看，有时间和精力就做做，因为到最后一个月政治会有很多需要记忆的内容，专业课更多的是查漏补缺。</li><li>这个时期你已经没有足够的时间去系统性把辅导书全面复习了，所以你平时整理的笔记就会十分重要了，你可以拿出来笔记来快速反复复习。</li></ul><h1 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h1><p>由于整理笔记十分花费时间，所以不建议大家去自己整理笔记，可以在本人整理的笔记基础之上添加一些笔记即可；</p><p>详情可点击该链接，文末有购买方式：<a href="https://sanduohou.github.io/2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">【考研】408计算机考研笔记介绍及使用方法</a></p><img src="/2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/2.png" class>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】408计算机考研笔记介绍及使用方法</title>
      <link href="2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="408笔记介绍"><a href="#408笔记介绍" class="headerlink" title="408笔记介绍"></a>408笔记介绍</h1><img src="/2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/2.png" class><p>408的复习由于涉及到四个科目，且内容十分广泛，<strong>很容易出现复习后一门科目的时候而忘记前面复习的科目</strong>，因此萌发了自己整理一份笔记，这样可以快速回顾整个科目多个章节的内容。笔记是用OneNote制作整理的，因为这个软件可以实现表格的无限嵌套，整理的笔记会条理清晰，然后加上不同的配色来突出重难点。笔记是初试期间整理的，一般是复习完一章就晚上回到住处整理，如果对知识熟悉一章也花不了太多时间，还可以加深记忆。前期使用确实是花费了较多的时间用来整理笔记，不过整理几章熟悉软件的操作之后速度就大大加快。</p><p>我是复试通过之后，在一个复试群里发了自己的笔记，就有很多参加复试的小伙伴向我索要笔记，当时主要是想着能够帮助大家，基本是白菜价给那些小伙伴们，后来朋友就鼓励我把笔记放在闲鱼，这样可以让更多的人用到自己的笔记而受益。我是相信自己的笔记可以帮到各位学弟学妹才拿出来的，整理笔记并不需要成绩多么好，只需要能够细心、认真、耐心、愿意花时间就可以做得很好。笔记是用OneNote制作整理，有想要尝试的小伙伴可以试一下，但是要做好需要花费大量时间的准备，<strong>经历过整理笔记的经历之后我不太建议大家再去自己去整理笔记。这就像计算机中“时间换空间”还是“空间换时间”一样，你可以通过花费一些钱来获得笔记节省时间，真的没有必要再去自己花费大量的时间整理笔记。</strong></p><ul><li><strong>《数据结构笔记》</strong>参考2021版王道、数据结构（C语言版严蔚敏）</li><li><strong>《计算机组成原理笔记》</strong>参考2021版王道、计算机组成原理（第二版唐朔飞）</li><li><strong>《计算机网络笔记》</strong>参考2021版王道、计算机网络第七版（谢希仁）整理</li><li><strong>《操作系统笔记》</strong>是根据2021版王道、计算机操作系统（第四版）汤小丹整理</li></ul><p><strong>目前，笔记只有纸质版，不再出售电子版，纸质版定价为99元四科，彩色打印包邮，有需要的同学可以通过下方购买，购买之后添加我的私人微信：cs188513890</strong></p><p><a href="http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW">http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW</a></p><p><a href="http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW"><strong><u>408笔记购买方式，该链接即可跳转</u></strong></a></p><p>购买之后14:00之前下单，当天发货，14:00之后下单，第二天发货。</p><img src="/2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/1.png" class><h1 id="第二版笔记的升级"><a href="#第二版笔记的升级" class="headerlink" title="第二版笔记的升级"></a>第二版笔记的升级</h1><p>第一版笔记由于是初试期间整理，有几个章节做的并不够好，因此我在第一版笔记的基础上进行了小的调整。</p><p> <strong>第二版笔记调整如下</strong>: </p><ol><li><p>原有的配图是截图方式，现在改为文字编辑或更换带有明显水印的截图，例如数据结构的代码全部是编辑器编辑之后再截图更加清晰; </p></li><li><p>部分章节的配色第一版没有加上去，在第二版中全部加上去保证统一格式; </p></li><li><p>数据结构前三个章节由于内容较少，第一版采用的是思维导图方式，在第二版中我进行了改进，与现有笔记格式统一; </p></li><li><p>为了防止盗版，把水印的位置与笔记合为一体，既不影响诸位使用也可以保证水印的存在；</p></li><li><p>另外，最近也开始在找人整理出第三版笔记了，具体更新时间暂时不确定，大家有需要可以先使用第二版笔记即可，应付考研完全是足够的；</p></li><li><p>由于笔记是彩色打印，截图打印出来的效果可能会有点不清晰，还请多谅解，不过基本不影响大家正常使用。</p></li></ol><h1 id="笔记如何使用"><a href="#笔记如何使用" class="headerlink" title="笔记如何使用?"></a>笔记如何使用?</h1><p>第一，笔记是对知识的整理、归纳、汇总，涉及的多是重点、难点知识，无法做到对知识的全面覆盖，所有一定要结合辅导书使用。前期需要以辅导书为主，笔记为辅，对知识进行全面复习;后期因为要抓住重点、难点、考点进行复习，不能胡子眉毛一把抓，可以笔记和辅导书同步结合，然后结合真题进行复习，越到后期笔记越重要。 </p><p>第二，为了解决408复习过程中复习后一个科目忘记前一个科目的情况，大家可以在复习空余，定期根据笔记来快速回顾前面的一个科目重点知识，这样既不需要花太多的时间也可防止知识遗忘。 </p><p>第三，笔记主要是用于初试，但是复试亦可，因为复试只需要根据提问叙述出大致意思即可，对一些细节、计算的要求相对较低，所以准备复试的小伙伴也完全可以在短期内复习408的大量内容，并且全部是重点。我整理了一份每章节的复试问题汇总，如果有需要可以私聊我。 </p><p>第四，对于本科期间的期末考试，原则上来说知识是覆盖到了，但是每个学校的期末考试侧重点是不一样的，所以如果是用于期末复习的小伙伴需要根据自己学校的历年考题来进行适当调整。</p><p>第五，现在改考408是大趋势，20、21两年改考的学校已经有几十所，诸位如果选定的学校不是408一定要做好准备：<strong>如果改考408怎么半？</strong>临时改科目确实是一件比较讨厌的事情，大家在准备的过程中也都是信息满满，抱着必上某所学校的决心，甚至是非某所学校不上的决绝，但是我遇到过很多人，当成绩出来的时候，他们找调剂，有点甚至需要二战、工作而以没有学可上而结束。到那时，很多人都会感慨一句:“<strong>有学上比考到自己心目中那所学校更重要。</strong>”</p><p>以上只是建议，还请诸位谨慎采纳，祝各位都可以取得一个好的成绩!</p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>笔记全程都是由我一人初试期间整理，难免会有个别错误以及一些不足之处，如果各位学弟学妹在使用过程中发现，可以通过邮箱（<a href="mailto:&#x31;&#x38;&#x38;&#53;&#49;&#51;&#56;&#x39;&#48;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;">&#x31;&#x38;&#x38;&#53;&#49;&#51;&#56;&#x39;&#48;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;</a>）反馈于我，我在之后的版本中会做一个汇总以便帮助大家指正;</p><p><strong>诸位做为中国高等教育的精英，保护版权、尊重版权、打击盗版应该从我们每个人做起，如果精英阶层都无法做到保护他人知识产权，那么我们所接受的教育就会存在很大缺陷!今日你为他人知识产权站队，明天他人也会为你的知识产权撑腰！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】考研择校如果做到尽可能理性？</title>
      <link href="2021/04/13/210413%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/"/>
      <url>2021/04/13/210413%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-38614663c03722521a9e7f88195d097a_r.jpg" alt="考研择校如何做到尽可能理性选择，拒绝盲目？"></p><p>20年上岸，看到身边很多小伙伴最终被迫选择调剂、工作、二战，感到十分可惜。特写下此篇，以指导诸位学弟学妹在考研的第一步就选择对，这样会让你的考研之路更加有把握。看完此篇，再来对照你择校的过程。大家在选择学校的时候，一定要经过尽可能的理性分析，而不是感性的选择。选择学校这一步走错了，基本上也就意味着你的考研之路悲惨结局开始了。</p><h2 id="第一：什么是感性选择？"><a href="#第一：什么是感性选择？" class="headerlink" title="第一：什么是感性选择？"></a><strong>第一：什么是感性选择？</strong></h2><p>名校情结，非这个学校不上，完全没有考虑自己的实力和学校的难度；感觉自己能够考上，对自己要考的学校了解很少，例如初试科目难度怎么样、复试比例多少、刷人多不多、是否等歧视双非学校等信息都一无所知；对往年数据（经验贴）没有做任何收集，全凭自己的感觉走；选择考研，并不是自己真的想要考研，而是看身边人考研了，自己随大流；<strong>以上情况都是考研择校的大忌，往往会葬送你的考研梦想；</strong>当然，如果你能够承受名校情结可能带来的风险，并且知道如果自己无法上岸会去干什么，那你就勇敢去拼搏一把吧！</p><h2 id="第二：如何做到尽可能理性选择？"><a href="#第二：如何做到尽可能理性选择？" class="headerlink" title="第二：如何做到尽可能理性选择？"></a><strong>第二：如何做到尽可能理性选择？</strong></h2><p>要说明一点，择校想要做到完全理性是不可能的，只能做到有限理性，因为我们的信息是有限，即使你能够把我下面强调的信息完全收集到也不行，因为人们在预估自己的实力之时，往往很难做到理性。但是通过我下面的方法，可以尽可能让你选择一个自己更有把握的学校<br>选择几个学校作为备选项，就是这几个学校都可以作为你的意愿学校，这种备选学校最好能够有5个以上，实力都相差不大即可；收集备</p><p><strong>选学校过去三年的考研信息，这些信息包括：（很重要）</strong><br><strong>初试科目及难度、专硕/学硕招生人数（去掉推免之后的人数）、进入复试的人数及比例、历年的报录比、每年的单科分数线及总分数线、是否歧视双非学校的学生、是否保护第一志愿、复试科目都有哪些内容等等</strong>，只要能够找到的，全部都收集下来，会有一些信息学校没有公布；</p><p>还要再去看经验贴，就是往年考上的学姐学长在网上分享的经验贴，这是一个很好的一手材料，作为对考研学校的一些辅助分析，例如可以分析复试难度、是否歧视双非等信息；把上面这些数据拿出来对比，既要纵向对比（看这个学校的报考热度、分数是否增加），也要横向对比（看哪个学校更好考一些）。</p><p>根据这些对比，你要能够预估一下自己这些学校下一年的分数会在多少，自己要是考这些学校能够考多少分，需要付出多大的努力，有多大的决心；除此之外，还要考虑复试，因为初试能够进去只是过了第一关，复试这一关更加重要。复试不及格是无法录取的，就拿计算机专业来说，有的学校需要上机编程，你能否顺利通过，又能拿到多少分呢？对于计算机的同学来说，需要强调的是，就我目前观察的情况是，21年计算机多所学校出现了高分被刷的同学，而且不乏初试排名前几名的同学，这是因为现在考研已经进入了存量时代，老师开始更加重视学生专业技能而不在是你能考多少分。因为老师招收一个学生，本来就培养时间在2.5-3年之间，如果跨考的学生基础以及可塑性太差的话，即使是初试高分老师也是不太想要的。</p><p>对自己进行分析，这是最难做到理性的，所以在完成以上的分析之后，要把这些数据找一个老师或者考上的学长学姐帮你分析。看看你能否实现你自己预定的分数，哪个学校考上的把握更大，然后选择1-2个学校作为备选（这两个学校最好科目差不多，如果科目差别大的话，就只能选择一所学校了），到9、10月份的时候根据自己的复习情况填报志愿。</p><h2 id="第三：如何看待“选择大于努力”"><a href="#第三：如何看待“选择大于努力”" class="headerlink" title="第三：如何看待“选择大于努力”"></a><strong>第三：如何看待“选择大于努力”</strong></h2><p>每个人的看法都不一样，我说说自己的看法：“选择大于努力”这句话是考研界十分流行的一句话，首先要明确的是：选择确实比努力更重要，因为你选择错了，怎么努力都是徒劳，因为你努力的上限不能够达到你选择的下限，就像鲤鱼跳龙门一样，这条鲤鱼能够跳的最大高度不能够超过门的高度。</p><p>今年（20年）因为疫情的影响，很多学校扩招，选择这些学校的学生真的是很幸运的。但是疫情毕竟是突发事件，几十年才能遇到一次，所以我们还是主要考虑常规事件。选择很重要，但是你选择的学校毕竟是自己喜欢的、想要去的，如果选择一个自己即使考上了也不能够开心学习的学校，哪怕这个学校很好考，我也认为大可不必。选择还是要想我上面所说，尽可能理性选择，而不是感性盲目选择。</p><p>最后再说一句，每个人在备考的过程中都会雄心壮志，非这个学校不上，但是最终大多数人都会被现实打败，他们会屈服在自己考研分数的现实面前，不得不低下自己骄傲的头颅，卑微地四处找调剂，那个时候他们才会认识到<strong>“有学上是多么重要”</strong>。当然也有人会继续扬起自己骄傲的头颅选择二战。现实是可悲的，考研无论怎么扩招，最终录取率还是保持在20-30%，四、五个考研学生里只有一个学生能够录取！</p><p>选择考研，你真的准备好了吗？</p><hr><p>我建立了一个考研打卡群，群里有一些小伙伴可以每天一起打卡自己的学习内容，如果你是单独备考，欢迎你加入我们，一起交流学习！</p><p>微信：cs188513890（加好友请备注：考研打卡群）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【408笔记勘误】4月10日更新</title>
      <link href="2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/"/>
      <url>2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>笔记在整理过程中，难免存在一些错误，我会把大家反馈的错误在此处进行勘误，如果您在使用笔记的过程中发现有错误之处，还请及时告知于我，以便我勘误，并在下一版笔记中纠正。</p><p>联系方式（微信）：cs188513890</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="第三节：线性表的链式表示"><a href="#第三节：线性表的链式表示" class="headerlink" title="第三节：线性表的链式表示"></a>第三节：线性表的链式表示</h3><img src="/2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/1-1.png" class><p>把**<u>“按值查找节点值”与“按序号查找节点的值”</u>**交换位置</p><h2 id="第四章：树和二叉树"><a href="#第四章：树和二叉树" class="headerlink" title="第四章：树和二叉树"></a>第四章：树和二叉树</h2><h3 id="第三节：二叉树的遍历与线索二叉树"><a href="#第三节：二叉树的遍历与线索二叉树" class="headerlink" title="第三节：二叉树的遍历与线索二叉树"></a>第三节：二叉树的遍历与线索二叉树</h3><img src="/2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/1-2.png" class><p>三种遍历方式，都应该是先访问左节点，再访问右节点，因此需要把<strong>T-&gt;rchild与T-&gt;lchild</strong>交换位置</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="第一章：操作系统概述"><a href="#第一章：操作系统概述" class="headerlink" title="第一章：操作系统概述"></a>第一章：操作系统概述</h3><h3 id="第一节：基本概念"><a href="#第一节：基本概念" class="headerlink" title="第一节：基本概念"></a>第一节：基本概念</h3><img src="/2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/3-1.png" class><p>删去<strong>“前者时间换空间；后者空间换时间”</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【效率】如何用iPad辅助考研备考</title>
      <link href="2021/04/01/210401%E5%A6%82%E4%BD%95%E7%94%A8iPad%E8%BE%85%E5%8A%A9%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83/"/>
      <url>2021/04/01/210401%E5%A6%82%E4%BD%95%E7%94%A8iPad%E8%BE%85%E5%8A%A9%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic1.zhimg.com/80/v2-9e9dc0dc8a84987e296c0920261bc910_1440w.jpg" alt="img"></p><p>iPad长期以来被诟病——买前生产力，买后爱奇艺。考研过程中，我看到身边很多人确实是把iPad作为一种追剧的神器，而不是学习的利刃。我通过将近一年的使用，却用iPad做了不少事情，用来考研备考的辅助神器，真的是一个不错的选择，今天为大家分享一些我的使用方法。<strong>当然正如题主所说，iPad只是辅助，能否发挥其性能以及把其性能发挥到何种程度也要看个人。</strong></p><blockquote><p>装备：32GiPad2019+BOW可折叠键盘+Apple Pencil（发挥最大效能三者缺一不可）<br>本文将会介绍以下几个软件：<strong>OneNote、notability、Anki背诵神器、墨墨背单词软件、MarginNote2、欧路词典、Forest专注森林、B站万能学习资源、百度网盘</strong></p></blockquote><h2 id="第一｜OneNote（做笔记、计划、记录、总结等）"><a href="#第一｜OneNote（做笔记、计划、记录、总结等）" class="headerlink" title="第一｜OneNote（做笔记、计划、记录、总结等）"></a>第一｜OneNote（做笔记、计划、记录、总结等）</h2><p>本人算是一个OneNote重度用户了，考研期间的笔记、每日计划、每周总结、考研择校等等所有的东西，基本都是在OneNote上完成。OneNote的一些其他用法可以看看我的这个回答</p><h3 id="1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）"><a href="#1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）" class="headerlink" title="1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）"></a>1、考研每日计划（下面的这个视频<strong>是我制作的如何在OneNote制作每日计划模板教程）</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-219e72ec6055307ceb025c2cd01b4185_1440w.jpg" alt="img"></p><h3 id="2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。"><a href="#2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。" class="headerlink" title="2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。"></a>2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。</h3><p><img src="https://pic3.zhimg.com/80/v2-38614663c03722521a9e7f88195d097a_1440w.jpg" alt="img"></p><h3 id="3、每个月的总体规划"><a href="#3、每个月的总体规划" class="headerlink" title="3、每个月的总体规划"></a>3、每个月的总体规划</h3><p><img src="https://pic4.zhimg.com/80/v2-233b0b5cc2d20a621d97dcc7dc9aa2f3_1440w.jpg" alt="img"></p><h3 id="4、每周的总结"><a href="#4、每周的总结" class="headerlink" title="4、每周的总结"></a>4、每周的总结</h3><p><img src="https://pic2.zhimg.com/80/v2-96b1c453043a1d8a0971d39b1cc1b5e5_1440w.jpg" alt="img">每周的一个小总结，这是最后一个多月前的一次大总结</p><p>5、通过OneNote，我记录下自己考研过程中的每日点点滴滴，每周都会回头看看自己这周学习了哪些内容，还有哪些需要加强，还会整理自己的英语笔记、专业课笔记、政治笔记。</p><p>政治复习是花最少的时间，获得最高的分数，具体建议可以看看我的博客中关于政治复习建议的文章</p><p><img src="https://pic1.zhimg.com/80/v2-e61ca954717deec88167421407af99bc_1440w.jpg" alt="img">徐涛的30天背诵大作战，每天背一点</p><p><img src="https://pic1.zhimg.com/80/v2-35bab5b50fb4f34e2cc2715e59f845ac_1440w.jpg" alt="img">英语作文模板，自己通过很多其他优秀的模板整理出一份属于自己的模板，最终效果也不错</p><p>下面是专业课笔记（计算机网络、数据结构、计算机组成原理、操作系统），因为408科目比较多，所以需要整理出笔记方便自己的复习，针对笔记虽然会很有争议，但是还是要因人而异，尤其是针对内容较多的时候，笔记可以更好辅助复习。</p><p><img src="https://pic2.zhimg.com/80/v2-2c11080be72801a3baf7369412d04999_1440w.jpg" alt="img">操作系统笔记</p><p><img src="https://pic2.zhimg.com/80/v2-0c4a66e65bd08bb74bc9c23d20f245f1_1440w.jpg" alt="img">计算机网络笔记</p><p><img src="https://pic1.zhimg.com/80/v2-70e64827c965aa1a5c7d177ffad482d4_1440w.jpg" alt="img">还有数据结构笔记和计算机组成原理笔记</p><p><img src="https://pic4.zhimg.com/80/v2-a521e3bbd6d119009e062074416da787_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1f37d420b2c0058713f0d930ad2989ca_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-aad604278b4c225092f797a3e51123f4_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-43108766c4c1d52bffad75a7a4e4cdd0_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5c46076370d4547b0af45961f7b2bd8b_1440w.jpg" alt="img"></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="第二｜notability（标记、看PDF、整理笔记）"><a href="#第二｜notability（标记、看PDF、整理笔记）" class="headerlink" title="第二｜notability（标记、看PDF、整理笔记）"></a>第二｜notability（标记、看PDF、整理笔记）</h2><p>notability用来看PDF、做标记、整理笔记也是十分方便的，我主要用来完成做前两者的事情，如果再结合它的<strong>分屏功能</strong>简直是太棒了，就是iPad2019屏幕稍微有点小，不过也够用了。</p><p>notability手写、标记、荧光笔……等功能一定要用起来，我使用过好几款类似软件，但是最好用的还是这一款。</p><p><img src="https://pic2.zhimg.com/80/v2-7356d88f6c51cb6146ace5030bd68bed_1440w.jpg" alt="img">把OneNote里的笔记导出到notability，在上标记很方便</p><p><img src="https://pic2.zhimg.com/80/v2-54f5703ea2e1b21c6034ac0d4941acb1_1440w.jpg" alt="img">数学笔记，好多资料考后删了，内存不够，有点心疼</p><p><img src="https://pic2.zhimg.com/80/v2-06e50f547ce2df0ab182da64e083f4e1_1440w.jpg" alt="img">英语作文模板，考英语二，小作文背十篇基本就够了</p><p><img src="https://pic3.zhimg.com/80/v2-378423545490f6ccbec83c6de8b8f0b6_1440w.jpg" alt="img">这个是大作文模板，大作文要整理出来一份自己的模板，我的这一份用着感觉挺好的，考场发挥也不错啦</p><p><img src="https://pic1.zhimg.com/80/v2-4b82c015c019321d97b7d3ad4f559148_1440w.jpg" alt="img">政治很多资料都没必要买，可以看PDF版就好，特别是肖四，PDF版本会比纸质版提前3天出来，可以比别人早几天背诵，真的很重要</p><p><img src="https://pic1.zhimg.com/80/v2-970ab3ff6eb3c932e843998c3b76326c_1440w.jpg" alt="img">OneNote做出来的笔记，最终就是这样的，很方便，重点突出</p><p><img src="https://pic4.zhimg.com/80/v2-c9a741db8f5a1d1976fbba94edbfc753_1440w.jpg" alt="img">英语二大作文模板</p><p><strong>分屏功能</strong>：这个是nb和欧路词典，左边是英语文章，直接选中后复制就可以在右边出现翻译，对于英语学习来说简直是不可多得的利器，对于日后的研究生阅读论文帮助也很大。</p><p><img src="https://pic2.zhimg.com/80/v2-dac6d504608210ee808b416814b8ed41_1440w.jpg" alt="img"></p><h2 id="第三｜Anki背诵神器（强推，背英语单词、背政治题目）"><a href="#第三｜Anki背诵神器（强推，背英语单词、背政治题目）" class="headerlink" title="第三｜Anki背诵神器（强推，背英语单词、背政治题目）"></a><strong>第三｜Anki背诵神器（强推</strong>，背英语单词、背政治题目）</h2><p>遇到这款神器真是幸运，政治选择题能够拿到40+，真当是多亏这款软件了，用来做《肖1000题》、《各位名师的模拟题》大概做了40+套，重复很多遍，关键是为我节省了很多时间。*<strong>我今年也建立了一个Anki卡组免费共享裙，欢迎大家一起交流学习，可以直接看我主页“想法”第一条就是有图片可以扫描进入。*</strong></p><p><strong><em>注意：这款工具安卓、电脑均可使用，进群有安装包可以下载使用\</em></strong></p><p><img src="https://pic4.zhimg.com/80/v2-5fd56e965f0fca8894f58cd38cb216b3_1440w.jpg" alt="img">这个是我用到的模拟题</p><p><img src="https://pic2.zhimg.com/80/v2-7762737e6e031645f194ac4bd340d04d_1440w.jpg" alt="img">感谢各位大佬制作的Anki卡组，用起来很方便</p><h2 id="第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）"><a href="#第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）" class="headerlink" title="第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）"></a>第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）</h2><p>我试过很多款市面上流行的背单词软件，但是最喜欢的还是墨墨背单词，最大的特点就是根据“艾宾浩斯遗忘曲线”来帮助你重复背诵单词，其他软件这一点做的不是很好，缺点就是需要买单词上线，我当时买了8800个。</p><p><img src="https://pic2.zhimg.com/80/v2-ee3ab22400f2326f665b38e58721b8fd_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-0efdb35f4f58782210d17175a3f4fc96_1440w.jpg" alt="img"></p><h2 id="第五｜MarginNote2（可以把PDF标记之后直接生成PDF）"><a href="#第五｜MarginNote2（可以把PDF标记之后直接生成PDF）" class="headerlink" title="第五｜MarginNote2（可以把PDF标记之后直接生成PDF）"></a>第五｜MarginNote2（可以把PDF标记之后直接生成PDF）</h2><p>这个软件可以把你的标记生成思维导图，这一点还是很好用的，对于文科的学生我感觉帮助会更大一点，我用到比较少，据说生成的思维导图可以制作成卡片直接导入Anki中，尝试几次都没有成功。以后有机会再做尝试吧！</p><p><img src="https://pic3.zhimg.com/80/v2-bb0d075ac85759725e75eca4d5fd483a_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-963e5e817cdb4c257c3797b7dbed4e7c_1440w.jpg" alt="img"></p><h2 id="第六｜欧路词典（查生词）"><a href="#第六｜欧路词典（查生词）" class="headerlink" title="第六｜欧路词典（查生词）"></a>第六｜欧路词典（查生词）</h2><p>欧路词典有三个特点：一个是可以自己导入词典；一个是你可以利用iPad的分屏功能，在一个软件上直接划词复制之后，就会在欧路词典上出现这个词语的意思，非常方便；第三个功能是每次查词之后都可以加入生词本，然后你可以像墨墨单词那样复习一样；</p><p><img src="https://pic2.zhimg.com/80/v2-84533fa69f8cf0391199f1ce91a7a1ed_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-6fd7edf487fbbe0012b7cf319a8c061e_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-cf14c10f886bf7952c5ba6feea1f4a0e_1440w.jpg" alt="img"></p><h2 id="第七｜Forest专注森林（学习时种树，让自己变得更加专注）"><a href="#第七｜Forest专注森林（学习时种树，让自己变得更加专注）" class="headerlink" title="第七｜Forest专注森林（学习时种树，让自己变得更加专注）"></a>第七｜Forest专注森林（学习时种树，让自己变得更加专注）</h2><p>很多人都控制不住自己，总是会玩iPad，所以你可以在自己学习的时候在Forest专注森林里面种树，也可以邀请其他小伙伴一起种树，如果其中一个人退出软件就会导致双方的树枯萎。</p><p><img src="https://pic3.zhimg.com/80/v2-25af2266b51dc12586ab59694b3043ea_1440w.jpg" alt="img"></p><h2 id="第八｜B站（传说中的学习万能宝库，什么资源都有）"><a href="#第八｜B站（传说中的学习万能宝库，什么资源都有）" class="headerlink" title="第八｜B站（传说中的学习万能宝库，什么资源都有）"></a>第八｜B站（传说中的学习万能宝库，什么资源都有）</h2><p>B站的学习功能就不用说了，这个是有目共睹。</p><h2 id="第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）"><a href="#第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）" class="headerlink" title="第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）"></a><strong>第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）</strong></h2><p>百度网盘也是用的比较多的，我往往都是前一天晚上开始缓存，然后第二天就可以倍速观看了，如果没有提前缓存下来需要开通会员才可以使用倍速观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】政治考研复习建议</title>
      <link href="2021/04/01/210401%E6%94%BF%E6%B2%BB%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"/>
      <url>2021/04/01/210401%E6%94%BF%E6%B2%BB%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>20上岸，旱区（北上地区）政治75+，还算一个不错的分数；这篇帖子不仅仅是经验分享，更是一篇备考指导，让你可用最少的时间和精力，获得更多的分数，大家请根据自己的情况进行调整复习。</p><p><img src="https://pic2.zhimg.com/80/v2-137341f9506ac1289248d62ac6ee22ed_1440w.jpg" alt="img"></p><h3 id="一、欲拿高分，思想先行"><a href="#一、欲拿高分，思想先行" class="headerlink" title="一、欲拿高分，思想先行"></a><strong>一、欲拿高分，思想先行</strong></h3><p>考研过程中，只有政治可以说是几乎所有人的基础都是一样的——零基础，但是最后政治依然会有人拿到高分，而有人是50分低分飘过，究其原因，就是方法的失当和努力的缺失，更加重要的先入为主的错误思想。</p><p>这些错误思想包括：“政治是一门玄学”，“政治大家分数都差不多，拉不开分”，“政治只要能考60分就可以了”…………这些思想，在考研期间真是听了不知多少遍，其共同之处都是对政治的不重视。就拿“政治能否拉开分数来说”，诸位可以任意找几所学院的复试名单，看政治分数第一名与最后一名的分数差距便可知道，基本可以相差二十分以上，试问在考研过程中20分是个什么样的概念！！！关键是这20分的提升可能只需要四五十个小时便可以完成。</p><p>我们也完全可以把英语与政治对比一下，英语基础的好坏对你成绩的影响是非常大的，有的人可以轻轻松松考到80分，而有的人努力大半年也只能考50分，这就是差距。政治备考，如若可以重视起来，认真准备，并且善于利用我下面提供的一款软件Anki，拿到75+的分数并非不可能。</p><h3 id="二、书籍推荐、省时省；做好计划、心中有数；"><a href="#二、书籍推荐、省时省；做好计划、心中有数；" class="headerlink" title="二、书籍推荐、省时省；做好计划、心中有数；"></a><strong>二、书籍推荐、省时省；做好计划、心中有数；</strong></h3><h4 id="（一）书籍推荐"><a href="#（一）书籍推荐" class="headerlink" title="（一）书籍推荐"></a><strong>（一）书籍推荐</strong></h4><p>考研花钱，政治最花钱，买书是最多的，但是很多书完全可以不用买，因为只需要看一下PDF就可以了，但是有些必须要买。<strong>因为我用的是肖秀荣的书，所以就以他的整套书为例，如果你用的是其他老师的书，也可以进行对比。</strong>每个老师的图书系列都是差不多的，无论跟哪个老师都可以，基本上考研政治这几位名师都是很不错的，选择了就请相信。</p><p><img src="https://pic1.zhimg.com/80/v2-4037681b96edbfa76a7f8c5ff28affac_1440w.jpg" alt="img"></p><p>考研毕竟是要花钱的，不要想着所有的书都看PDF，这是绝对行不通的，能帮你省点钱都帮你省了，如果实在拮据，就去闲鱼看看必买的书籍吧！</p><p>注意：其他老师的模拟卷，不用买，全部使用我下文提到的Anki背诵软件即可，但是需要网上找相关的模拟卷卡组导入，如果私信我的人多，我可以建立一个Anki卡组资料共享群；</p><h4 id="（二）关于计划"><a href="#（二）关于计划" class="headerlink" title="（二）关于计划"></a>（二）关于计划</h4><p>考研需要有一个整体的计划，你哪个时期该做什么？做到什么程度？自己心中都应该有数，最好能够以计划的形式写出来。</p><p><img src="https://pic4.zhimg.com/80/v2-575240b2779bd61a391ca5b9edd459b3_1440w.jpg" alt="img"></p><p>我根据自己的帖子，做一个大致的计划，稍微前后提前或者推迟半个月，不能太多，太早复习时间有点早，太晚复习选择题部分不能保证40+。政治是一门投入产出比最大的课程，如果你三四月份就开始复习，可能到最后和人家八九月份复习的人来说没有太大的分数区别；但是如果太晚复习我是十分不建议的，有的人会十一月才开始复习政治，你连政治的基础概念都无法全部理解，可能会有很多人说自己复习的很晚但是依然拿到不错的分数，但是这样还是太冒险，非常不建议。</p><p><img src="https://pic4.zhimg.com/80/v2-a61561988a2e3eb0c71fcf37a848e993_1440w.jpg" alt="img"></p><p><strong>改：9月-一轮复习 毛概、思修基础知识</strong></p><h3 id="三、一轮复习，掌握方法"><a href="#三、一轮复习，掌握方法" class="headerlink" title="三、一轮复习，掌握方法"></a><strong>三、一轮复习，掌握方法</strong></h3><p><strong>复习资料</strong>：《精讲精练》+《徐涛视频》+《1000题》</p><p><strong>复习方法</strong>：《精讲精练》快速过一遍，看视频，边看边理解书上的内容（也就马原需要理解，其他三科只需要记忆），看完视频再看一遍书，开始做《1000题》，错误的地方做个标记，尤其是马原部分，因为还要二刷；</p><p><strong>复习时间：</strong>我建议的开始复习政治的时间是：8月中旬前后开始，不能太晚，太晚很多基础的东西复习不完了，到最后做模拟冲刺卷的时候，你会发现自己很多基础的知识题都会出错。这轮复习下来大概需要2个月左右；</p><p>政治分为马原、毛概、史纲、思修，其中马原是最难理解的，大家都是零基础，建议结合徐涛的视频来复习，看视频的时候用1.5的倍速观看，每个视频的时间都不长，倍速之后也就二十分钟。徐涛的视频讲的很有意思，很多人都喜欢看，而且越看越想看，而且看的时候就像在看综艺节目，很开心<strong>，但是开心的同时是否学到了东西却是值得商榷的</strong>，很多人到最后只记得看视频却忘记学习知识，这个大家需要注意。我个人认为：<strong>除了马原必须要看视频之外，其他三科完全可以选择不看</strong>，因为其他三科都是基本的知识，理解的地方很少，<strong>如果看的话建议两倍速</strong>；</p><h3 id="四、二轮复习，借助Anki，结合核心考点"><a href="#四、二轮复习，借助Anki，结合核心考点" class="headerlink" title="四、二轮复习，借助Anki，结合核心考点"></a><strong>四、二轮复习，借助Anki，结合核心考点</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-68753fee2a0813b9a72423b34b21bd9c_1440w.jpg" alt="img"></p><p><strong>复习资料</strong>：<u>《1000题》+Anki记忆软件+《风中劲草核心考点》+《精讲精练》</u></p><p><strong>复习方法做题部分</strong>：《1000题》肯定是需要至少两遍，第二遍做题，只需要马原部分用到《1000题》，毛概、史纲、思修的《1000题》复习，我推荐使用<strong>Anki背诵软件</strong>，这个《1000题》的卡组可以在官网上找到资料分享。做题部分其实并不需要完全与第二轮分开，你可以先复习马原、毛概并完成相应的题目，等你复习史纲的时候就可以回过头来做第二遍马原的题目，当然也可以等第一轮完全结束的时候在开始第二遍做题。</p><p><strong>复习方法-《风中劲草》如何使用</strong>：风中劲草这本书的好处是内容简介、多种颜色标记、重点清晰，这本书用来第二轮复习，可以看完一章或者看完整个科目之后就刷第二遍题目。风中劲草需要前前后后看四遍左右，2-3天就可以完成一轮复习。</p><h3 id="五、三轮复习、多做模拟题的选择题部分"><a href="#五、三轮复习、多做模拟题的选择题部分" class="headerlink" title="五、三轮复习、多做模拟题的选择题部分"></a>五<strong>、三轮复习、多做模拟题的选择题部分</strong></h3><p>这个过程你需要做30-40套模拟题，大家不要以为30套模拟题很多，其实很少，因为每套模拟题只需要做选择题就可以了，基本一套也就二十多分钟就可以做完了。主要是多选部分，多选拿到高分，选择题才能拿到高分，想要拿75+，多选需要保证40+，这样把握更大；</p><p><strong>复习资料</strong>：<u>各位老师的模拟题+时政+近五年《真题》</u></p><p><strong>模拟题复习方法</strong>：大概在十一月下旬开始，就会有各种老师的模拟题出版，记住，只需要买《肖八》和《肖四》，其他的模拟题全部都用Anki背诵软件来做题，Anki背诵就类似于墨墨单词软件，采用的是艾宾浩斯遗忘曲线来辅助。我推荐使用Anki的原因并不是省钱，而是它可以帮助你短期内把这些试卷做三遍以上，而且花的时间会比你买试卷做题少很多。注意：《肖八》需要好好做，可以先只做选择题部分，做完一整套试卷就对答案，然后把每个选项中不懂得部分都翻书看一下；</p><p><img src="https://pic2.zhimg.com/80/v2-edc9e2ce1ab349c017d2244995535e95_1440w.jpg" alt="img"></p><p><strong>时政复习方法</strong>：时政选择题也占6分，但是根据20年的情况可以发现，时政选择题远远超过了6分，而且很多题目都会和时政结合起来出题。时政可以看看肖老师的《时政小册子》，微博上会有很多人分享自己整理的时政，以及各种考研公众号也会整理出来，<strong>你要广泛搜集这些他们整理的，就不用自己整理了，找来打印出来记住就可以了；</strong></p><p><strong>真题复习方法</strong>：真题是一定要做的，你最起码要做完最近五年的真题，分析一下命题人是如何设置陷阱，同时也要看一下分析题的答题方法，保证能够拿到最多的分数。</p><h3 id="六、四轮复习、冲刺分析题"><a href="#六、四轮复习、冲刺分析题" class="headerlink" title="六、四轮复习、冲刺分析题"></a><strong>六、四轮复习、冲刺分析题</strong></h3><p><strong>复习资料</strong>：<u>《肖四》（如果你跟的其他老师就选择其他老师的资料）</u></p><p><strong>复习方法</strong>：分析题占比50分，但是却是最容易拿到的，我身边的大多数人都是在最后15-20天开始准备分析题，分析题我用的是《肖四》，其实每个老师押题都是能够压中的，但是绝对很难做到全部压中题目，有的老师可能用50个题目去压考研的5个题，而有的老师却只用三十个题目就可以压中，肖老师在考研政治中的名气大家都有所耳闻，最后只用几页A4纸就可以搞定，性价比高，拿分也高。这个阶段，你狂背肖四就可以了，当然也可以背其他老师的押题卷，看个人喜好。</p><p>但是要记住，无论是哪个老师，都无法做到全部压中原题，所以在考场上遇到你没有背到的题目，就要从材料中去找答案，你翻看一下就会发现每一题的材料都会给整个A4纸那么多的内容，答案都会隐藏在材料中，要多去材料中找到答案，进行归纳总结。</p><hr><h3 id="补充与答疑"><a href="#补充与答疑" class="headerlink" title="补充与答疑"></a>补充与答疑</h3><h4 id="补充一：《1000题》怎么用"><a href="#补充一：《1000题》怎么用" class="headerlink" title="补充一：《1000题》怎么用"></a><strong>补充一：《1000题》怎么用</strong></h4><p>1、《1000题》需要做不止一遍，如果只用纸质版，想要做2遍花费的时间就无法想象，但是如果使用Anki背诵的话，做3-4遍所花费的时间都比纸质版2遍要少很多，所以我还是推荐第一遍做纸质版，之后就用Anki背诵神器来记忆；</p><p>2、第一遍做题方法：看完视频和基础知识之后就做本章节对应的《1000题》，做题的时候需要记住，一定要做错题标记，一是为了能够统计错题率，二是能够后面回头复习的时候看到自己做错的题目，方便复习；</p><p>第一遍做题错误率会很高，这个不要担心，毕竟是刚开始，后面会降下来的；</p><p>3、<strong>第二遍做《1000题》：这里是重点，一定要认真看。</strong></p><p>马原部分涉及到哲学，还是有一定难度，需要理解，我建议再把纸质版的《1000题》做第二遍，之后再使用Anki做马原的题目就会感觉到如鱼得水；</p><p>毛中特、史纲、思修第二遍就可以直接使用Anki做题，你会发现做一段时间之后你对知识的理解以及做题的速度都会优于身边人。</p><hr><p><strong>本文首发于我的知乎账号</strong>：上海地区政治77，考研政治复习指导 - 后羿的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/145769562">https://zhuanlan.zhihu.com/p/145769562</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 经验贴 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

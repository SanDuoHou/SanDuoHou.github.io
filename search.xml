<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第276场周赛</title>
      <link href="2022/01/16/220116-276%E5%91%A8%E8%B5%9B/"/>
      <url>2022/01/16/220116-276%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-5980-将字符串拆分为若干长度为-k-的组"><a href="#1-5980-将字符串拆分为若干长度为-k-的组" class="headerlink" title="1.5980. 将字符串拆分为若干长度为 k 的组"></a>1.<a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">5980. 将字符串拆分为若干长度为 k 的组</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>字符串 s 可以按下述步骤划分为若干长度为 k 的组：</p><p>第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。<br>对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。<br>注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。</p><p>给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdefghi&quot;, k &#x3D; 3, fill &#x3D; &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;]</span><br><span class="line">解释：</span><br><span class="line">前 3 个字符是 &quot;abc&quot; ，形成第一组。</span><br><span class="line">接下来 3 个字符是 &quot;def&quot; ，形成第二组。</span><br><span class="line">最后 3 个字符是 &quot;ghi&quot; ，形成第三组。</span><br><span class="line">由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。</span><br><span class="line">因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abcdefghij&quot;, k &#x3D; 3, fill &#x3D; &quot;x&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;]</span><br><span class="line">解释：</span><br><span class="line">与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。</span><br><span class="line">对于最后一组，字符串中仅剩下字符 &#39;j&#39; 可以用。为了补全这一组，使用填充字符 &#39;x&#39; 两次。</span><br><span class="line">因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; s.length &lt;&#x3D; 100</span><br><span class="line">s 仅由小写英文字母组成</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; 100</span><br><span class="line">fill 是一个小写英文字母</span><br></pre></td></tr></table></figure><h2 id="解法：简单模拟"><a href="#解法：简单模拟" class="headerlink" title="解法：简单模拟"></a>解法：简单模拟</h2><p>首先判断一下长度，然后把需要填充的fill数量计算出来并加进去，最后遍历每k个输出即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divideString</span>(<span class="params">self, s: str, k: int, fill: str</span>) -&gt; List[str]:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        m = n % k</span><br><span class="line">        s += fill * (k - m)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n, k):</span><br><span class="line">            ans.append(s[i:i+k])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="2-5194-得到目标值的最少行动次数"><a href="#2-5194-得到目标值的最少行动次数" class="headerlink" title="2.5194. 得到目标值的最少行动次数"></a>2.<a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">5194. 得到目标值的最少行动次数</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。</p><p>在一次行动中，你可以做下述两种操作之一：</p><p>递增，将当前整数的值加 1（即， x = x + 1）。<br>加倍，使当前整数的值翻倍（即，x = 2 * x）。<br>在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。</p><p>给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 5, maxDoubles &#x3D; 0</span><br><span class="line">输出：4</span><br><span class="line">解释：一直递增 1 直到得到 target 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 19, maxDoubles &#x3D; 2</span><br><span class="line">输出：7</span><br><span class="line">解释：最初，x &#x3D; 1 。</span><br><span class="line">递增 3 次，x &#x3D; 4 。</span><br><span class="line">加倍 1 次，x &#x3D; 8 。</span><br><span class="line">递增 1 次，x &#x3D; 9 。</span><br><span class="line">加倍 1 次，x &#x3D; 18 。</span><br><span class="line">递增 1 次，x &#x3D; 19 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：target &#x3D; 10, maxDoubles &#x3D; 4</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">最初，x &#x3D; 1 。 </span><br><span class="line">递增 1 次，x &#x3D; 2 。 </span><br><span class="line">加倍 1 次，x &#x3D; 4 。 </span><br><span class="line">递增 1 次，x &#x3D; 5 。 </span><br><span class="line">加倍 1 次，x &#x3D; 10 。 </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; target &lt;&#x3D; 10**9</span><br><span class="line">0 &lt;&#x3D; maxDoubles &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><h2 id="解法：反向dp"><a href="#解法：反向dp" class="headerlink" title="解法：反向dp"></a>解法：反向dp</h2><p>刚开始想着能不能用回溯做，结果是正确的，但是超时，因为数据比较大10**9；后来想着用动态规划，结果正确，但是会超时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">        dp[int(target / <span class="number">2</span>)] = dp[target] + <span class="number">1</span></span><br><span class="line">        target = int(target / <span class="number">2</span>)</span><br><span class="line">        maxDoubles -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dp[target - <span class="number">1</span>] = min(dp[target] + <span class="number">1</span>, dp[target - <span class="number">1</span>])</span><br><span class="line">        target -= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>就想着优化，需要从后面出发（原来的乘以2变为除以2，原来的加1变为减1），遇到合适的就先利用double除以2，不合适的就递减即可。</p><p>如果走到中间maxDoubles用完了，就说明剩下的全部都是-1操作，直接跳出循环即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minMoves</span>(<span class="params">self, target: int, maxDoubles: int</span>) -&gt; int:</span></span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> target &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> target % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">                pre = pre + <span class="number">1</span></span><br><span class="line">                target = int(target / <span class="number">2</span>)</span><br><span class="line">                maxDoubles -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> maxDoubles &gt; <span class="number">0</span>:</span><br><span class="line">                pre = pre + <span class="number">1</span></span><br><span class="line">                target -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> maxDoubles == <span class="number">0</span>:</span><br><span class="line">                pre += target - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><h1 id="3-5982-解决智力问题"><a href="#3-5982-解决智力问题" class="headerlink" title="3.5982. 解决智力问题"></a>3.<a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">5982. 解决智力问题</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。</p><p>这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得  pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。</p><p>比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ：<br>如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。<br>如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。<br>请你返回这场考试里你能获得的 最高 分数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions &#x3D; [[3,2],[4,3],[4,4],[2,5]]</span><br><span class="line">输出：5</span><br><span class="line">解释：解决问题 0 和 3 得到最高分。</span><br><span class="line"></span><br><span class="line">- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 1 和 2</span><br><span class="line">- 解决问题 3 ：获得 2 分</span><br><span class="line">  总得分为：3 + 2 &#x3D; 5 。没有别的办法获得 5 分或者多于 5 分。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：questions &#x3D; [[1,1],[2,2],[3,3],[4,4],[5,5]]</span><br><span class="line">输出：7</span><br><span class="line">解释：解决问题 1 和 4 得到最高分。</span><br><span class="line">- 跳过问题 0</span><br><span class="line">- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。</span><br><span class="line">- 不能解决问题 2 和 3</span><br><span class="line">- 解决问题 4 ：获得 5 分</span><br><span class="line">  总得分为：2 + 5 &#x3D; 7 。没有别的办法获得 7 分或者多于 7 分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; questions.length &lt;&#x3D; 105</span><br><span class="line">questions[i].length &#x3D;&#x3D; 2</span><br><span class="line">1 &lt;&#x3D; pointsi, brainpoweri &lt;&#x3D; 105</span><br></pre></td></tr></table></figure><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>第三题和第二题，解决思路是差不多的，因为都存在一个选择和不选择问题，就想着用回溯，结果是不行的；然后就用动态规划，超出时间限制，就需要不停优化。这个题目没有做出来，参考了一下其他人的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span>(<span class="params">self, questions: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(questions)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            q = questions[i]</span><br><span class="line">            j = i + q[<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            dp[i] = max(dp[i + <span class="number">1</span>], q[<span class="number">0</span>] + (dp[j] <span class="keyword">if</span> j &lt; n <span class="keyword">else</span> <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>下面这个解法就是递归（回溯），用的非常好，但是更好的地方是用了一个@functools.lru_cache(None)，还是第一次遇到，如果没有这一行代码是无法通过的，会超时，用了之后就可以通过。</p><p>在functools这个模块中，有lru_cache这个一个神奇的<a href="https://so.csdn.net/so/search?q=%E8%A3%85%E9%A5%B0%E5%99%A8&spm=1001.2101.3001.7020">装饰器</a>存在。functools.lru_cache的作用主要是用来做缓存，他能把相对耗时的函数结果进行保存，避免传入相同的参数重复计算。同时，缓存并不会无限增长，不用的缓存会被释放。</p><p>具体用法可以参考这里：<a href="https://blog.csdn.net/wzqnls/article/details/78506022">https://blog.csdn.net/wzqnls/article/details/78506022</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostPoints</span>(<span class="params">self, questions: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line"><span class="meta">        @functools.lru_cache(None)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">t=<span class="number">0</span></span>) :</span></span><br><span class="line">            <span class="keyword">if</span> t &gt;= len(questions) :</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            points, brainpower = questions[t]</span><br><span class="line">            <span class="keyword">return</span> max(points+solve(t+brainpower+<span class="number">1</span>), solve(t+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> solve()</span><br></pre></td></tr></table></figure><p>第四题有时间就整理吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解：堆（优先队列）应用</title>
      <link href="2022/01/15/220115%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/"/>
      <url>2022/01/15/220115%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-堆的相关操作"><a href="#1-堆的相关操作" class="headerlink" title="1. 堆的相关操作"></a>1. 堆的相关操作</h1><table><thead><tr><th>函 数</th><th>函 数</th></tr></thead><tbody><tr><td>heappush(heap, x)</td><td>将x压入堆中</td></tr><tr><td>heappop(heap)</td><td>从堆中弹出最小的元素</td></tr><tr><td>heapify(heap)</td><td>让列表具备堆特征</td></tr><tr><td>heapreplace(heap, x)</td><td>弹出最小的元素，并将x压入堆中</td></tr><tr><td>nlargest(n, iter)</td><td>返回iter中n个最大的元素</td></tr><tr><td>nsmallest(n, iter)</td><td>返回iter中n个最小的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># 将x压入堆中</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="comment"># 建立堆，把列表的元素放如到堆heap中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="comment"># 把元素压入到堆中</span></span><br><span class="line">    heapq.heappush(heap, x[i])</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 从堆中弹出最小的元素</span></span><br><span class="line">print(heapq.heappop(heap))</span><br><span class="line"><span class="comment"># 通过heapify建立堆，可以执行尽可能少的操作</span></span><br><span class="line">heap = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 弹出最小的元素，并将10压入堆中</span></span><br><span class="line">heapq.heapreplace(heap, <span class="number">10</span>)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 返回heap中n=4个最大的元素</span></span><br><span class="line">print(heapq.nlargest(<span class="number">4</span>, heap))</span><br><span class="line"><span class="comment"># 返回iter中n=3个最小的元素</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">4</span>, heap))</span><br></pre></td></tr></table></figure><h1 id="2-面试题-17-09-第-k-个数"><a href="#2-面试题-17-09-第-k-个数" class="headerlink" title="2.面试题 17.09. 第 k 个数"></a>2.<a href="https://leetcode-cn.com/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: k &#x3D; 5</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><h2 id="解法一：堆"><a href="#解法一：堆" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>题目已经指定素因子只有3，5，7三个数字，我们先把这三个数字压入堆中，每次弹出一个数字，然后把弹出的数字分别乘3，5，7再压入堆中，以此类推即可。</p><p>需要注意的是，压入堆中的元素会存在重复，例如弹出3的时候会压入9，15，21；弹出5的时候，会压入15，25，35；这里就会存在15的重复。</p><p>所以我们每次弹出一个最小元素的时候，需要判断一下堆中当前最小元素与之前弹出的最小元素是否相等，如果相等就需要把其弹出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthMagicNumber</span>(<span class="params">self, k: int</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> res == heap[<span class="number">0</span>]:  <span class="comment">#去除重复元素</span></span><br><span class="line">                <span class="comment"># 我们只需要往里面加元素即可，当弹出最小元素的时候，我们判断弹出的元素与堆最小的第元素是否相等</span></span><br><span class="line">                <span class="comment"># 如果相等就继续弹出，直至不想等</span></span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            <span class="comment"># 把当前元素的相关元素压入堆中</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]:</span><br><span class="line">                heapq.heappush(heap, res * num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划（三指针）"><a href="#解法二：动态规划（三指针）" class="headerlink" title="解法二：动态规划（三指针）"></a>解法二：动态规划（三指针）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getKthMagicNumber</span>(<span class="params">self, k: int</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        idx3, idx5, idx7 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            a, b, c = res[idx3] * <span class="number">3</span>, res[idx5] * <span class="number">5</span>, res[idx7] * <span class="number">7</span></span><br><span class="line">            res.append(min(a, b, c))</span><br><span class="line">            <span class="comment"># 三个if一定要都执行，不能够用elif，这样就可以保证如果有相同的数字，都可以执行+1操作</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == a:</span><br><span class="line">                idx3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == b:</span><br><span class="line">                idx5 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == c:</span><br><span class="line">                idx7 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-264-丑数-II"><a href="#3-264-丑数-II" class="headerlink" title="3.264. 丑数 II"></a>3.<a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p><p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 1690</span><br></pre></td></tr></table></figure><h2 id="解法一：堆-1"><a href="#解法一：堆-1" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>方法和上面一题一模一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> res == heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]:</span><br><span class="line">                heapq.heappush(heap, res * num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划（三指针）-1"><a href="#解法二：动态规划（三指针）-1" class="headerlink" title="解法二：动态规划（三指针）"></a>解法二：动态规划（三指针）</h2><p>这个思路不是很好想出来。</p><p>可以这样理解：</p><p>初始的时候，idx2, idx3, idx5 = 0, 0, 0，第一轮之后会把2加入到队列，然后</p><table><thead><tr><th></th><th>a,b,c</th><th>res</th><th>idx2， idx3， idx5</th></tr></thead><tbody><tr><td>初始的时候</td><td></td><td>1</td><td>0， 0， 0</td></tr><tr><td>第一轮</td><td>2，3，5</td><td>1，2</td><td>1， 0， 0</td></tr><tr><td>第二轮</td><td>4，3，5</td><td>1，2，3</td><td>1，1，0</td></tr><tr><td>第三轮</td><td>4，6，5</td><td>1，2，3，5</td><td>1，1，1</td></tr></tbody></table><p>这样推导一下就可以很清晰看出来，每次用idx2， idx3， idx5来标记当前需要加入的最小值，而且保证每个数都可以乘2，3，5，只是先后顺序受到控制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        idx2, idx3, idx5 = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            a, b, c = res[idx2] * <span class="number">2</span>, res[idx3] * <span class="number">3</span>, res[idx5] * <span class="number">5</span></span><br><span class="line">            res.append(min(a, b, c))</span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == a:</span><br><span class="line">                idx2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == b:</span><br><span class="line">                idx3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[<span class="number">-1</span>] == c:</span><br><span class="line">                idx5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="4-313-超级丑数"><a href="#4-313-超级丑数" class="headerlink" title="4.313. 超级丑数"></a>4.<a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p><p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p><p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12, primes &#x3D; [2,7,13,19]</span><br><span class="line">输出：32 </span><br><span class="line">解释：给定长度为 4 的质数数组 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 1, primes &#x3D; [2,3,5]</span><br><span class="line">输出：1</span><br><span class="line">解释：1 不含质因数，因此它的所有质因数都在质数数组 primes &#x3D; [2,3,5] 中。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 106</span><br><span class="line">1 &lt;&#x3D; primes.length &lt;&#x3D; 100</span><br><span class="line">2 &lt;&#x3D; primes[i] &lt;&#x3D; 1000</span><br><span class="line">题目数据 保证 primes[i] 是一个质数</span><br><span class="line">primes 中的所有值都 互不相同 ，且按 递增顺序 排列</span><br></pre></td></tr></table></figure><h2 id="解法一：堆（超出时间限制）"><a href="#解法一：堆（超出时间限制）" class="headerlink" title="解法一：堆（超出时间限制）"></a>解法一：堆（超出时间限制）</h2><p>思路和上面讲的一模一样。</p><p>时间超时，应该是不太好优化了，尝试了第二种方法优化，减少了一些执行次数，但是还是不能够通过，参考几个解答可能都是之前的解法，后面增加了测试数据之后，还是无法通过，但是整体的思路是正确的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">while</span> heap <span class="keyword">and</span> res == heap[<span class="number">0</span>]:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> primes:</span><br><span class="line">                heapq.heappush(heap, res * num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        seen = &#123;<span class="number">1</span>&#125; <span class="comment"># 把已经出现的数字加入进来，防止重复加入</span></span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> primes:</span><br><span class="line">                next_ = res * num</span><br><span class="line">                <span class="keyword">if</span>  next_ <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                    heapq.heappush(heap, next_)</span><br><span class="line">                    seen.add(next_)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h2><p>这个题和上面的丑数2类似，但是现在因子变成了一个动态的primes，所以需要我们转变一下思路，设置一个index来标记每个因子的位置代替上面的idx，设置一个nums来代替上面的abc，依然是从nums中取出一个最小的加入到res中，然后把idx对应+1操作。</p><p>但是不能够用两层循环来实现，因为会出现超时的情况，下面这个版本就是把nums和index分开循环，最终提交的结果会超时报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        m = len(primes)</span><br><span class="line">        index = [<span class="number">0</span>] * m</span><br><span class="line">        nums = [<span class="number">1</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                nums[j] = res[index[j]] * primes[j]</span><br><span class="line">            min_ = min(nums)</span><br><span class="line">            res.append(min_)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == min_:</span><br><span class="line">                    index[j] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>既然思路已经有了，我们就可以想办法进行优化，依然是上面的思路，我们把第二层for循环合并为一个，只要我们初始化的时候先把nums最小值放进来，然后再同时执行index+1操作以及求下一次的nums就可以完美解决这个问题了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthSuperUglyNumber</span>(<span class="params">self, n: int, primes: List[int]</span>) -&gt; int:</span></span><br><span class="line">        res = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        m = len(primes)</span><br><span class="line">        index = [<span class="number">0</span>] * m</span><br><span class="line">        nums = [<span class="number">1</span>] * m</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            min_ = min(nums)</span><br><span class="line">            res[i] = min_</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == min_:</span><br><span class="line">                    index[j] += <span class="number">1</span></span><br><span class="line">                    nums[j] = res[index[j]] * primes[j]</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 堆（优先队列） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解：求“第k小”相关问题</title>
      <link href="2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></p><p><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></p><p><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></p><p><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a></p><p><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></p><p><a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></p><h1 id="1-378-有序矩阵中第-K-小的元素"><a href="#1-378-有序矩阵中第-K-小的元素" class="headerlink" title="1.378. 有序矩阵中第 K 小的元素"></a>1.<a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8</span><br><span class="line">输出：13</span><br><span class="line">解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix &#x3D; [[-5]], k &#x3D; 1</span><br><span class="line">输出：-5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n &#x3D;&#x3D; matrix.length</span><br><span class="line">n &#x3D;&#x3D; matrix[i].length</span><br><span class="line">1 &lt;&#x3D; n &lt;&#x3D; 300</span><br><span class="line">-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109</span><br><span class="line">题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; n**2</span><br></pre></td></tr></table></figure><h2 id="解法一：暴力求解"><a href="#解法一：暴力求解" class="headerlink" title="解法一：暴力求解"></a>解法一：暴力求解</h2><p>暴力求解很简单，只需要把二维数组降维为一维数组，然后排序返回结果即可；</p><p><strong>sum(matrix, [])这个是直接降维的方法，后面遇到类似的记得学习。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        nums = sorted(sum(matrix, []))</span><br><span class="line">        <span class="keyword">return</span> nums[k<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：使用堆来解决问题"><a href="#解法二：使用堆来解决问题" class="headerlink" title="解法二：使用堆来解决问题"></a>解法二：使用堆来解决问题</h2><p>关于堆的方法讲解可以参考下面这个题解，非常详细。</p><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/shi-yong-dui-heapde-si-lu-xiang-jie-ling-fu-python/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/shi-yong-dui-heapde-si-lu-xiang-jie-ling-fu-python/</a></p><p>大致思想就是，每次我们都从matrix中选择一个最小的元素弹出，当弹出到第k个的时候就是我们需要的。因此我们需要用堆来维护<strong>一组最小候选人</strong>，每次弹出一个最小的，就把最小元素的下一个元素加入到堆中，这样就继续从堆中选择最小元素弹出即可。</p><p>我们选取第一列作为最小候选人，第一列的每一个元素都是当前行最小的元素，每次弹出一个元素，然后把该行的下一个元素加入到堆中，知道弹出k个元素为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(matrix) <span class="comment">#注：题目中这个矩阵是n*n的，所以长宽都是n</span></span><br><span class="line">        <span class="comment">#取出第一列候选人，每个候选人组成一个三元组，当前元素以及当前元素的位置</span></span><br><span class="line">        <span class="comment">#matrix[i][0]是具体的值，后面的(i,0)是在记录候选人在矩阵中的位置，方便每次右移添加下一个候选人</span></span><br><span class="line">        heap = [(matrix[i][<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] </span><br><span class="line">        heapq.heapify(heap) <span class="comment">#变成一个heap</span></span><br><span class="line">        print(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k - <span class="number">1</span>): <span class="comment">#一共弹k次：这里k-1次，return的时候1次</span></span><br><span class="line">            num, x, y = heapq.heappop(heap) <span class="comment">#弹出候选人里最小一个</span></span><br><span class="line">            <span class="keyword">if</span> y != n - <span class="number">1</span>: <span class="comment">#如果这一行还没被弹完</span></span><br><span class="line">                heapq.heappush(heap, (matrix[x][y + <span class="number">1</span>], x, y + <span class="number">1</span>)) <span class="comment">#加入这一行的下一个候选人</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(heap)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="堆的相关操作"><a href="#堆的相关操作" class="headerlink" title="堆的相关操作"></a>堆的相关操作</h2><table><thead><tr><th>函 数</th><th>函 数</th></tr></thead><tbody><tr><td>heappush(heap, x)</td><td>将x压入堆中</td></tr><tr><td>heappop(heap)</td><td>从堆中弹出最小的元素</td></tr><tr><td>heapify(heap)</td><td>让列表具备堆特征</td></tr><tr><td>heapreplace(heap, x)</td><td>弹出最小的元素，并将x压入堆中</td></tr><tr><td>nlargest(n, iter)</td><td>返回iter中n个最大的元素</td></tr><tr><td>nsmallest(n, iter)</td><td>返回iter中n个最小的元素</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="comment"># 将x压入堆中</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">heap = []</span><br><span class="line"><span class="comment"># 建立堆，把列表的元素放如到堆heap中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="comment"># 把元素压入到堆中</span></span><br><span class="line">    heapq.heappush(heap, x[i])</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 从堆中弹出最小的元素</span></span><br><span class="line">print(heapq.heappop(heap))</span><br><span class="line"><span class="comment"># 通过heapify建立堆，可以执行尽可能少的操作</span></span><br><span class="line">heap = [<span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 弹出最小的元素，并将10压入堆中</span></span><br><span class="line">heapq.heapreplace(heap, <span class="number">10</span>)</span><br><span class="line">print(heap)</span><br><span class="line"><span class="comment"># 返回heap中n=4个最大的元素</span></span><br><span class="line">print(heapq.nlargest(<span class="number">4</span>, heap))</span><br><span class="line"><span class="comment"># 返回iter中n=3个最小的元素</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">4</span>, heap))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解法三：二分查找"><a href="#解法三：二分查找" class="headerlink" title="解法三：二分查找"></a>解法三：二分查找</h2><p>上面的堆只是利用了矩阵的当前行元素是逐渐增大这个条件，如果我们把当前列元素也是逐渐增大这个条件用上的话就可以更优化。</p><p>矩阵中的最小值为left = matrix[0] [0]，最大值为right = matrix[-1] [-1]，我们取中间值mid = (left + right) // 2，如果我们在矩阵中把大于mid的值和小于mid的值分开就会发现可以把矩阵分为两个部分。</p><img src="/2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/1.png" class><p>所以我们只需要统计mid左边的数量，以及mid右边的数量，然后比较一下就可以知道，当前的mid是大了还是笑了，如果左边的数量&gt;k那么说明mid太大了，需要减小；如果右边的数量&gt;k那么说明mid太小了，需要增大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, matrix: List[List[int]], k: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">mid</span>):</span></span><br><span class="line">            <span class="comment"># 从左下角开始查找，这样可以保证mid始终比自己左上角的值大</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            i, j = n - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n:</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] &lt;= mid:</span><br><span class="line">                    num += i + <span class="number">1</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= k <span class="comment"># 判断num是否大于等于k</span></span><br><span class="line">        left, right = matrix[<span class="number">0</span>][<span class="number">0</span>], matrix[<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left                </span><br></pre></td></tr></table></figure><h1 id="2-373-查找和最小的-K-对数字"><a href="#2-373-查找和最小的-K-对数字" class="headerlink" title="2.373. 查找和最小的 K 对数字"></a>2.<a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/">373. 查找和最小的 K 对数字</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。</p><p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。</p><p>请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  …  (uk,vk) 。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,7,11], nums2 &#x3D; [2,4,6], k &#x3D; 3</span><br><span class="line">输出: [1,2],[1,4],[1,6]</span><br><span class="line">解释: 返回序列中的前 3 对数：</span><br><span class="line">     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,1,2], nums2 &#x3D; [1,2,3], k &#x3D; 2</span><br><span class="line">输出: [1,1],[1,1]</span><br><span class="line">解释: 返回序列中的前 2 对数：</span><br><span class="line">     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2], nums2 &#x3D; [3], k &#x3D; 3 </span><br><span class="line">输出: [1,3],[2,3]</span><br><span class="line">解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]</span><br></pre></td></tr></table></figure><p>提示:</p><p>1 &lt;= nums1.length, nums2.length &lt;= 105<br>-109 &lt;= nums1[i], nums2[i] &lt;= 109<br>nums1 和 nums2 均为升序排列<br>1 &lt;= k &lt;= 1000</p><h2 id="解法一：堆"><a href="#解法一：堆" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>以数对和来建立堆，每个堆中还需要保存当前数对的位置，同时需要注意的是：判断循环的条件，需要考虑到两个数组组成的数对小于k个的问题，例如：[1,2] 、[3]、3。所以需要加一个必须堆不为空的条件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kSmallestPairs</span>(<span class="params">self, nums1: List[int], nums2: List[int], k: int</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        m, n = len(nums1), len(nums2)</span><br><span class="line">        heap = [(nums1[i] + nums2[<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(min(k, m))]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> heap <span class="keyword">and</span> len(ans) &lt; k:</span><br><span class="line">            _, x, y = heapq.heappop(heap)</span><br><span class="line">            ans.append([nums1[x], nums2[y]])</span><br><span class="line">            <span class="keyword">if</span> y + <span class="number">1</span> &lt; n:</span><br><span class="line">                heapq.heappush(heap, (nums1[x] + nums2[y+<span class="number">1</span>], x, y+<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="3-668-乘法表中第k小的数"><a href="#3-668-乘法表中第k小的数" class="headerlink" title="3.668. 乘法表中第k小的数"></a>3.<a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table/">668. 乘法表中第k小的数</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？</p><p>给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。</p><p>例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 3, n &#x3D; 3, k &#x3D; 5</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">乘法表:</span><br><span class="line">123</span><br><span class="line">246</span><br><span class="line">369</span><br><span class="line">第5小的数字是 3 (1, 2, 2, 3, 3).</span><br></pre></td></tr></table></figure><p>例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m &#x3D; 2, n &#x3D; 3, k &#x3D; 6</span><br><span class="line">输出: 6</span><br><span class="line">解释: </span><br><span class="line">乘法表:</span><br><span class="line">123</span><br><span class="line">246</span><br><span class="line">第6小的数字是 6 (1, 2, 2, 3, 4, 6).</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">m 和 n 的范围在 [1, 30000] 之间。</span><br><span class="line">k 的范围在 [1, m * n] 之间。</span><br></pre></td></tr></table></figure><h2 id="解法一：堆（超出时间限制）"><a href="#解法一：堆（超出时间限制）" class="headerlink" title="解法一：堆（超出时间限制）"></a>解法一：堆（超出时间限制）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNumber</span>(<span class="params">self, m: int, n: int, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 如果m大于k说明堆有一部分用不到，所以取两者中最小的</span></span><br><span class="line">        heap = [(i, i, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>)]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            num, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> y != n:</span><br><span class="line">                <span class="comment"># 这里结束应该是n，而不是n-1</span></span><br><span class="line">                heapq.heappush(heap, (x * (y + <span class="number">1</span>), x, y + <span class="number">1</span>))</span><br><span class="line">        ans, _, _ = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="解法二：二分查找"><a href="#解法二：二分查找" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNumber</span>(<span class="params">self, m: int, n: int, k: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">mid</span>):</span></span><br><span class="line">            <span class="comment"># 从左下角开始查找，这样可以保证mid始终比自己左上角的值大</span></span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            i, j = m, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">1</span> <span class="keyword">and</span> j &lt;= n:</span><br><span class="line">                <span class="keyword">if</span> i * j &lt;= mid:</span><br><span class="line">                    num += i</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> num &gt;= k <span class="comment"># 判断num是否大于等于k</span></span><br><span class="line">        left, right = <span class="number">1</span> * <span class="number">1</span>, m * n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left                </span><br></pre></td></tr></table></figure><h1 id="4-719-找出第-k-小的距离对"><a href="#4-719-找出第-k-小的距离对" class="headerlink" title="4.719. 找出第 k 小的距离对"></a>4.<a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums &#x3D; [1,3,1]</span><br><span class="line">k &#x3D; 1</span><br><span class="line">输出：0 </span><br><span class="line">解释：</span><br><span class="line">所有数对如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">提示:</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; len(nums) &lt;&#x3D; 10000.</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; len(nums) * (len(nums) - 1) &#x2F; 2.</span><br></pre></td></tr></table></figure><h2 id="解法一：堆（超出时间限制）-1"><a href="#解法一：堆（超出时间限制）-1" class="headerlink" title="解法一：堆（超出时间限制）"></a>解法一：堆（超出时间限制）</h2><p>首先针对nums按照升序排序，然后我们以[1, 2, 3, 4]为例，来推演一下结果：</p><p>对角线为空，对于左下角和右上角会存在重复，所以我们只需要考虑一个即可，中间的结果是绝对值。</p><table><thead><tr><th align="center">nums</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"></td><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">2</td><td align="center"></td><td align="center"></td><td align="center">1</td><td align="center">2</td></tr><tr><td align="center">3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">1</td></tr><tr><td align="center">4</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>通过这个表格我们会发现，最小的值是按照对角线排列，所以我们可以先把结果为1的加入到堆中，然后每次遇到最小值，就把当前最小值弹出，并把当前结果右侧的一个结果放入到堆中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDistancePair</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        heap = [(abs(nums[i<span class="number">-1</span>] - nums[i]), i<span class="number">-1</span>, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n)]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            _, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> y != n - <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(heap, (abs(nums[x] - nums[y+<span class="number">1</span>]), x, y + <span class="number">1</span>))</span><br><span class="line">        num, _, _ = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> num</span><br></pre></td></tr></table></figure><h2 id="解法二：二分查找-1"><a href="#解法二：二分查找-1" class="headerlink" title="解法二：二分查找"></a>解法二：二分查找</h2><p>由于堆排序会出现超时情况，所以我们在这里考虑二分查找。</p><p><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/solution/719-zhao-chu-di-k-xiao-de-ju-chi-dui-er-g1i76/">https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/solution/719-zhao-chu-di-k-xiao-de-ju-chi-dui-er-g1i76/</a></p><img src="/2022/01/14/220114%E6%B1%82%E2%80%9C%E7%AC%ACK%E5%B0%8F%E2%80%9D%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/2.png" class><p>看上面这张图，我们用二分查找的时候，需要统计小于等于mid的值有多少个，距离对的所有值是上图红色标记的部分，我们来推导一个check(mid)这个过程。</p><p>建设初始的mid为1，</p><p>第一轮:r=0, l=0,while不执行，此时cnt=0</p><p>第二轮:r=1, l=0, 此时while执行l=1，cnt=1</p><p>第三轮:r=2,l=1,此时while执行l=2, cnt=2</p><p>第四轮:r=3,l=2,此时while执行l=3，cnt= 3</p><p>返回结果判断cnt的值是否大于k，如果大于k说明mid太大了，right右边界降低，否则left左边界提高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDistancePair</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">mid</span>):</span></span><br><span class="line">            cnt = l = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">while</span> nums[r] - nums[l] &gt; mid:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                cnt += r - l</span><br><span class="line">            <span class="keyword">return</span> cnt &gt;= k</span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        left, right = <span class="number">0</span>, nums[<span class="number">-1</span>] - nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> check(mid):</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h1 id="5-658-找到-K-个最接近的元素"><a href="#5-658-找到-K-个最接近的元素" class="headerlink" title="5.658. 找到 K 个最接近的元素"></a>5.<a href="https://leetcode-cn.com/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a></h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。</p><p>整数 a 比整数 b 更接近 x 需要满足：</p><p>|a - x| &lt; |b - x| 或者<br>|a - x| == |b - x| 且 a &lt; b</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 4, x &#x3D; 3</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5], k &#x3D; 4, x &#x3D; -1</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; arr.length</span><br><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 104</span><br><span class="line">数组里的每个元素与 x 的绝对值不超过 104</span><br></pre></td></tr></table></figure><h2 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h2><p>采用双指针，从两边往中间逼近，如果从左边距离x的距离大于右边的话，那么就需要把左边的往右移动，否则就需要把右边的往左边移动。同时需要注意循环条件，保证中间又k个元素存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span>(<span class="params">self, arr: List[int], k: int, x: int</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 采用双指针，从两边往中间逼近</span></span><br><span class="line">        left, right = <span class="number">0</span>, len(arr)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> (right-left+<span class="number">1</span>) &gt; k:</span><br><span class="line">            l_dis, r_dis = abs(x-arr[left]), abs(x-arr[right])</span><br><span class="line">            <span class="keyword">if</span> l_dis &gt; r_dis:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr[left : right+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1 id="6-786-第-K-个最小的素数分数"><a href="#6-786-第-K-个最小的素数分数" class="headerlink" title="6.786. 第 K 个最小的素数分数"></a>6.<a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数  组成，且其中所有整数互不相同。</p><p>对于每对满足 0 &lt;= i &lt; j &lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。</p><p>那么第 k 个最小的分数是多少呢?  以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,5], k &#x3D; 3</span><br><span class="line">输出：[2,5]</span><br><span class="line">解释：已构造好的分数,排序后如下所示: </span><br><span class="line">1&#x2F;5, 1&#x2F;3, 2&#x2F;5, 1&#x2F;2, 3&#x2F;5, 2&#x2F;3</span><br><span class="line">很明显第三个最小的分数是 2&#x2F;5</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,7], k &#x3D; 1</span><br><span class="line">输出：[1,7]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line"></span><br><span class="line">2 &lt;&#x3D; arr.length &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 3 * 104</span><br><span class="line">arr[0] &#x3D;&#x3D; 1</span><br><span class="line">arr[i] 是一个 素数 ，i &gt; 0</span><br><span class="line">arr 中的所有数字 互不相同 ，且按 严格递增 排序</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; arr.length * (arr.length - 1) &#x2F; 2</span><br></pre></td></tr></table></figure><h2 id="解法一：堆-1"><a href="#解法一：堆-1" class="headerlink" title="解法一：堆"></a>解法一：堆</h2><p>这个题和上面的题目都有异曲同工之处，如果用示例 1写出来就会发现，每一行元素从右到左是递增的，从上到下是递增的。</p><p>所以我们就可以用堆，先把最后一列的元素加入到堆里面，然后再逐渐</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallestPrimeFraction</span>(<span class="params">self, arr: List[int], k: int</span>) -&gt; List[int]:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        heap = [(arr[i] / arr[n<span class="number">-1</span>], i, n<span class="number">-1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>)]</span><br><span class="line">        <span class="comment"># print(heap)</span></span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k<span class="number">-1</span>):</span><br><span class="line">            _, x, y = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> y != <span class="number">1</span>:</span><br><span class="line">                heapq.heappush(heap, (arr[x] / arr[y - <span class="number">1</span>], x, y - <span class="number">1</span>))</span><br><span class="line">        _, x, y = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">return</span> [arr[x], arr[y]]</span><br></pre></td></tr></table></figure><ul><li><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></li><li><a href="https://leetcode-cn.com/problems/super-ugly-number/">313. 超级丑数</a></li><li><a href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/comments/">373. 查找和最小的K对数字</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/">632. 最小区间</a></li><li><a href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">719. 找出第 k 小的距离对</a></li><li><a href="https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/">786. 第 K 个最小的素数分数</a></li><li><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/">1439. 有序矩阵中的第 k 个最小数组和</a></li><li><a href="https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/">1508. 子数组和排序后的区间和</a></li><li><a href="https://leetcode-cn.com/problems/minimize-deviation-in-array/">1675. 数组的最小偏移量</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 堆（优先队列） </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解“最长递增子序列及其变形”</title>
      <link href="2022/01/12/220112%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2022/01/12/220112%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><strong>LeetCode刷题是很有规律的，我们在此称之为”子母题“，通过多个子题我们可以归纳总结出一个母题，通过一个母题我们可以演绎推理出多个子题。</strong></p><p>今天的第一个题目就是母题，后面的几个题目就是子题，我们通过这个系列来加快刷题速度，快速掌握一个相关类型的题目。</p><h1 id="1-300-最长递增子序列"><a href="#1-300-最长递增子序列" class="headerlink" title="1.300. 最长递增子序列"></a>1.<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 2500<br>-104 &lt;= nums[i] &lt;= 104</p><h2 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>以nums=[10,9,2,5,3,7,101,18]为例，我们采用动态规划来解决这个问题，首先dp初始值全部为1，dp[i]代表以nums[i]为结尾的递增子序列长度为dp[i]。</p><p>我们把nums[i]与前i-1个元素比较，如果<code>nums[i] &gt; nums[j]</code>就更新dp[i]，因此我们可以得到状态转移方程为：<code>dp[i] = max(dp[i], dp[j] + 1)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><p>$$<br>时间复杂度：O(n^2),空间复杂度：O(n)<br>$$</p><h2 id="解法二：动态规划-二分查找"><a href="#解法二：动态规划-二分查找" class="headerlink" title="解法二：动态规划+二分查找"></a>解法二：动态规划+二分查找</h2><p>我们可以用一个数组tail，来动态保存一个递增子序列，tail在任意时刻都是保存当前最长子序列的结果，同时我们利用贪心思想，既让tail为递增子序列，有保证尽可能让后一个元素比前一个元素更接近。</p><p>我们来动态模拟一下这个过程，更方便理解：</p><p>当i=0时，由于tail初始为空，所以10进入tail，此时tail=[10]</p><p>当i=1时，由于9&lt;10，所以我们让9替换10，此时tail=[9]；</p><p>当i=2时，由于2&lt;9，所以我们让2替换9，此时tail=[2]</p><p>当i=3时，由于5&gt;2，所以让5进入tail，此时tail=[2, 5]</p><p>当i=4时，由于3&lt;5，而且3如果替换5的话依然可以保证tail递增，所以利用贪心思想，我们让3替换5，此时tail= [2, 3]；</p><p>当i=5时，由于7&gt;3，所以让7进入tail，此时tail=[2, 3, 7]</p><p>当i=6时，由于101&gt;7，所以让101进入tail，此时tail=[2, 3, 7, 101]</p><p>当i=7时，由于18&lt;101，而且18如果替换101的话依然可以保证tail递增，所以利用贪心思想，我们让18替换101，此时tail=[2, 3, 7, 101]</p><blockquote><p>通过上面的模拟我们可以得到更新tail的两个原则：</p></blockquote><p>第一：时刻保证tail是递增的序列；第二：尽可能让后一个元素与前一个元素相接近，就是如果当前元素可以比原有的tail元素接近的话，就用当前元素替换原有的元素。</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>nums[i]</td><td>10</td><td>9</td><td>2</td><td>5</td><td>3</td><td>7</td><td>101</td><td>18</td></tr><tr><td>tail</td><td>[10]</td><td>[9]</td><td>[2]</td><td>[2, 5]</td><td>[2, 3]</td><td>[2, 3, 7]</td><td>[2, 3, 7, 101]</td><td>[2, 3, 7, 18]</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># tail为空或当前num大于tail的最后一个元素</span></span><br><span class="line">                tail.append(num)</span><br><span class="line">            l, r = <span class="number">0</span>, len(tail) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 用当前的num更新tail数组，贪心思想来用num替换tail中的一个元素</span></span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tail[mid] &lt; num:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid</span><br><span class="line">            tail[l] = num</span><br><span class="line">        <span class="keyword">return</span> len(tail)</span><br></pre></td></tr></table></figure><p>$$<br>时间复杂度：O(NlogN)，遍历数组使用了 O(N)，二分查找法使用了 O(logN)<br>$$</p><p>$$<br>空间复杂度：O(N)，开辟数组的长度至多和nums长度一样长<br>$$</p><h1 id="2-334-递增的三元子序列"><a href="#2-334-递增的三元子序列" class="headerlink" title="2.334. 递增的三元子序列"></a>2.<a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 5 * 105<br>-231 &lt;= nums[i] &lt;= 231 - 1</p><p>进阶：你能实现时间复杂度为 O(n) ，空间复杂度为 O(1) 的解决方案吗？</p><h2 id="解法一：基于最长递增子序列的变形"><a href="#解法一：基于最长递增子序列的变形" class="headerlink" title="解法一：基于最长递增子序列的变形"></a>解法一：基于最长递增子序列的变形</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># tail为空或当前num大于tail的最后一个元素</span></span><br><span class="line">                tail.append(num)</span><br><span class="line">            l, r = <span class="number">0</span>, len(tail) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="comment"># 用当前的num更新tail数组，贪心思想来用num替换tail中的一个元素</span></span><br><span class="line">                mid = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> tail[mid] &lt; num:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid</span><br><span class="line">            tail[l] = num</span><br><span class="line">            <span class="keyword">if</span> len(tail) == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>时间复杂度与空间复杂度同上</p><h2 id="解法二：数学法（进阶）"><a href="#解法二：数学法（进阶）" class="headerlink" title="解法二：数学法（进阶）"></a>解法二：数学法（进阶）</h2><p>通过数学法，首先我们令a记录一个最小值，b记录次小值，如果在a，b之后存在一个元素比b大的话，就说明可以满足条件；<strong>a，b的初始值均为边界最大值；</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increasingTriplet</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        a = (<span class="number">2</span> ** <span class="number">31</span>)</span><br><span class="line">        b = (<span class="number">2</span> ** <span class="number">31</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &lt;= a:</span><br><span class="line">                a = num</span><br><span class="line">            <span class="keyword">elif</span> num &lt;= b:</span><br><span class="line">                b = num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h1 id="3-354-俄罗斯套娃信封问题"><a href="#3-354-俄罗斯套娃信封问题" class="headerlink" title="3.354. 俄罗斯套娃信封问题"></a>3.<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。</p><p>当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p>注意：不允许旋转信封。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：最多信封的个数为 3, 组合为: [2,3] &#x3D;&gt; [5,4] &#x3D;&gt; [6,7]。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：envelopes &#x3D; [[1,1],[1,1],[1,1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= envelopes.length &lt;= 5000<br>envelopes[i].length == 2<br>1 &lt;= wi, hi &lt;= 104</p><h2 id="题目预处理"><a href="#题目预处理" class="headerlink" title="题目预处理"></a>题目预处理</h2><p>因为是二维数组，一般遇到这样的题目，都需要考虑先排序，要么是按照升序排序，要么是按照降序排序，或者是升序与降序结合的方式来排序。</p><p>在这个题目中，我们采用两者结合的方法，先按照x[0]升序，在按照x[1]降序，降序的时候只要按照-x[1]升序即可；</p><h2 id="解法一：动态规划-1"><a href="#解法一：动态规划-1" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>由于已经按照上面的预处理进行排序，所以我们用动态规划的思想，就类似于<strong>最长递增子序列</strong>这个题目，第一列已经有序，所以只需要考虑第二列是否符合要求即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        n = len(envelopes)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> envelopes[j][<span class="number">1</span>] &lt; envelopes[i][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划-二分查找-1"><a href="#解法二：动态规划-二分查找-1" class="headerlink" title="解法二：动态规划+二分查找"></a>解法二：动态规划+二分查找</h2><p>这个思路理解起来有些困难，</p><p>我们envelops=[[2, 5], [2, 3], [5, 4], [5, 3], [6, 7], [6, 4]]</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>envelops[i]</td><td>[2, 5]</td><td>[2, 3]</td><td>[5, 4]</td><td>[5, 3]</td><td>[6, 7]</td><td>[6, 4]</td></tr><tr><td>tail</td><td>5</td><td>3</td><td>3, 4</td><td>3, 4</td><td>3, 4, 7</td><td></td></tr></tbody></table><p>对于第一列是2开始的有[2, 5]和  [2, 3]，我么首先把5加入tail，然后由于3&lt;5，所以把3加入tail。</p><p>接下来对于第一列是5开始的有[5, 4]和[5, 3]，我们必须要找一个第二列比3大的才可以加入tail，最后找到了4；</p><p>然后对于第一列是6开始的有[6, 7]和 [6, 4]，同上。</p><p>根据上面的表格推理一遍就可以发现上面题目排序的方式的妙处在哪里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(envelopes)</span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            num = envelopes[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                tail.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &lt;= tail[<span class="number">-1</span>]:</span><br><span class="line">                l, r = <span class="number">0</span>, len(tail) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    mid = (l + r) // <span class="number">2</span></span><br><span class="line">                    <span class="keyword">if</span> tail[mid] &lt; num:</span><br><span class="line">                        l = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r = mid</span><br><span class="line">                tail[l] = num</span><br><span class="line">        <span class="keyword">return</span> len(tail)</span><br></pre></td></tr></table></figure><p>针对上面的代码在二分查找这一部分进行优化，直接调用函数来实现，这样可以大大优化时间和代码量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEnvelopes</span>(<span class="params">self, envelopes: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(envelopes)</span><br><span class="line">        envelopes.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        tail = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            num = envelopes[i][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tail <span class="keyword">or</span> num &gt; tail[<span class="number">-1</span>]:</span><br><span class="line">                tail.append(num)</span><br><span class="line">            <span class="keyword">elif</span> num &lt;= tail[<span class="number">-1</span>]:</span><br><span class="line">                l = bisect.bisect_left(tail, num)</span><br><span class="line">                tail[l] = num</span><br><span class="line">        <span class="keyword">return</span> len(tail)</span><br></pre></td></tr></table></figure><h1 id="4-673-最长递增子序列的个数"><a href="#4-673-最长递增子序列的个数" class="headerlink" title="4.673. 最长递增子序列的个数"></a>4.<a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,4,7]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,2,2,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</span><br></pre></td></tr></table></figure><p>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p><h2 id="解法一：动态规划-2"><a href="#解法一：动态规划-2" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><p>在第一个题目最长递增子序列的基础上，我们需要修改一下，dp的含义依然不变：以nums[i]结尾的最长子序列的长度；</p><p>新增一个cnt数组，其含义是以nums[i]结尾的最长子序列的个数；</p><p>有了长度数组dp和个数数组cnt，我们只需要每次遍历的时候比较一下max_len和max_ans就可以得到最终的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        cnt = [<span class="number">1</span>] * n</span><br><span class="line">        max_len, max_ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                        cnt[i] = cnt[j]</span><br><span class="line">                    <span class="keyword">elif</span> dp[j] + <span class="number">1</span> == dp[i]:</span><br><span class="line">                        cnt[i] += cnt[j]</span><br><span class="line">            <span class="keyword">if</span> dp[i] &gt; max_len:</span><br><span class="line">                max_len = dp[i]</span><br><span class="line">                max_ans = cnt[i]</span><br><span class="line">            <span class="keyword">elif</span> dp[i] == max_len:</span><br><span class="line">                max_ans += cnt[i]</span><br><span class="line">        <span class="keyword">return</span> max_ans</span><br></pre></td></tr></table></figure><p>上面这个可以稍微优化一下，既然cnt是以nums[i]结尾的最长子序列的个数，只要我们在nums后面增加一个2 ** 31这个数，这样我们的最长子序列一定是以最后增加的这个数为结尾，这样就不需要设置max_len来标记最长长度。在代码量上会有很大的优化空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberOfLIS</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        nums = nums + [<span class="number">2</span> ** <span class="number">31</span>]</span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        cnt = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    <span class="keyword">if</span> dp[j] + <span class="number">1</span> &gt; dp[i]:</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">                        cnt[i] = cnt[j]</span><br><span class="line">                    <span class="keyword">elif</span> dp[j] + <span class="number">1</span> == dp[i]:</span><br><span class="line">                        cnt[i] += cnt[j]</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-646-最长数对链"><a href="#5-646-最长数对链" class="headerlink" title="5.646. 最长数对链"></a>5.<a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/">646. 最长数对链</a></h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p><p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p><p>给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,2], [2,3], [3,4]]</span><br><span class="line">输出：2</span><br><span class="line">解释：最长的数对链是 [1,2] -&gt; [3,4]</span><br></pre></td></tr></table></figure><p>提示：</p><p>给出数对的个数在 [1, 1000] 范围内。</p><h2 id="解法一：动态规划-3"><a href="#解法一：动态规划-3" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span>(<span class="params">self, pairs: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        print(pairs)</span><br><span class="line">        n = len(pairs)</span><br><span class="line">        dp = [<span class="number">1</span>] * n    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划-二分"><a href="#解法二：动态规划-二分" class="headerlink" title="解法二：动态规划+二分"></a>解法二：动态规划+二分</h2><h2 id="解法三：贪心"><a href="#解法三：贪心" class="headerlink" title="解法三：贪心"></a>解法三：贪心</h2><p>这个解法稍微难理解一些，我们举个例子来看就更容易理解：</p><p>初始时：pairs = [[2,3], [2,5], [2,7], [2,10], [3,4], [6,7], [8,9]]</p><p>排序之后：[[2, 3], [3, 4], [2, 5], [2, 7], [6, 7], [8, 9], [2, 10]]</p><p>这样我们就可以发现，对于第一列是2的情况，第二列我们通过贪心原则优先选择最小的，这样可以保证后面的尽可能多；</p><p>通过上面的结果我们可以看出最后形成对链的有：[2,3], [6,7], [8,9]</p><p>因此我们按照第二列升序排序之后，然后用一个position记录上一次的结尾数字是哪个，而且这个结尾数字是尽可能小（贪心），这样只需要遍历一遍数组就可以找到所有满足要求的对链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span>(<span class="params">self, pairs: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        n = len(pairs)</span><br><span class="line">        pairs.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        print(pairs)</span><br><span class="line">        position = pairs[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> pairs[i][<span class="number">0</span>] &gt; position:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                position = pairs[i][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解“最长回文子串”（中心扩展算法、马拉车算法）</title>
      <link href="2022/01/06/220107%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
      <url>2022/01/06/220107%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-5-最长回文子串"><a href="#1-5-最长回文子串" class="headerlink" title="1.5. 最长回文子串"></a>1.<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="解法一：中心扩展算法"><a href="#解法一：中心扩展算法" class="headerlink" title="解法一：中心扩展算法"></a>解法一：中心扩展算法</h2><img src="/2022/01/06/220107%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/1.jpeg" class><p>由于回文串是对称的，对于中心扩展算法来说，我们每次选择从回文串的中心向左右两侧扩展，对应位置的元素一定是相同的。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>b</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>第一种情况：回文串长度为奇数，对于abbba这个回文串来说，它的中心是b（2）；</p><p>第二种情况：回文串长度为偶数，对于baab这个回文串来说，它的中心就是aa(4\5);</p><p>所以我们遍历一个字符串，只需要把把当前位置作为中心，向两侧进行扩展来判断以当前位置为中心的回文串的最大长度是多少就可以了。</p><p>首先定义一个expandAroundCenter函数，来判断制定字符串以及中心的位置，判断以当前位置为中心的最长回文串；</p><p>其次，遍历所有的中心，然后把当前中心的回文串长度与最长长度比较，同时需要更新最长回文串的起始和结束为止；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">expandAroundCenter</span>(<span class="params">s, left, right</span>):</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt; n <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> right - left - <span class="number">1</span>  </span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            len1 = expandAroundCenter(s, i, i)</span><br><span class="line">            len2 = expandAroundCenter(s, i, i + <span class="number">1</span>)</span><br><span class="line">            l = max(len1, len2)</span><br><span class="line">            <span class="keyword">if</span> l &gt; end - start:</span><br><span class="line">                start = i - (l - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">                end = i + l // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>时间复杂度：$O（n²）$。两层循环，每层循环都是遍历每个字符。</p><p>空间复杂度：$O（1）$。</p><h2 id="解法二：马拉车算法"><a href="#解法二：马拉车算法" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>具体的讲解请参考这位博主的整理<a href="https://zhuanlan.zhihu.com/p/70532099">https://zhuanlan.zhihu.com/p/70532099</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">            ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">            ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        ret = preProcess(s)</span><br><span class="line">        n = len(ret)</span><br><span class="line">        P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">        C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">            <span class="keyword">if</span> R &gt; i:</span><br><span class="line">                P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">            <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">                P[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        <span class="comment"># 找到最长回文串的位置</span></span><br><span class="line">        maxLen = <span class="number">0</span> </span><br><span class="line">        cnterIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> P[i] &gt; maxLen:</span><br><span class="line">                maxLen = P[i]</span><br><span class="line">                cnterIndex = i</span><br><span class="line">        start = (cnterIndex - maxLen) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> s[start:start+maxLen]</span><br></pre></td></tr></table></figure><p>下面这个是马拉车算法的一般形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">    n = len(s)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">    ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">    ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manacher</span>(<span class="params">s</span>):</span></span><br><span class="line">    ret = preProcess(s)</span><br><span class="line">    n = len(ret)</span><br><span class="line">    P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">    C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">        i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">        <span class="keyword">if</span> R &gt; i:</span><br><span class="line">            P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">        <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">        <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">            P[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">            C = i</span><br><span class="line">            R = i + P[i]</span><br><span class="line"> <span class="comment">#     return P</span></span><br><span class="line">  maxLen = <span class="number">0</span> </span><br><span class="line">    cnterIndex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> P[i] &gt; maxLen:</span><br><span class="line">        maxLen = P[i]</span><br><span class="line">        cnterIndex = i</span><br><span class="line">    start = (cnterIndex - maxLen) // <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> s[start:start+maxLen]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://segmentfault.com/a/1190000008484167">https://segmentfault.com/a/1190000008484167</a></p><p><a href="https://zhuanlan.zhihu.com/p/70532099">https://zhuanlan.zhihu.com/p/70532099</a></p><p><a href="https://blog.crimx.com/2017/07/06/manachers-algorithm/">https://blog.crimx.com/2017/07/06/manachers-algorithm/</a></p><h1 id="2-647-回文子串"><a href="#2-647-回文子串" class="headerlink" title="2.647. 回文子串"></a>2.<a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= s.length &lt;= 1000<br>s 由小写英文字母组成</p><h2 id="解法一：中心扩展法"><a href="#解法一：中心扩展法" class="headerlink" title="解法一：中心扩展法"></a>解法一：中心扩展法</h2><p>这里有一个小技巧，我们把n扩大到2 * n - 1，同时令l, r = i // 2, i // 2 + i % 2就可以使得所有的情况都得到遍历。</p><p>以s = “abc”为例：</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>l</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td></tr><tr><td>r</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span> * n - <span class="number">1</span>):</span><br><span class="line">            l, r = i // <span class="number">2</span>, i // <span class="number">2</span> + i % <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="解法二：马拉车算法-1"><a href="#解法二：马拉车算法-1" class="headerlink" title="解法二：马拉车算法"></a>解法二：马拉车算法</h2><p>这一题依然可以用马拉车算法，只是最后求数量的时候需要做一下特殊的处理，对于P，如果P[i] == 1说明有一个长度为1的回文串，如果P[i] &gt; 1说明回文串长度大于1的有P[i] % 2个，例如deed，此时长度为4，回文串长度大于1的个数有2个分别是deed和ee。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span>(<span class="params">s</span>):</span></span><br><span class="line">            <span class="comment"># 首先对字符串进行预处理，^$分别标记起始位置，也可以不用加起始标记位置</span></span><br><span class="line">            n = len(s)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;^$&#x27;</span></span><br><span class="line">            ret = <span class="string">&#x27;^&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                ret += <span class="string">&#x27;#&#x27;</span> + s[i]</span><br><span class="line">            ret += <span class="string">&#x27;#$&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">        ret = preProcess(s)</span><br><span class="line">        n = len(ret)</span><br><span class="line">        P = [<span class="number">0</span>] * n <span class="comment"># 记录每个位置的最长回文串长度</span></span><br><span class="line">        C, R = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># C代表当前回文串，R代表右半径</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n<span class="number">-1</span>):</span><br><span class="line">            i_mirror = <span class="number">2</span> * C - i</span><br><span class="line">            <span class="keyword">if</span> R &gt; i:</span><br><span class="line">                P[i] = min(R - i, P[i_mirror]) <span class="comment"># 防止超出R</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                P[i] = <span class="number">0</span>    <span class="comment"># 等于R的情况</span></span><br><span class="line">            <span class="comment"># 碰到之前讲的三种情况时候，需要利用中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> ret[i + <span class="number">1</span> + P[i]] == ret[i - <span class="number">1</span> - P[i]]:</span><br><span class="line">                P[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i + P[i] &gt; R:</span><br><span class="line">                C = i</span><br><span class="line">                R = i + P[i]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> P:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">                ans += num // <span class="number">2</span></span><br><span class="line">        ans += len(s)</span><br><span class="line">        <span class="keyword">return</span> ans        </span><br></pre></td></tr></table></figure><h1 id="4-1143-最长公共子序列"><a href="#4-1143-最长公共子序列" class="headerlink" title="4.1143. 最长公共子序列"></a>4.<a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h1><p>dp[i] [j]代表text1前i个元素，text2前j个元素的公共子序列长度为多少</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span>(<span class="params">self, text1: str, text2: str</span>) -&gt; int:</span></span><br><span class="line">        m, n = len(text1), len(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] </span><br></pre></td></tr></table></figure><h1 id="3-516-最长回文子序列"><a href="#3-516-最长回文子序列" class="headerlink" title="3.516. 最长回文子序列"></a>3.<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h1><p>这个部分可以参考一下这个链接 有很详细的关于动态规划的讲解，以及如何优化问题。</p><p><a href="https://sanduohou.github.io/2021/12/31/211231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">动态规划之背包问题</a></p><p>首先是问题转换，把求回文子序列转换为求最长公共子序列，对于s，我们用r表示s的反转，由于是最长回文子序列，所以s的最长回文子序列一定等于r的最长回文子序列。</p><h2 id="解法一：动态规划（转换为最长公共子序列）"><a href="#解法一：动态规划（转换为最长公共子序列）" class="headerlink" title="解法一：动态规划（转换为最长公共子序列）"></a>解法一：动态规划（转换为最长公共子序列）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        r = s[::<span class="number">-1</span>]</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == r[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：动态规划（优化空间，滚动数组）"><a href="#解法二：动态规划（优化空间，滚动数组）" class="headerlink" title="解法二：动态规划（优化空间，滚动数组）"></a>解法二：动态规划（优化空间，滚动数组）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        r = s[::<span class="number">-1</span>]</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i<span class="number">-1</span>] == r[j<span class="number">-1</span>]:</span><br><span class="line">                <span class="comment"># if s[i-1] == s[n-j]:这样也可以 就不需要复制s了</span></span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j], dp[i&amp;<span class="number">1</span>][j<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp[<span class="number">0</span>][<span class="number">-1</span>], dp[<span class="number">1</span>][<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><h2 id="解法三：动态规划"><a href="#解法三：动态规划" class="headerlink" title="解法三：动态规划"></a>解法三：动态规划</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 滚动数组优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindromeSubseq</span>(<span class="params">self, s: str</span>) -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            dp[i &amp; <span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = dp[(i + <span class="number">1</span>)&amp;<span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i&amp;<span class="number">1</span>][j] = max(dp[(i + <span class="number">1</span>)&amp;<span class="number">1</span>][j], dp[i&amp;<span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> max(dp[<span class="number">0</span>][<span class="number">-1</span>], dp[<span class="number">1</span>][<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 经典算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二/N叉树深度问题</title>
      <link href="2022/01/05/220105%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
      <url>2022/01/05/220105%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1.知识讲解"></a>1.知识讲解</h1><h1 id="2-104-二叉树的最大深度"><a href="#2-104-二叉树的最大深度" class="headerlink" title="2.104. 二叉树的最大深度"></a>2.104.<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/"> 二叉树的最大深度</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>通过递归获得左右子树的深度，然后取两者中最大的，再加上当前节点1，就会得到结果；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: Optional[TreeNode]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        leftMax = self.maxDepth(root.left)</span><br><span class="line">        rightMax = self.maxDepth(root.right)</span><br><span class="line"></span><br><span class="line">        depth = max(leftMax, rightMax) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure><h1 id="3-559-N-叉树的最大深度"><a href="#3-559-N-叉树的最大深度" class="headerlink" title="3.559. N 叉树的最大深度"></a>3.<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N 叉树的最大深度</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给定一个 N 叉树，找到其最大深度。</p><p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p><p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,3,2,4,null,5,6]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示：</p><p>树的深度不会超过 1000 。<br>树的节点数目位于 [0, 104] 之间。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>N叉树的在递归的时候需要把每个节点都遍历一遍，可以参考上面二叉树的思路；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">            ans = max(ans, self.maxDepth(chl))</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="4-111-二叉树的最小深度"><a href="#4-111-二叉树的最小深度" class="headerlink" title="4.111. 二叉树的最小深度"></a>4.<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点数的范围在 [0, 105] 内<br>-1000 &lt;= Node.val &lt;= 1000</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>分三种情况考虑：</p><p>第一种情况：如果左右孩子均为空，说明是叶子结点，返回为1；</p><p>第二种情况：如果左右孩子只有一个为空，则返回两者中最小的一个；</p><p>第三种情况：边界问题，如果当前节点为空，则返回0；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left = self.minDepth(root.left)</span><br><span class="line">        right = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span>  <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> left + right + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        ans = <span class="number">10</span> ** <span class="number">9</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            ans = min(self.minDepth(root.left), ans)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            ans = min(self.minDepth(root.right), ans)</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之多重背包问题</title>
      <link href="2022/01/04/220104%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
      <url>2022/01/04/220104%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1.知识讲解"></a>1.知识讲解</h1><blockquote><p>01、完全、多重背包的异同</p></blockquote><table><thead><tr><th></th><th>01背包</th><th>完全背包</th><th>多重背包</th><th></th></tr></thead><tbody><tr><td>目的</td><td>求最大价值</td><td>求最大价值</td><td>求最大价值</td><td></td></tr><tr><td><strong>每件物品数量</strong></td><td>一件</td><td>无限件</td><td>有限件</td><td></td></tr></tbody></table><p>01背包是后两种背包问题的基础，唯一的变化就是每件物品的数量是不同的。而完全背包与多重背包存在更大的相似性，唯一的改变就是<strong>每件物品的数量是有限件，相当于对完全背包中的k进行了限定。</strong></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>其中N为物品种类数，V为背包体积，v为每个物品占用的体检，w为物品的价值，s为每个物品的数量；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 4, V &#x3D; 10, v &#x3D; [1,2,3,4], w &#x3D; [1,4,5,10], s &#x3D; [1, 2, 5, 2, 3]</span><br><span class="line">输出: 24</span><br><span class="line">解释: 选一件物品2，再选两件物品 4，可使价值最大。</span><br></pre></td></tr></table></figure><blockquote><p>定义状态</p></blockquote><p>前n个物品的在体积V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题。</p><p><strong>dp[i] [j]定义 为前i个物品放入到体积为j的背包中可以获得的最大价值。</strong></p><blockquote><p>状态方程</p></blockquote><p>由于每个物品i可以被选择多次，因此对于dp[i] [j]来说，它的可能取值为：</p><ul><li><p>选择0件物品i的价值，即dp[i-1] [j]</p></li><li><p>选择1件物品i的价值，即dp[i-1] [j - 1 * v[i]] + 1 * w[i]</p></li><li><p>选择2件物品i的价值，即dp[i-1] [j - 2 * v[i]] + 2 * w[i]</p><p>……</p></li><li><p>选择s[i]件物品i的价值，即dp[i-1] [j - s[i]* v[i]] + s[i] * w[i]</p></li></ul><p>状态转移方程为所有可能取值中的最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - k * v[i]] + k * w[i]), 0 &lt; k * v[j] &lt;&#x3D; j and k &lt;&#x3D; s[i]</span><br></pre></td></tr></table></figure><blockquote><p>边界</p></blockquote><p>先考虑dp[0] [j]的情况，对于容量为j的背包，把v[0]放进去，最大的价值是多少 ，需要满足条件：*<em>0 &lt; k * v[0] &lt;= j and k &lt;= s[0]。*</em></p><h2 id="解法一：N为数组"><a href="#解法一：N为数组" class="headerlink" title="解法一：N为数组"></a>解法一：N为数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiplePack</span>(<span class="params">N, V, v, w, s</span>):</span></span><br><span class="line">    <span class="comment"># N维数组</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="comment"># 初始状态， 前0件的最大价值为j//v[0]（背包可以放）和s[0]之间的最小者</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = min(j // v[<span class="number">0</span>], s[<span class="number">0</span>]) * w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= k * v[i] <span class="keyword">and</span> k &lt;= s[i]:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i<span class="number">-1</span>][j-k*v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：二维数组"><a href="#解法二：二维数组" class="headerlink" title="解法二：二维数组"></a>解法二：二维数组</h2><p>采用滚动数组的方法，我们把N为数组降维到二维数组；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiplePack</span>(<span class="params">N, V, v, w, s</span>):</span></span><br><span class="line">    <span class="comment"># 滚动数组，优化为二维数组</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="comment"># 初始状态， 前0件的最大价值为j//v[0]（背包可以放）和s[0]之间的最小者</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = min(j // v[<span class="number">0</span>], s[<span class="number">0</span>]) * w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= k * v[i] <span class="keyword">and</span> k &lt;= s[i]:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[i &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-k*v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法三：一维数组"><a href="#解法三：一维数组" class="headerlink" title="解法三：一维数组"></a>解法三：一维数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiplePack</span>(<span class="params">N, V, v, w, s</span>):</span></span><br><span class="line">    <span class="comment"># 优化为一维数组</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= k * v[i] <span class="keyword">and</span> k &lt;= s[i]:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-k*v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="2-474-一和零"><a href="#2-474-一和零" class="headerlink" title="2.474. 一和零"></a>2.<a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m &#x3D; 5, n &#x3D; 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs &#x3D; [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m &#x3D; 1, n &#x3D; 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= strs.length &lt;= 600<br>1 &lt;= strs[i].length &lt;= 100<br>strs[i] 仅由 ‘0’ 和 ‘1’ 组成<br>1 &lt;= m, n &lt;= 100</p><h2 id="解法一：dp-N-m-1-n-1-三维度数组"><a href="#解法一：dp-N-m-1-n-1-三维度数组" class="headerlink" title="解法一：dp[N] [m+1] [n+1]三维度数组"></a>解法一：dp[N] [m+1] [n+1]三维度数组</h2><p>因为需要考虑0和1的数量，所以之前的二维数组不能够解决这个问题了，所以需要使用三维数组。dp[k] [i] [j]代表，前k个元素在i个0和j个1的情况下，最大价值是多少。</p><p>每个元素的成本为（0和1的个数），价值为1；</p><blockquote><p>状态转移方程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[k][i][j] &#x3D; max(dp[k-1][i][j], dp[k-1][i-zero][j-one]) 其中zero、one代表当前k的0和1的个数</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[str], m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 首先保存0 1 的个数</span></span><br><span class="line">        cnt = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            cnt.append([s.count(<span class="string">&#x27;0&#x27;</span>), s.count(<span class="string">&#x27;1&#x27;</span>)])</span><br><span class="line">        N = len(strs)</span><br><span class="line">        <span class="comment"># 创建dp数组三维，前k个元素在i和j的情况下有多少种子集</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= cnt[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">and</span> j &gt;= cnt[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            zero, one = cnt[k][<span class="number">0</span>], cnt[k][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                    a = dp[k<span class="number">-1</span>][i][j]</span><br><span class="line">                    <span class="keyword">if</span> i &gt;= zero <span class="keyword">and</span> j &gt;= one:</span><br><span class="line">                        b = dp[k<span class="number">-1</span>][i-zero][j-one] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        b = <span class="number">0</span></span><br><span class="line">                    dp[k][i][j] = max(a, b)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：滚动数组，优化空间"><a href="#解法二：滚动数组，优化空间" class="headerlink" title="解法二：滚动数组，优化空间"></a>解法二：滚动数组，优化空间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[str], m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 首先保存0 1 的个数</span></span><br><span class="line">        cnt = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            cnt.append([s.count(<span class="string">&#x27;0&#x27;</span>), s.count(<span class="string">&#x27;1&#x27;</span>)])</span><br><span class="line">        N = len(strs)</span><br><span class="line">        <span class="comment"># 创建dp数组三维，前k个元素在i和j的情况下有多少种子集</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="comment"># 边界</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= cnt[<span class="number">0</span>][<span class="number">0</span>] <span class="keyword">and</span> j &gt;= cnt[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[<span class="number">0</span>][i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            zero, one = cnt[k][<span class="number">0</span>], cnt[k][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">                    a = dp[(k<span class="number">-1</span>) &amp; <span class="number">1</span>][i][j]</span><br><span class="line">                    b = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt;= zero <span class="keyword">and</span> j &gt;= one:</span><br><span class="line">                        b = dp[(k<span class="number">-1</span>) &amp; <span class="number">1</span>][i-zero][j-one] + <span class="number">1</span></span><br><span class="line">                    dp[k &amp; <span class="number">1</span>][i][j] = max(a, b)</span><br><span class="line">        <span class="keyword">return</span> dp[(N - <span class="number">1</span>) &amp; <span class="number">1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法三：转化为01背包问题"><a href="#解法三：转化为01背包问题" class="headerlink" title="解法三：转化为01背包问题"></a>解法三：转化为01背包问题</h2><blockquote><p>本题的状态转移方程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> dp[k][i][j] &#x3D; max(dp[k-1][i][j], dp[k-1][i-zero][j-one])</span><br><span class="line">#通过这个可以看出dp[k][i][j]与其上方元素以及上方左侧元素有关</span><br><span class="line"></span><br><span class="line">dp[i][j] &#x3D; max(dp[i][j], dp[i-zero][j-one]) </span><br></pre></td></tr></table></figure><blockquote><p>01背包的状态转移方程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1] [j - v[i]] + w[i])</span><br><span class="line"></span><br><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><p>通过对比上面两个状态转移方程，可以看出两种具有很多共同的地方，两者当前的值都是由当前元素上一行对应的值以及上一行左边的值决定的，所以我们就可以简化，降低维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span>(<span class="params">self, strs: List[str], m: int, n: int</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># 首先保存0 1 的个数</span></span><br><span class="line">        cnt = []</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            cnt.append([s.count(<span class="string">&#x27;0&#x27;</span>), s.count(<span class="string">&#x27;1&#x27;</span>)])</span><br><span class="line">        N = len(strs)</span><br><span class="line">        <span class="comment"># 创建dp数组三维，前k个元素在i和j的情况下有多少种</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">            zero, one = cnt[k][<span class="number">0</span>], cnt[k][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m, zero<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n, one<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                     dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-879-盈利计划"><a href="#3-879-盈利计划" class="headerlink" title="3.879. 盈利计划"></a>3.<a href="https://leetcode-cn.com/problems/profitable-schemes/">879. 盈利计划</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>集团里有 n 名员工，他们可以完成各种各样的工作创造利润。</p><p>第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p><p>工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。</p><p>有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 5, minProfit &#x3D; 3, group &#x3D; [2,2], profit &#x3D; [2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。</span><br><span class="line">总的来说，有两种计划。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 10, minProfit &#x3D; 5, group &#x3D; [2,3,5], profit &#x3D; [6,7,8]</span><br><span class="line">输出：7</span><br><span class="line">解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。</span><br><span class="line">有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= n &lt;= 100<br>0 &lt;= minProfit &lt;= 100<br>1 &lt;= group.length &lt;= 100<br>1 &lt;= group[i] &lt;= 100<br>profit.length == group.length<br>0 &lt;= profit[i] &lt;= 100</p><h2 id="解法一：多维数组"><a href="#解法一：多维数组" class="headerlink" title="解法一：多维数组"></a>解法一：多维数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span>(<span class="params">self, n: int, minProfit: int, group: List[int], profit: List[int]</span>) -&gt; int:</span></span><br><span class="line">        m = len(group)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># N为个数，n为背包大小 minProfit为</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (minProfit + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>) ]<span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当利润为0时</span></span><br><span class="line">            dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i的下标从1开始</span></span><br><span class="line">            a, b = group[i<span class="number">-1</span>], profit[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(minProfit+<span class="number">1</span>):</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k]</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= a:</span><br><span class="line">                        dp[i][j][k] += dp[i<span class="number">-1</span>][j-a][max(<span class="number">0</span>, k-b)]</span><br><span class="line">                        <span class="keyword">if</span> dp[i][j][k] &gt;= mod:</span><br><span class="line">                            dp[i][j][k] -= mod</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：优化空间，滚动数组"><a href="#解法二：优化空间，滚动数组" class="headerlink" title="解法二：优化空间，滚动数组"></a>解法二：优化空间，滚动数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span>(<span class="params">self, n: int, minProfit: int, group: List[int], profit: List[int]</span>) -&gt; int:</span></span><br><span class="line">        m = len(group)</span><br><span class="line">        mod = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># N为个数，n为背包大小 minProfit为</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (minProfit + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>) ]<span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 当利润为0时</span></span><br><span class="line">            dp[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># i的下标从1开始</span></span><br><span class="line">            a, b = group[i<span class="number">-1</span>], profit[i<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(minProfit+<span class="number">1</span>):</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j][k] = dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][k]</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= a:</span><br><span class="line">                        dp[i&amp;<span class="number">1</span>][j][k] += dp[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j-a][max(<span class="number">0</span>, k-b)]</span><br><span class="line">                        <span class="keyword">if</span> dp[i&amp;<span class="number">1</span>][j][k] &gt;= mod:</span><br><span class="line">                            dp[i&amp;<span class="number">1</span>][j][k] -= mod</span><br><span class="line">        <span class="keyword">return</span> dp[m &amp; <span class="number">1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法三：降低维度"><a href="#解法三：降低维度" class="headerlink" title="解法三：降低维度"></a>解法三：降低维度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profitableSchemes</span>(<span class="params">self, n: int, minProfit: int, group: List[int], profit: List[int]</span>) -&gt; int:</span></span><br><span class="line">        m = len(group)</span><br><span class="line">        MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        <span class="comment"># N为个数，n为背包大小 minProfit为</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (<span class="number">1</span> + minProfit) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span> + n)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="comment"># i的下标从1开始</span></span><br><span class="line">            a, b = group[i], profit[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n, a<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(minProfit, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    dp[j][k] += dp[j-a][max(<span class="number">0</span>, k-b)] % MOD</span><br><span class="line"></span><br><span class="line">        ans = sum(dp[i][minProfit] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>+n))</span><br><span class="line">        <span class="keyword">return</span> ans % MOD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之完全背包问题</title>
      <link href="2022/01/02/220103CompletePack/"/>
      <url>2022/01/02/220103CompletePack/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识讲解"><a href="#1-知识讲解" class="headerlink" title="1.知识讲解"></a>1.知识讲解</h1><blockquote><p>回顾一下01背包</p></blockquote><p>有N种物品和一个容量为V的背包，每种物品只有一种。第i件物品的体积是v[i] ，价值是w[i]。</p><blockquote><p>完全背包</p></blockquote><p>有N种物品和一个容量为V的背包，每种物品都有无限多种。第i件物品的体积是v[i] ，价值是w[i]。</p><blockquote><p>两者的区别</p></blockquote><p><strong><u>完全背包</u>**是在</strong><u>01背包</u><strong>的基础上增加了一个条件：</strong>每种物品可以取无限多次（在背包容量满足的条件下）**。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 4, V &#x3D; 10, v &#x3D; [1,2,3,4], w &#x3D; [1,4,5,10]</span><br><span class="line">输出: 24</span><br><span class="line">解释: 选一件物品2，再选两件物品 4，可使价值最大。</span><br></pre></td></tr></table></figure><h2 id="解法一：定义数组dp-N-V-1"><a href="#解法一：定义数组dp-N-V-1" class="headerlink" title="解法一：定义数组dp[N] [V+1]"></a>解法一：定义数组dp[N] [V+1]</h2><blockquote><p>定义状态</p></blockquote><p>前n个物品的在体积V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题。</p><p><strong>dp[i] [j]定义 为前i个物品放入到体积为j的背包中可以获得的最大价值。</strong></p><blockquote><p>状态方程</p></blockquote><p>由于每个物品i可以被选择多次，因此对于dp[i] [j]来说，它的可能取值为：</p><ul><li><p>选择0件物品i的价值，即dp[i-1] [j]</p></li><li><p>选择1件物品i的价值，即dp[i-1] [j - 1 * v[i]] + 1 * w[i]</p></li><li><p>选择2件物品i的价值，即dp[i-1] [j - 2 * v[i]] + 2 * w[i]</p><p>……</p></li><li><p>选择k件物品i的价值，即dp[i-1] [j - k * v[i]] + k * w[i]</p></li></ul><p>状态转移方程为所有可能取值中的最大值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - k * v[i]] + k * w[i]), 0 &lt; k * v[j] &lt;&#x3D; j</span><br></pre></td></tr></table></figure><blockquote><p>边界</p></blockquote><p>先考虑dp[0] [j]的情况，对于容量为j的背包，把v[0]放进去，最大的价值是多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">completepack</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j // v[<span class="number">0</span>] * w[<span class="number">0</span>]</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V+<span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= v[i] * k:</span><br><span class="line">                dp[i][j] = max(dp[i][j], dp[i - <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：定义数组dp-2-V-1-，采用滚动数组"><a href="#解法二：定义数组dp-2-V-1-，采用滚动数组" class="headerlink" title="解法二：定义数组dp[2] [V+1]，采用滚动数组"></a>解法二：定义数组dp[2] [V+1]，采用滚动数组</h2><p>根据状态方程我们可以知道，dp[i] [j]的结果只与dp[i-1]相关，因此我们可以参考01背包的方法来优化空间，只需要用一个二维的数组即可解决问题。dp[0]和dp[1]轮流交替使用，例如i=1时，dp[1]根据dp[0]的结果获得；i=2时，dp[2]可以转换为dp[0]， 然后再根据dp[1]的结果获得；</p><p>需要做的就是判断当前i是奇数还是偶数即可，一种方法是用i % 2 == 0?来判断；一种方法是让i&amp;1进行与运算判断；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">completepack</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = j // v[<span class="number">0</span>] * w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= v[i] * k:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[i &amp; <span class="number">1</span>][j], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - k * v[i]] + k * w[i])</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="解法二：定义数组-V-1-、一维空间"><a href="#解法二：定义数组-V-1-、一维空间" class="headerlink" title="解法二：定义数组[V+1]、一维空间"></a>解法二：定义数组[V+1]、一维空间</h2><blockquote><p>01背包：优化为一维空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - v[i]] + w[i])</span><br></pre></td></tr></table></figure><p>dp[i] [j]的结果只与dp[i-1] [j],  dp[i-1] [j - v[i]]这两个元素有关，因此我们可以把从0到V遍历求解改为从V到0遍历求解，这样就可以每次先把上一次的dp[j-v[i]]保存下来，然后当前再遍历的时候比较一下结果是否发生改变，取最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><blockquote><p>完全背包：优化为一维度空间</p></blockquote><p>对于完全背包可以参照01背包进行类似推导，详情参考下图，（图源：宫水三叶的刷题笔记）</p><img src="/2022/01/02/220103CompletePack/1.png" class><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 原始状态转移方程</span><br><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - k * v[i]] + k * w[i]), 0 &lt; k * v[j] &lt;&#x3D; j</span><br><span class="line"># 第一次优化</span><br><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i-1][j - v[i]] + w[i])</span><br><span class="line"># 一维优化</span><br><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">completepack</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j - v[i] &gt;= <span class="number">0</span>:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-v[i]] + w[i])</span><br><span class="line">        print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="2-279-完全平方数"><a href="#2-279-完全平方数" class="headerlink" title="2.279. 完全平方数"></a>2.<a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 </p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 &#x3D; 4 + 4 + 4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n &#x3D; 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 &#x3D; 4 + 9</span><br></pre></td></tr></table></figure><h2 id="思路（以示例1为例）"><a href="#思路（以示例1为例）" class="headerlink" title="思路（以示例1为例）"></a>思路（以示例1为例）</h2><p>这是一个典型的完全背包问题，根据题意我们可以把问题转换重新描述一下：</p><p><strong><u>有三种物品N=3，体积为V=12，物品体积v=[1, 4, 9]，由于是求最小可能的组合数量，因此w=[1,1,1]，每个物品选择一次价值为1。</u></strong></p><p><strong>定义数组</strong>：dp = [100000] * (n + 1)，这里是求最小的组合数量，所以dp的初始值设置大一点（也可以设置为无穷大），<strong>dp[j]含义</strong>代表当体积为j时组合的数量为dp[j]。</p><p><strong>定义状态方程</strong>：dp[j] = min(dp[j], dp[j-v[i]] + w[i])，因为w[i] = 1,所以这里可以直接写为1，也可以写w[i]，由于是求最小值，所以用min而不是max。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [n + <span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        j = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 由于v需要我们自己生成，所以用循环判断平方即可</span></span><br><span class="line">        <span class="keyword">while</span> j * j &lt;= n:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= j * j:</span><br><span class="line">                    dp[i] = min(dp[i], dp[i-j*j] + <span class="number">1</span>)</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line">       </span><br></pre></td></tr></table></figure><p>也可以用下面这种解法遍历，两种遍历的结果一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n: int</span>) -&gt; int:</span></span><br><span class="line">        dp = [n + <span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j * j &lt;= i:</span><br><span class="line">                dp[i] = min(dp[i], dp[i - j * j] + <span class="number">1</span>)</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="3-322-零钱兑换"><a href="#3-322-零钱兑换" class="headerlink" title="3.322. 零钱兑换"></a>3.<a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个是比较典型的完全背包问题，但是需要注意的是，因为最终并不一定能够是的coins中的钱可以成功兑换为amount，例如coins = [2], amount = 3，所以我们需要加入一个value数组，其中value[j]=j的时候说明可以coins中的钱可以兑换为总金额为j的钱。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[int], amount: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [amount + <span class="number">1</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        value = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i] <span class="keyword">and</span> value[j-coins[i]] + coins[i] == j:</span><br><span class="line">                    dp[j] = min(dp[j], dp[j-coins[i]] + <span class="number">1</span>)</span><br><span class="line">                    value[j] = j</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> value[<span class="number">-1</span>] == amount <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="优化时空复杂度"><a href="#优化时空复杂度" class="headerlink" title="优化时空复杂度"></a>优化时空复杂度</h2><p>为了能够降低时空复杂度，我们可以考虑不使用value数组，而是根据dp数组判断。</p><p>dp数组初始值定义为无穷大∞，因为我们要求的是最小值，所以要定义为无穷大；同样如果题目求的是最大值，我们就可以直接定义为0。</p><p>为了判断最终dp[amount]这个是否能够通过coins凑齐，只要判断dp[amount]的值是否发生变化，只要不再是float(‘inf’)就说明发生了变化，可以凑齐；否则就是不能凑齐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins: List[int], amount: int</span>) -&gt; int:</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [float(<span class="string">&#x27;inf&#x27;</span>)] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] = min(dp[j], dp[j-coins[i]] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] <span class="keyword">if</span> dp[<span class="number">-1</span>] != float(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h1 id="4-518-零钱兑换-II"><a href="#4-518-零钱兑换-II" class="headerlink" title="4.518. 零钱兑换 II"></a>4.<a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。 </p><p>题目数据保证结果符合 32 位带符号整数。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 5, coins &#x3D; [1, 2, 5]</span><br><span class="line">输出：4</span><br><span class="line">解释：有四种方式可以凑成总金额：</span><br><span class="line">5&#x3D;5</span><br><span class="line">5&#x3D;2+2+1</span><br><span class="line">5&#x3D;2+1+1+1</span><br><span class="line">5&#x3D;1+1+1+1+1</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 3, coins &#x3D; [2]</span><br><span class="line">输出：0</span><br><span class="line">解释：只用面额 2 的硬币不能凑成总金额 3 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：amount &#x3D; 10, coins &#x3D; [10] </span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先，定义dp[j] 代表能够构成金额j的方法有dp[j]种；</p><p>接着，定义边界，dp[0] = 1构成金额0的有一种；</p><p>接着，定义状态方程，dp[j] += dp[j-coins[i]] 这里我们不用管dp[j-coins[i]]是否为0，如果dp[j-coins[i]]不为0，说明可以在dp[j-coins[i]]的基础上加coins[i]构成dp[j]；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount: int, coins: List[int]</span>) -&gt; int:</span></span><br><span class="line">        n = len(coins)</span><br><span class="line">        dp = [<span class="number">0</span>] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(coins[i], amount + <span class="number">1</span>):</span><br><span class="line">                dp[j] += dp[j-coins[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-1449-数位成本和为目标值的最大数字"><a href="#5-1449-数位成本和为目标值的最大数字" class="headerlink" title="5.1449. 数位成本和为目标值的最大数字"></a>5.<a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/">1449. 数位成本和为目标值的最大数字</a></h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：</p><p>给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。<br>总成本必须恰好等于 target 。<br>添加的数位中没有数字 0 。<br>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [4,3,2,5,6,7,2,5,5], target &#x3D; 9</span><br><span class="line">输出：&quot;7772&quot;</span><br><span class="line">解释：添加数位 &#39;7&#39; 的成本为 2 ，添加数位 &#39;2&#39; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 &#x3D; 9 。 &quot;977&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  1  -&gt;   4</span><br><span class="line">  2  -&gt;   3</span><br><span class="line">  3  -&gt;   2</span><br><span class="line">  4  -&gt;   5</span><br><span class="line">  5  -&gt;   6</span><br><span class="line">  6  -&gt;   7</span><br><span class="line">  7  -&gt;   2</span><br><span class="line">  8  -&gt;   5</span><br><span class="line">  9  -&gt;   5</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [7,6,5,5,5,6,8,7,8], target &#x3D; 12</span><br><span class="line">输出：&quot;85&quot;</span><br><span class="line">解释：添加数位 &#39;8&#39; 的成本是 7 ，添加数位 &#39;5&#39; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 &#x3D; 12 。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [2,4,6,2,4,6,4,4,4], target &#x3D; 5</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost &#x3D; [6,10,15,40,40,40,40,40,40], target &#x3D; 47</span><br><span class="line">输出：&quot;32211&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p>cost.length == 9<br>1 &lt;= cost[i] &lt;= 5000<br>1 &lt;= target &lt;= 5000</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这一题就是典型的完全背包问题，首先我们进行问题转换：</p><p>总共有9个物体，每个物体占用的体积是cost[i]，背包大小为target，每个物体的价值为i，最后用所有的i来组成的数字最大。</p><p>我们直接写一维数组，每次数组中保存的是前i个数字中在背包大小为j的情况下能组成的最大数字。由于遍历是从1-9，但是组成数字的时候我们要写成：**tmp = str(i) + dp[j - cost[i]]**，这样的意思是后面加入的数字比较大，作为一个数的高位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span>(<span class="params">self, cost: List[int], target: int</span>) -&gt; str:</span></span><br><span class="line">        cost = [<span class="number">0</span>] + cost</span><br><span class="line">        dp = [<span class="string">&#x27;0&#x27;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(target + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(cost[i], target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j - cost[i]] != <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">                    tmp = str(i) + dp[j - cost[i]]</span><br><span class="line">                    dp[j] = self.compare(dp[j], tmp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self, a: str, b: str</span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> len(a) == len(b):    </span><br><span class="line">            <span class="keyword">return</span> max(a, b)</span><br><span class="line">        <span class="keyword">elif</span> len(a) &gt; len(b):   </span><br><span class="line">            <span class="keyword">return</span> a</span><br><span class="line">        <span class="keyword">else</span>:                   </span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247486107&amp;idx=1&amp;sn=e5fa523008fc5588737b7ed801caf4c3&amp;chksm=fd9ca184caeb28926959c0987208a3932ed9c965267ed366b5b82a6fc16d42f1ff40c29db5f1&amp;token=990510480&amp;lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247486107&amp;idx=1&amp;sn=e5fa523008fc5588737b7ed801caf4c3&amp;chksm=fd9ca184caeb28926959c0987208a3932ed9c965267ed366b5b82a6fc16d42f1ff40c29db5f1&amp;token=990510480&amp;lang=zh_CN#rd</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode周赛1月2日</title>
      <link href="2022/01/02/220102%E5%91%A8%E8%B5%9B/"/>
      <url>2022/01/02/220102%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="第一题：5967-检查是否所有-A-都在-B-之前"><a href="#第一题：5967-检查是否所有-A-都在-B-之前" class="headerlink" title="第一题：5967. 检查是否所有 A 都在 B 之前"></a>第一题：<a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">5967. 检查是否所有 A 都在 B 之前</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>仅</strong> 由字符 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 组成的字符串 <code>s</code> 。如果字符串中 <strong>每个</strong> <code>&#39;a&#39;</code> 都出现在 <strong>每个</strong> <code>&#39;b&#39;</code> 之前，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaabbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">&#39;a&#39; 位于下标 0、1 和 2 ；而 &#39;b&#39; 位于下标 3、4 和 5 。</span><br><span class="line">因此，每个 &#39;a&#39; 都出现在每个 &#39;b&#39; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abab&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">存在一个 &#39;a&#39; 位于下标 2 ，而一个 &#39;b&#39; 位于下标 1 。</span><br><span class="line">因此，不能满足每个 &#39;a&#39; 都出现在每个 &#39;b&#39; 之前，所以返回 false 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;bbb&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">不存在 &#39;a&#39; ，因此可以视作每个 &#39;a&#39; 都出现在每个 &#39;b&#39; 之前，所以返回 true 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s[i]</code> 为 <code>&#39;a&#39;</code> 或 <code>&#39;b&#39;</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>设置一个flag，初始为False，如果遇到b则为True，只要判断再次遇到a就直接返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkString</span>(<span class="params">self, s: str</span>) -&gt; bool:</span></span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">False</span>:</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">if</span> ch == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="第二题：5968-银行中的激光束数量"><a href="#第二题：5968-银行中的激光束数量" class="headerlink" title="第二题：5968. 银行中的激光束数量"></a>第二题：<a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">5968. 银行中的激光束数量</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 ‘0’ 和若干 ‘1’ 组成。’0’ 表示单元格是空的，而 ‘1’ 表示单元格有一个安全设备。</p><p>对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：</p><p>两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 &lt; r2 。<br>满足 r1 &lt; i &lt; r2 的 所有 行 i ，都 没有安全设备 。<br>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p><p>返回银行中激光束的总数量。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank &#x3D; [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]</span><br><span class="line">输出：8</span><br><span class="line">解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bank &#x3D; [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在两个位于不同行的设备</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><p>m == bank.length<br>n == bank[i].length<br>1 &lt;= m, n &lt;= 500</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们先把每一行bank[i]中的1统计出来放到一个result数组，例如示例 1中统计之后的result=[3,0,2,1]。这样我们只要遍历这个数组即可：3 * 2 + 2 * 1 = 8；令start为result[0]，然后找到bank[i]不为0的时候就可以找到一组激光，更新start为bank[i]直到遍历结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numberOfBeams</span>(<span class="params">self, bank: List[str]</span>) -&gt; int:</span></span><br><span class="line">        m, n = len(bank), len(bank[<span class="number">0</span>])</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> bank[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">            result.append(res)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        start = result[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> start != <span class="number">0</span> <span class="keyword">and</span> result[i] != <span class="number">0</span>:</span><br><span class="line">                ans += start * result[i]</span><br><span class="line">                start = result[i]</span><br><span class="line">            <span class="keyword">elif</span> start == <span class="number">0</span> <span class="keyword">and</span> result[i] != <span class="number">0</span>:</span><br><span class="line">                start = result[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="第三题：5969-摧毁小行星"><a href="#第三题：5969-摧毁小行星" class="headerlink" title="第三题：5969. 摧毁小行星"></a>第三题：<a href="https://leetcode-cn.com/problems/destroying-asteroids/">5969. 摧毁小行星</a></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。</p><p>你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。</p><p>如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：mass &#x3D; 10, asteroids &#x3D; [3,9,19,5,21]</span><br><span class="line">输出：true</span><br><span class="line">解释：一种安排小行星的方式为 [9,19,5,3,21] ：</span><br><span class="line"></span><br><span class="line">- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 &#x3D; 19</span><br><span class="line">- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 &#x3D; 38</span><br><span class="line">- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 &#x3D; 43</span><br><span class="line">- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 &#x3D; 46</span><br><span class="line">- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 &#x3D; 67</span><br><span class="line">  所有小行星都被摧毁。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mass &#x3D; 5, asteroids &#x3D; [4,9,23,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。</span><br><span class="line">行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 &#x3D; 22 。</span><br><span class="line">它比 23 小，所以无法摧毁最后一颗小行星。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= mass &lt;= 105<br>1 &lt;= asteroids.length &lt;= 105<br>1 &lt;= asteroids[i] &lt;= 105</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>把数组排序</p><p>首先判断一下不能够将所有小行星摧毁的条件：mass不能比最小的小行星小；行星合并除了最大小行星之外的小行星之后的质量不能够比最大小行星小，即2 * asteroids[-1] &gt; sum(asteroids) + mass；</p><p>其次，我们只需要遍历数组即可，每次遇到一个小星星，如果符合要求就摧毁它，并获得它的质量，否则就反悔False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">asteroidsDestroyed</span>(<span class="params">self, mass: int, asteroids: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        asteroids.sort()</span><br><span class="line">        <span class="keyword">if</span> mass &lt; asteroids[<span class="number">0</span>] <span class="keyword">or</span> <span class="number">2</span> * asteroids[<span class="number">-1</span>] &gt; sum(asteroids) + mass:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(asteroids)):</span><br><span class="line">            <span class="keyword">if</span> mass &gt;= asteroids[i]:</span><br><span class="line">                mass += asteroids[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="第四题：5970-参加会议的最多员工数"><a href="#第四题：5970-参加会议的最多员工数" class="headerlink" title="第四题：5970. 参加会议的最多员工数"></a>第四题：<a href="https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/">5970. 参加会议的最多员工数</a></h1><p>这一题不会做，还需要继续加强，做出来三个题的速度大概在25min，由于最后一个题，条件少加一个等于号，导致提交判错加时一次，争取下次可以获得更好的成绩。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之01背包问题</title>
      <link href="2021/12/31/211231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/12/31/211231-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-01背包dp-N-V-1-（第一讲）"><a href="#1-01背包dp-N-V-1-（第一讲）" class="headerlink" title="1.01背包dp[N] [V+1]（第一讲）"></a>1.01背包dp[N] [V+1]（第一讲）</h1><p>有 N 件物品和一个容量为 V 的背包。第 i 件物品的体积是 v[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大，求出最大总价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: N &#x3D; 3, V &#x3D; 5, v &#x3D; [4,2,3], w &#x3D; [4,2,3]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 不选第一件物品，选择第二件和第三件物品，可使价值最大。</span><br></pre></td></tr></table></figure><p>考虑上面的这个输入，我们用表格来思考一下，我们考虑放入前i件物品获得的最大价值是多少</p><table><thead><tr><th>i\V</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4</td><td>4</td></tr><tr><td>2</td><td>0</td><td>0</td><td>2</td><td>2</td><td>4</td><td>4</td></tr><tr><td>3</td><td>0</td><td>0</td><td>0</td><td>3</td><td>4</td><td>4</td></tr></tbody></table><blockquote><p>定义状态</p></blockquote><p>前n个物品的在体积V处的最大价值可以通过前n-1个物品推到出来，因此我们可以把问题拆解为第i个问题和第i-1个问题，定义dp[i] [j] 为前i个物品放入到体积为j的背包中可以获得的最大价值。</p><blockquote><p>状态方程</p></blockquote><p>对于每个<strong>物品i（体积v[i]价值w[i]）</strong>我们都有两种选择：<strong>放入背包或不放入背包</strong>，是否放入取决于两个条件，第一：背包的容量是否足够；第二：放入之后的总价值与不放入到总价值哪个更大。</p><ul><li><strong>空间不足的时候</strong>，第i个物品放不进去，那么最大价值就是前i-1个物品的价值：<ul><li>dp[i] [j] = dp[i-1] [j]</li></ul></li><li><strong>空间充足的时候</strong>，能够放入第i个物品，但是我们必须要判断是选择放还是不放，<strong>判断的依据就是不放进去和放进去的价值大小</strong>，并选择两者中较大者：<ul><li>不放为：dp[i-1] [j]</li><li>放进去为：dp[i-1] [j - v[i]] + w[i] （因为要放进去，所以留给前i-1个物品的大小只有j-v[i]了，然后再加上w[i]）</li><li>最终dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j - v[i]] + w[i])</li></ul></li></ul><blockquote><p>边界条件</p></blockquote><p>当只放入第一件物品的时候，只需要判断当前的空间j是否能够放入v[0]即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">self, N, V, v, w</span>) -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][j] = w[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; v[i]:</span><br><span class="line">                    <span class="comment"># 空间不足</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 空间充足</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-v[i]] + w[i])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][V]</span><br></pre></td></tr></table></figure><h1 id="2-01背包优化为二维dp-2-V-1"><a href="#2-01背包优化为二维dp-2-V-1" class="headerlink" title="2.01背包优化为二维dp[2] [V+1]"></a>2.01背包优化为二维dp[2] [V+1]</h1><p>通过上面的表格我们可以发现，当前行的结果只与上一行的结果有关，因此我们可以用一个二维数组来保存结果，这样可以更加节省空间。只需要判断当前行是奇数行还是偶数行即可，这里我们用的是i &amp; 1 这个操作，也可以用i%2这个来做判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (V + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">if</span> j &gt;= v[<span class="number">0</span>]:</span><br><span class="line">            dp[<span class="number">0</span>][j] = w[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 空间不足</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; v[i]:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-v[i]] + w[i])</span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[(N<span class="number">-1</span>)&amp;<span class="number">1</span>][V]</span><br></pre></td></tr></table></figure><h1 id="3-01背包优化一维dp-V-1"><a href="#3-01背包优化一维dp-V-1" class="headerlink" title="3.01背包优化一维dp[V+1]"></a>3.01背包优化一维dp[V+1]</h1><p>根据状态转移方程 $dp[i] [j] = max(dp[i-1] [j], dp[i-1] [j - v[i]] + w[i])$ 我们可以看出，dp[i] [j]只与dp[i-1] [j] 、dp[i-1] [j - v[i]] 这两个元素相关，<strong>即第i行的数值只与第i-1行的<u>第j个格子以及第j-v[i]个格子相关</u>。</strong></p><p>对于第i行，我们此时遍历的顺序是<strong>从0到V</strong>，只需要改为<strong>从V到0</strong>就可以不用到这两个元素，这样就可以从二维降低到一维。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] &#x3D; max(dp[j], dp[j-v[i]] + w[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPaths</span>(<span class="params">N, V, v, w</span>):</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (V + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(V, v[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> j &gt;= v[i]:</span><br><span class="line">                dp[j] = max(dp[j], dp[j-v[i]] + w[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    print(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="4-416-分割等和子集"><a href="#4-416-分割等和子集" class="headerlink" title="4.416. 分割等和子集"></a>4.<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,5,11,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以分割成 [1, 5, 5] 和 [11] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：数组不能分割成两个元素和相等的子集。</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 200<br>1 &lt;= nums[i] &lt;= 100</p><p>我们以这个题目为例，来体验一下01背包问题的三种解法，把思路再过一遍。</p><h2 id="第一种解法：dp-N-V-1-解法"><a href="#第一种解法：dp-N-V-1-解法" class="headerlink" title="第一种解法：dp[N] [V+1]解法"></a>第一种解法：dp[N] [V+1]解法</h2><ul><li>因为需要把一个数组分成两个等和子集，所以数组之和必须是偶数才能够保证分成两个，每个子集的和定义为target；</li><li>然后接下来的过程就是从数组中可以选元素，但是我们背包的大小是target；</li><li>状态转移函数和边界条件都和上面的推理过程一样；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-nums[i]] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="第二种解法：dp-2-V-1-解法"><a href="#第二种解法：dp-2-V-1-解法" class="headerlink" title="第二种解法：dp[2] [V+1]解法"></a>第二种解法：dp[2] [V+1]解法</h2><p>这种解法只需要在前者的基础上加一个判断i为0还是1即可；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= nums[<span class="number">0</span>]:</span><br><span class="line">                dp[<span class="number">0</span>][i] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &lt; nums[i]:</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = max(dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j], dp[(i<span class="number">-1</span>) &amp; <span class="number">1</span>][j-nums[i]] + nums[i])</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="第三种解法：dp-V-1-解法"><a href="#第三种解法：dp-V-1-解法" class="headerlink" title="第三种解法：dp [V+1]解法"></a>第三种解法：dp [V+1]解法</h2><p>这是第三种解法，依然类似与上面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[j] = max(dp[j], dp[j-nums[i]]+nums[i])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>] == target</span><br></pre></td></tr></table></figure><h2 id="解法优化"><a href="#解法优化" class="headerlink" title="解法优化"></a>解法优化</h2><p>由于题目只需要返回能否分割等和子集（true or false）因此在我们定义dp数组的时候可以定义为bool类型，这样可以节省计算的时间；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span>(<span class="params">self, nums: List[int]</span>) -&gt; bool:</span></span><br><span class="line">        sum_ = sum(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">False</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[<span class="number">-1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i]:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-nums[i]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="5-494-目标和"><a href="#5-494-目标和" class="headerlink" title="5.494. 目标和"></a>5.<a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 &#x3D; 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1], target &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= nums.length &lt;= 20<br>0 &lt;= nums[i] &lt;= 1000<br>0 &lt;= sum(nums[i]) &lt;= 1000<br>-1000 &lt;= target &lt;= 1000</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><blockquote><p>问题转换</p></blockquote><p>因为需要向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，所以最终我们得到的结果就是：正数之和+负数之和==target。<br>我们假设P是正子集，N是负子集，sum(P)代表正子集之和，sum(N)代表负子集之和。<br>例如： 假设nums = [1, 2, 3, 4, 5]，target = 3，一个可能的解决方案是+1-2+3-4+5 = 3 这里正子集P = [1, 3, 5]和负子集N = [2, 4]。</p><p>那么让我们看看如何将其转换为子集求和问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                  sum(P) - sum(N) &#x3D; target</span><br><span class="line">sum(P) + sum(N) + sum(P) - sum(N) &#x3D; target + sum(P) + sum(N)</span><br><span class="line">                       2 * sum(P) &#x3D; target + sum(nums)</span><br></pre></td></tr></table></figure><p>最终，我们可以得到sum(P)=(target + sum(nums))/2，<strong>所以我们的最终问题转换为求从数组nums中找到一组数，让其之和为sum(P)。</strong></p><blockquote><p>需要注意几个条件：</p></blockquote><p>第一：因为数组都是整数，所以target + sum(nums)必须是偶数；<br>第二：targe可能为负数，所以sum(nums)&lt;abs(target)即数组之和小于target的绝对值，例如：nums = [200], target=-100就是无法满足，返回0；（target为负数这个条件应该是题目最近新改的，我看很多题解都没有考虑到这个）</p><blockquote><p>状态转移</p></blockquote><p>动态规划定义dp长度为sum(P) + 1即可；<br>定义dp[j]为组成和为j的组合又dp[j]种， dp[j] += dp[j-nums[i]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTargetSumWays</span>(<span class="params">self, nums: List[int], target: int</span>) -&gt; int:</span></span><br><span class="line">        sum_ = sum(nums) + target</span><br><span class="line">        <span class="keyword">if</span> sum_ % <span class="number">2</span> <span class="keyword">or</span> sum(nums) &lt; abs(target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target = sum_ // <span class="number">2</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(target, nums[i]<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[j] += dp[j-nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>此为本人学习笔记，整理方便回顾，会参考到部分博主，尽可能会一一列明，如有遗漏请见谅。</p><p>参考资料：</p><p>宫水三叶的相关题解以及LeetCode相关题解</p><p><a href="https://blog.csdn.net/weixin_45594025/article/details/106112195">https://blog.csdn.net/weixin_45594025/article/details/106112195</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 背包问题 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解回溯算法</title>
      <link href="2021/12/29/211229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2021/12/29/211229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法详解"><a href="#算法详解" class="headerlink" title="算法详解"></a>算法详解</h1><p>回溯算法需要考虑三个问题：</p><ul><li>结束条件：递归在什么时候终止，返回结果；</li><li>已有路径：已经加入到结果中的元素；</li><li>待选路径：还有哪些元素可以加入到路径中来；</li></ul><p>核心有两个，一个是什么时候结束，一个是什么时候做选择以及回溯（递归）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = [] <span class="comment"># 记录最终结果</span></span><br><span class="line">res = [] <span class="comment"># 记录中间结果（保存路径）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">res, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(res)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        <span class="comment"># 做选择</span></span><br><span class="line">        res.append(选择)</span><br><span class="line">        backtrack(res, 选择列表)</span><br><span class="line">        <span class="comment"># 撤销选择</span></span><br><span class="line">        res.pop()</span><br></pre></td></tr></table></figure><h1 id="以46-全排列为例分析："><a href="#以46-全排列为例分析：" class="headerlink" title="以46. 全排列为例分析："></a>以<a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a>为例分析：</h1><img src="/2021/12/29/211229-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/1.png" class><p>当输入为nums = [1,2,3]，我们进行全排列的过程是：首先固定第一个元素，然后在剩下的元素里选择一个固定第二个元素，最后固定第三个元素。例如，首先选择1作为第一个元素，然后就只有2、3可以作为第二个元素，如果选择2作为第二个元素，就只有3可以作为第三个元素；反之如果选择3作为第二个元素，就只有2作为第三个元素。</p><p>我们看一下这一题的三个问题：</p><ul><li><p>首先是结束条件：如果遍历到第三个元素说明递归终止；</p></li><li><p>其次是已有路径：当前元素如果是2，我们想要把当前元素选3，只需要交换2和3即可；</p></li><li><p>最后是待选路径：待选路径就是nums中没有加入到已有路径中的元素；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bacaktrack</span>():</span></span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> len(res) == n:</span><br><span class="line">              <span class="comment"># 结束条件，长度为n的时候结束</span></span><br><span class="line">                result.append(res[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                  <span class="comment"># 做选择前需要判断nums[i]是否已经加入到res中，如果没有加入就选择加入</span></span><br><span class="line">                  <span class="comment"># 做选择</span></span><br><span class="line">                    res.append(nums[i])</span><br><span class="line">                    bacaktrack()</span><br><span class="line">                    <span class="comment"># 撤销选择</span></span><br><span class="line">                    res.pop()</span><br><span class="line">        result = []<span class="comment"># result保存最终结果</span></span><br><span class="line">        res = []<span class="comment"># res 保存中间结果</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        bacaktrack()</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>上面的代码可以优化一下，因为我们得到的最终结果只需要在nums中进行交换元素即可，不需要每次都从头遍历保存在res中，这样既可以节省时间也可以节省空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">      </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bacaktrack</span>(<span class="params">start</span>):</span></span><br><span class="line">          <span class="comment"># start表示下一次递归从nums中的开始位置</span></span><br><span class="line">            <span class="keyword">if</span> start == n:</span><br><span class="line">              <span class="comment"># 结束条件，如果开始位置start==n结束为止就终止</span></span><br><span class="line">                result.append(nums[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n):</span><br><span class="line">              <span class="comment"># 做选择（把start开始位置与i位置交换元素）</span></span><br><span class="line">                nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">                bacaktrack(start + <span class="number">1</span>)</span><br><span class="line">                <span class="comment"># 撤销选择（两次交换就相当于撤销选择了）</span></span><br><span class="line">                nums[i], nums[start] = nums[start], nums[i]</span><br><span class="line">        result = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        bacaktrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li></ul><h1 id="相关题目目录"><a href="#相关题目目录" class="headerlink" title="相关题目目录"></a>相关题目目录</h1><p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></p><p><a href="https://leetcode-cn.com/problems/combination-sum-iii/">216. 组合总和 III</a></p><p><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></p><p><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></p><p><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></p><p>题目还有很多，可以直接去回溯标签下找一些，做几个熟悉一下即可。</p><p>参考文献：<a href="https://www.cnblogs.com/looyee/articles/12084932.html">https://www.cnblogs.com/looyee/articles/12084932.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二叉树的层序遍历</title>
      <link href="2021/12/27/211227-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/12/27/211227-%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-层序遍历讲解"><a href="#1-层序遍历讲解" class="headerlink" title="1.层序遍历讲解"></a>1.层序遍历讲解</h1><blockquote><p>基本用法</p></blockquote><p>层序遍历就是按二叉树从上到下，从左到右依次访问每个节点。</p><ul><li>首先将二叉树的根节点push到队列中，判断队列不为NULL，就输出队头的元素， </li><li>判断节点如果有孩子，就将孩子push到队列中， </li><li>遍历过的节点出队列， </li><li>循环以上操作，直到Tree == NULL。</li></ul><p>在使用python实现的过程中，我可以借助列表来模拟队列操作；在每次访问队头元素的时候，可以用pop(0)来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                nodeQueue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>进阶用法</p></blockquote><h4 id="102-叉树的层序遍历"><a href="#102-叉树的层序遍历" class="headerlink" title="102.叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102.叉树的层序遍历</a></h4><p>层序遍历的基础用法基本上不会涉及到，因为仅仅只是实现了遍历元素的功能，更多的是进阶用法：题目中一般是让你访问每一层，然后把每一层单独保存下来。LeetCode中的层序遍历变形基本都是基于这一种操作。</p><p>进阶用法在前者的基础上新增加一个队列来保存每一层的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            <span class="comment"># 用res和nextQueue来保存每一层的节点和结果 </span></span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextQueue.append(node.right)</span><br><span class="line">            result.append(res)</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="2-相关题目变形"><a href="#2-相关题目变形" class="headerlink" title="2.相关题目变形"></a>2.相关题目变形</h1><h2 id="429-N-叉树的层序遍历"><a href="#429-N-叉树的层序遍历" class="headerlink" title="429. N 叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">for</span> chl <span class="keyword">in</span> node.children:</span><br><span class="line">                    nextQueue.append(chl)</span><br><span class="line">            result.append(res)</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。</p><p>这个题目是在题目102的基础上，只是输出结果是先输出底层在输出顶层，所以代码只需要修改一行即可。把结果逆序输出即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return result[::-1]</span><br></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>这个题目也是基于102的基础，只是输出的时候中间每一层的res奇数层从左到右，偶数层从右到左。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            nextQueue = []</span><br><span class="line">            res = []</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodeQueue:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextQueue.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                result.append(res)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(res[::<span class="number">-1</span>])</span><br><span class="line">            nodeQueue = nextQueue</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h2><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p>这个题目也是经典变形，只需要修改一下代码即可。</p><h2 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h2><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p>进阶：</p><p>你只能使用常量级额外空间。<br>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><p>通过层序遍历一遍即可，需要注意因为next初始为空，所以只需要处理每一层的前n-1个节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        nodeQueue = []</span><br><span class="line">        nodeQueue.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            n = len(nodeQueue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i &lt; n - <span class="number">1</span>:</span><br><span class="line">                    node.next = nodeQueue[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodeQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归方式"><a href="#递归方式" class="headerlink" title="递归方式"></a>递归方式</h3><p>提供了两种方式，第一种是水平连接，第二种是纵深连接，之后有时间画个图来讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.next = root.right</span><br><span class="line">            <span class="keyword">if</span> root.next:</span><br><span class="line">                root.right.next = root.next.left</span><br><span class="line">            self.connect(root.left)</span><br><span class="line">            self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">self, root: <span class="string">&#x27;Optional[Node]&#x27;</span></span>) -&gt; &#x27;Optional[Node]&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = root.left</span><br><span class="line">        right = root.right</span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            left.next = right</span><br><span class="line">            left = left.right</span><br><span class="line">            right = right.left</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><h2 id="BFS广度优先遍历"><a href="#BFS广度优先遍历" class="headerlink" title="BFS广度优先遍历"></a>BFS广度优先遍历</h2><p>典型的层序遍历，直接用层序遍历，然后把每一层最右边的节点值保存下来即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rightSideView</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeQueue = [root]</span><br><span class="line">        <span class="keyword">while</span> nodeQueue:</span><br><span class="line">            n = len(nodeQueue)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = nodeQueue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> i == n<span class="number">-1</span>:</span><br><span class="line">                    result.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodeQueue.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodeQueue.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="DFS深度优先遍历"><a href="#DFS深度优先遍历" class="headerlink" title="DFS深度优先遍历"></a>DFS深度优先遍历</h2><p>在进行深度优先遍历的时候需要注意：第一，访问顺序是根节点、右节点、左节点这个顺序，这样可以确保访问右节点在左节点前面；第二，每次访问根节点的时候只要判断一下是否res的长度与二叉树当前节点深度是否一致即可判断是否把当前节点值加入到res中来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val&#x3D;0, left&#x3D;None, right&#x3D;None):</span><br><span class="line">#         self.val &#x3D; val</span><br><span class="line">#         self.left &#x3D; left</span><br><span class="line">#         self.right &#x3D; right</span><br><span class="line">class Solution:</span><br><span class="line">    def rightSideView(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        def DFS(root, depth):</span><br><span class="line">            if not root:</span><br><span class="line">                return</span><br><span class="line">            depth +&#x3D; 1</span><br><span class="line">            if len(res) &lt; depth:</span><br><span class="line">                res.append(root.val)</span><br><span class="line">            DFS(root.right, depth)</span><br><span class="line">            DFS(root.left, depth)</span><br><span class="line">            return res</span><br><span class="line">        DFS(root, 0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解二叉树的三种遍历方式（前序、中序、后序）</title>
      <link href="2021/12/24/211225-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>2021/12/24/211225-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1、三种遍历方式讲解"><a href="#1、三种遍历方式讲解" class="headerlink" title="1、三种遍历方式讲解"></a>1、三种遍历方式讲解</h2><blockquote><p>LeetCode题目链接</p></blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><blockquote><p>三种遍历讲解</p></blockquote><table><thead><tr><th>名称</th><th align="left">节点遍历方式（左根右）</th><th>题目难度</th></tr></thead><tbody><tr><td>二叉树的先序遍历</td><td align="left">根节点、左节点、右节点</td><td>Easy</td></tr><tr><td>二叉树的中序遍历</td><td align="left">左节点、根节点、右节点</td><td>Easy</td></tr><tr><td>二叉树的后序遍历</td><td align="left">根节点、左节点、右节点</td><td>Easy</td></tr></tbody></table><p>只要弄清楚三者的区别在做题的时候就可以更好的实现和理解，实现方法可以分为递归和非递归两种方式，代码可以参考下面。</p><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="2、前序遍历代码实现"><a href="#2、前序遍历代码实现" class="headerlink" title="2、前序遍历代码实现"></a>2、前序遍历代码实现</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></p><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(nodeStack) != <span class="number">0</span>:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line">        result = []</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="3-二叉树的中序遍历"><a href="#3-二叉树的中序遍历" class="headerlink" title="3.二叉树的中序遍历"></a>3.二叉树的中序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></p><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> nodeStack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                nodeStack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = nodeStack.pop()</span><br><span class="line">                result.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        result = []</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="4-二叉树的后序遍历"><a href="#4-二叉树的后序遍历" class="headerlink" title="4.二叉树的后序遍历"></a>4.二叉树的后序遍历</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></p><blockquote><p>非递归方式</p></blockquote><p>后序遍历的稍微有一点不一样，因为在访问左右根的时候，比较难操作，我们可以实现先访问<strong>根右左</strong>，然后再逆序输出就可以得到<strong>左右根</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(nodeStack) != <span class="number">0</span>:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right != <span class="literal">None</span>:</span><br><span class="line">                nodeStack.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            postorder(root.left)</span><br><span class="line">            postorder(root.right)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">        result = []</span><br><span class="line">        postorder(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="5-N叉树的前序遍历"><a href="#5-N叉树的前序遍历" class="headerlink" title="5.N叉树的前序遍历"></a>5.N叉树的前序遍历</h2><blockquote><p>非递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pre</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            result.append(root.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">                pre(chl)</span><br><span class="line"></span><br><span class="line">        result = []</span><br><span class="line">        pre(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><p>递归方式需要注意，遍历的时候是先保存后面的，再保存前面的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = [root]</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> node.children[::<span class="number">-1</span>]:</span><br><span class="line">                nodeStack.append(chl)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-N叉树的后序遍历"><a href="#6-N叉树的后序遍历" class="headerlink" title="6.N叉树的后序遍历"></a>6.N叉树的后序遍历</h2><blockquote><p>非递归方式</p></blockquote><p>N叉树并没有什么太大的区别，只需要在遍历的时候用for循环考虑多个子节点即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        nodeStack = []</span><br><span class="line">        nodeStack.append(root)</span><br><span class="line">        <span class="keyword">while</span> nodeStack:</span><br><span class="line">            node = nodeStack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> node.children:</span><br><span class="line">                nodeStack.append(chl)</span><br><span class="line">        <span class="keyword">return</span> result[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>递归方式</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val=None, children=None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">post_</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">for</span> chl <span class="keyword">in</span> root.children:</span><br><span class="line">                post_(chl)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">        result = []</span><br><span class="line">        post_(root)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研经验贴】本科双非上岸复旦大学计算机学院</title>
      <link href="2021/04/21/210421-%E7%BB%8F%E9%AA%8C%E8%B4%B4/"/>
      <url>2021/04/21/210421-%E7%BB%8F%E9%AA%8C%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<p>去年指导一位本科学弟，成功上岸复旦大学计算机学院，特邀请他写下此贴。</p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>我本科就读于双非院校，初试成绩分别为<strong>政治69，英语71，数学126，408计算机基础综合112，总分378</strong>。</p><p>在前面我很想说，其实我认为考研有一个很重要的方面是找到属于自己的复习方式以及节奏，别人的经验包括我的也更多的是一种参考，就像政治讲的实事求是，根据自己的情况，找到属于自己的学习方法。</p><p>比如我个人如果早期起来的很早，下午会没有精神，那我就八点多到教室也完全可以；我也有一个朋友考的科软，每天八九点来，晚上学到九点就不学，最后成绩441，四千人成绩前五，虽然天赋有一定成分，但是也可以说明，并不是每天必须呆在自习室多久才能有多好的成绩。</p><p>所以还是强调，考研不能仅靠别人推荐的学习安排，更重要的是实事求是，根据自身情况找到属于自己的方法。</p><h1 id="分科介绍"><a href="#分科介绍" class="headerlink" title="分科介绍"></a>分科介绍</h1><h2 id="政治"><a href="#政治" class="headerlink" title="政治"></a>政治</h2><p>我其实对最后的政治成绩并不是很满意，我客观题应该是44，这次主观题有点失误。</p><p>客观题重要的是多刷题，我也是听完了徐涛的课程，刷的是肖老的1000题、肖八、肖四，后期在手机上刷了各种模拟卷，比如余等人的（其实我觉得徐涛、腿姐的模拟卷质量不是很高），在小程序上，学累了就刷一下题，分数不重要，到后期甚至模拟卷我都可能35分不到，更重要的是这些知识不断地会重复，而且真题一定会简单一些，刷题刷多了最后做真题能明显地感觉到哪些选项是对的，哪些是干扰项，从哪个地方干扰的。最后有时间也要看几套真题，模拟卷和真题还是有一定差距，最像真题风格的选择题目也就肖四肖八。</p><p>主观题是因为今年肖老发挥超神，大题都预测到了，而我当时是看了研木易的主观题，最后并没有按照肖四中全部背下来写，更多的是用自己的话整理出来。但是可能由于上海的判卷尺度，让老师误认为我并没有背肖四，只是记住了大概；还有就是也不一定要写满，我觉得我是把肖老提到的点写完之后自己又补充，每道题都写满，最后成绩不是很理想，如果考旱区的可以注意一下。</p><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><p>英语今年英二比较难，我是按照往年的题目难度去准备的，英语并不是我的强项，也没花费很多时间，最后的结果还比较差强人意。</p><p>暑假的时候利用王江涛那本十天背完考研词汇，大概十几天每天花四五个小时，背会了大概七、八成的单词，接下来就是用扇贝每天手机复习一点。 暑假开始做真题，只做阅读理解，一开始做的英一，后来时间不太够就做的英二。到十一月的时候开始看一些作文以及做一些完型等题型。</p><p>总的来说只要坚持背单词，做好阅读，英语不会成为拖累的科目，但如果想要在这方面考的高一点，就需要基础比较好或者复习比较努力。 </p><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><p>今年数二的题目非常简单，按照往年经验一般有一道难题压轴，但是今年并没有出现难题，只要计算基础过关都能拿到一个不错的分数。</p><p>我的数学进度不太值得参考，大概就是在网上看到的进度往后推一个月左右。三四月份我是在家复习，看完了张宇的基础三十讲当中的高数部分，五月份到学校之后，一段时间不学习导致忘记了很多，又重新开始看武忠翔的基础班，到七月底才开始线代，强化甚至也是暑假结束了还没有看完高数的强化。不过我想说的是，如果自己真的进度没有很快，那么看到别人进度快不要着急，一定要打好基础，最后来得及的。</p><p>后期我做的模拟题是张八，李六和李四，比较推荐李林的试卷，包括李林的习题集880也很推荐，只不过我后期才发现，只做了880的线代部分。李林的题目和真题比较像，不会出现很偏很怪的题目，做好之后遇到基础的题目应该不会没有思路，如果想要成绩高一点，那就需要大量的刷题。</p><p>再说一下考试的时候，杭州考场时只给两张16开的草稿纸，根本不够用的，而且考试当天也最好喝杯咖啡什么提提神，我考试的时候有点晕晕乎乎，导致一道填空题写对了，往答题卡上写的时候漏抄了，就直接丢掉了五分。同时也证明大量的刷题也十分重要，我是三个小时刚好做完，甚至一点检查的时间都没有，而我朋友刷题多，他两个小时就做完了，所以最后就成绩比较高。</p><h2 id="408计算机基础综合"><a href="#408计算机基础综合" class="headerlink" title="408计算机基础综合"></a>408计算机基础综合</h2><p>​      我是从暑假开始看408的，先看了天勤的数据结构，直接看书看完了，发现收获不是很多。之后再看的王道全家桶，看视频以及做书上的习题。408这种东西一开始学的时候会觉得很痛苦，因为很多知识记不住，但是没关系，一遍一遍的看，到最后会觉得做408的真题是一件比较轻松愉悦的事情。</p><p>​    总的来说408应该看书，第一遍可以看视频，然后之后就可以直接看书，看三到四遍的时候就会发现没那么难，没有什么太难理解的东西，更多的在于能不能记得住，如果想要125+甚至更高的话，只看王道是不够的，应该结合考纲所指出的具体书籍进行学习。</p><h1 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h1><ul><li><p>政治：《肖秀荣全家桶》，徐涛的《精讲精练》（如果看课可以选择这个）</p></li><li><p>英语：我是只用的张剑的《黄皮书》，单词用的是王江涛《十天背会考研词汇》</p></li><li><p>数学：我跟的武忠翔，书用的是《高等数学辅导讲义》《线性代数辅导讲义》，习题集我只推荐他们的《660》（《330》不太推荐），还有李林的《880》编的也比较有真题味。模拟卷李六和李四一定要做，都是基础的题目，22的试题可能比21难的情况下，可以适当看张宇的张八和张四，然后就是合工大共创以及超越。（汤家凤和李永乐团队的模拟题不推荐）</p></li><li><p>408：《王道全家桶》</p></li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>其实即便从现在开始，也不用太紧张，只考虑初试的话也是完全来的及的。不要总盯着别人的进度以及攻略帖子的时间表，如果实在比较慢还是要稳扎稳打，不能为了赶进度而马马虎虎做完，这样后期也要花费时间来填坑。考研从来不是比谁学的久，而是比谁学的多，比谁考场发挥的好的比赛。心态也是考研很重要的一部分，希望大家可以稳住心态慢慢来，最终考上理想的学校和专业！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 经验贴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】计算机考研复习指导（简易版）</title>
      <link href="2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/"/>
      <url>2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>这篇文章介绍了408计算机考研复习的基本过程，关于时间、资料、真题都会有介绍，大家可以参考一下，整个属于简易版，后期我会推出一个更加详细的版本。</p><h1 id="考研资料准备"><a href="#考研资料准备" class="headerlink" title="考研资料准备"></a>考研资料准备</h1><img src="/2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/1.png" class><p><strong>对于辅导书</strong>，并没有太多的选择，除了王道的辅导书就是天勤，除此之外并没有其他可以选择的了，由于我身边考研的同学中，大多数都是选择王道的，所以在此处也就统一推荐王道了，各位可以根据自己的喜好来从两个机构的辅导书中自行决定。</p><p><strong>对于教材</strong>，我推荐的这四本也是网上大家用到的比较多的，这些教材可以在网上找一些PDF即可，因为使用的频率比较低。计算机组成原理有一些章节可以参考一下教材，其他的三门看辅导书已经足够了。复习过程中，可以直接看辅导书进行复习，遇到不会的知识点、重难点可以翻看一下教材，或者是去看一下王道的视频讲解。<strong>不建议全程看王道的视频或者教材，只要针对性的去看即可。</strong></p><p><strong>对于真题</strong>，真题是十分重要的，甚至可以说是最重要的复习资料，从真题里面你可以分析出出题类型、难度、方向、综合性。真题做题方法可以按照四个科目单独做，也可以按照整套试卷的方式来做。</p><p>对于模拟题，无论是王道还是天勤的模拟题，质量都是无法和真题相媲美，只能拿来做个参考，不用过于在意分数，毕竟408复习过程中的能做的题目并不是很多。</p><h1 id="408复习指导"><a href="#408复习指导" class="headerlink" title="408复习指导"></a>408复习指导</h1><p>408复习大致上需要4-5轮，每一轮都要侧重点不同</p><h2 id="第一轮复习-60天-75天"><a href="#第一轮复习-60天-75天" class="headerlink" title="第一轮复习(60天-75天)"></a>第一轮复习(60天-75天)</h2><blockquote><p>复习过程</p></blockquote><ul><li>第一轮的复习需要<strong>全面复习</strong>，无论是重点知识点还是非重点都要全部看一遍，大纲上提到的知识点都必须要复习到；</li><li>对于一些难点，如果实在看不懂也不用怕，可以先做个标记，可以先放下，等之后第二轮再特意攻克；</li><li><strong>做题</strong>，<strong>可以先做选择题以及一部分分析题</strong>，这样安排是因为选择题一般涉及到的知识点比较单一，可以起到巩固知识点的作用；分析题一般会涉及到多个知识点，有的甚至是多个学科，所以做不出来是很正常的，能做出来多少就做多少；</li><li><strong>时间</strong>：408四个科目，难度和内容都不一样，一般来说需要2个月时间才能复习完一轮，平均2天复习一章，有一些章节比较简单，花费的时间就相对减少（例如数据结构的第1、2、3章，计组的第1章，操作系统第1、5章，计网的第1、6章）这些章节复习的时候就自己把握时间，有些章节就会比较难，内容也会很多，可能需要安排3天时间复习一章；</li><li>常遇到的问题：408四个科目会出现后一门的时候忘记了前一门的知识，这个很多人都会遇到，我建议是通过<strong>我的笔记</strong>来快速回顾一下整个一门课的知识点。</li></ul><h2 id="第二轮复习（50-60天）"><a href="#第二轮复习（50-60天）" class="headerlink" title="第二轮复习（50-60天）"></a>第二轮复习（50-60天）</h2><blockquote><p>复习过程</p></blockquote><ul><li>第二轮复习依然是全面为主，但是在复习速度会快很多，因为简单的知识点只要看一下回顾一下就可以了，难点以及自己做出特殊标记的地方需要重点回顾；</li><li>在这一轮，选择题的问题要全部解决或者尽可能全部解决；分析题要基本上能够做出来，做不出来的也要看答案去理解，学习解题方法；</li><li>通过这一轮的复习，要基本上做到所有题型都遇到了也能做出来，为接下来第三轮作准备，同时要熟悉考试的题型，不仅仅是纯粹做题，把出题的套路也要解决掉；</li><li>这一轮复习时间上可能会比第一轮少一点，一个半月至两个月，反正就是尽可能压缩，提高复习速度和效率，人总是会拖延的，如果你给自己定了时间点就会自然而然提高效率；</li></ul><h2 id="第三轮复习"><a href="#第三轮复习" class="headerlink" title="第三轮复习"></a>第三轮复习</h2><blockquote><p>复习过程</p></blockquote><ul><li>这一轮的<strong>重点是真题</strong>，408是统考，所以考试的题目、出题方向都不会有太大的变化，因为要照顾到全国的学生，真题的重要性不言而喻；</li><li>真题可以按照整套试卷来做，也可以按照单独科目来做，可以先拿出来三年的做一下测试一下，最后建议流出后三年的试卷先不要做，可以留着后面测试一下（这个后面并不是考试前，大概十一月份就要做完所有的真题）；</li><li>分析真题，这个是至关重要的，因为你只做题目是没有用的，必须要分析自己做错的原因，出题的方向，横向对比以及纵向对比出题的类型，最后要总结一下哪些题型每年都考，哪些自己做到还不够好，哪些还需要加强；</li><li>通过真题查漏补缺，做题遇到不会的知识点，做完就赶紧复习一下，看看书和笔记，然后记住，通过不断查漏补缺来提升分数和实力。</li></ul><h2 id="第四轮复习"><a href="#第四轮复习" class="headerlink" title="第四轮复习"></a>第四轮复习</h2><ul><li>复习到这阶段距离考试估计还有一个月左右，这段时间也没有太多题目可以做，网上会有一些模拟题，可以参考看看，有时间和精力就做做，因为到最后一个月政治会有很多需要记忆的内容，专业课更多的是查漏补缺。</li><li>这个时期你已经没有足够的时间去系统性把辅导书全面复习了，所以你平时整理的笔记就会十分重要了，你可以拿出来笔记来快速反复复习。</li></ul><h1 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h1><p>由于整理笔记十分花费时间，所以不建议大家去自己整理笔记，可以在本人整理的笔记基础之上添加一些笔记即可；</p><p>详情可点击该链接，文末有购买方式：<a href="https://sanduohou.github.io/2021/04/19/0419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">【考研】408计算机考研笔记介绍及使用方法</a></p><img src="/2021/04/19/210419-408%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%AF%BC/2.png" class>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】408计算机考研笔记介绍及使用方法</title>
      <link href="2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="408笔记介绍"><a href="#408笔记介绍" class="headerlink" title="408笔记介绍"></a>408笔记介绍</h1><img src="/2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/2.png" class><p>408的复习由于涉及到四个科目，且内容十分广泛，<strong>很容易出现复习后一门科目的时候而忘记前面复习的科目</strong>，因此萌发了自己整理一份笔记，这样可以快速回顾整个科目多个章节的内容。笔记是用OneNote制作整理的，因为这个软件可以实现表格的无限嵌套，整理的笔记会条理清晰，然后加上不同的配色来突出重难点。笔记是初试期间整理的，一般是复习完一章就晚上回到住处整理，如果对知识熟悉一章也花不了太多时间，还可以加深记忆。前期使用确实是花费了较多的时间用来整理笔记，不过整理几章熟悉软件的操作之后速度就大大加快。</p><p>我是复试通过之后，在一个复试群里发了自己的笔记，就有很多参加复试的小伙伴向我索要笔记，当时主要是想着能够帮助大家，基本是白菜价给那些小伙伴们，后来朋友就鼓励我把笔记放在闲鱼，这样可以让更多的人用到自己的笔记而受益。我是相信自己的笔记可以帮到各位学弟学妹才拿出来的，整理笔记并不需要成绩多么好，只需要能够细心、认真、耐心、愿意花时间就可以做得很好。笔记是用OneNote制作整理，有想要尝试的小伙伴可以试一下，但是要做好需要花费大量时间的准备，<strong>经历过整理笔记的经历之后我不太建议大家再去自己去整理笔记。这就像计算机中“时间换空间”还是“空间换时间”一样，你可以通过花费一些钱来获得笔记节省时间，真的没有必要再去自己花费大量的时间整理笔记。</strong></p><ul><li><strong>《数据结构笔记》</strong>参考2021版王道、数据结构（C语言版严蔚敏）</li><li><strong>《计算机组成原理笔记》</strong>参考2021版王道、计算机组成原理（第二版唐朔飞）</li><li><strong>《计算机网络笔记》</strong>参考2021版王道、计算机网络第七版（谢希仁）整理</li><li><strong>《操作系统笔记》</strong>是根据2021版王道、计算机操作系统（第四版）汤小丹整理</li></ul><p><strong>目前，笔记只有纸质版，不再出售电子版，纸质版定价为99元四科，彩色打印包邮，有需要的同学可以通过下方购买，购买之后添加我的私人微信：cs188513890</strong></p><p><a href="http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW">http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW</a></p><p><a href="http://u4imyzcts7ll8ge6.mikecrm.com/AIvWBRW"><strong><u>408笔记购买方式，该链接即可跳转</u></strong></a></p><p>购买之后14:00之前下单，当天发货，14:00之后下单，第二天发货。</p><img src="/2021/04/19/210419-408%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/1.png" class><h1 id="第二版笔记的升级"><a href="#第二版笔记的升级" class="headerlink" title="第二版笔记的升级"></a>第二版笔记的升级</h1><p>第一版笔记由于是初试期间整理，有几个章节做的并不够好，因此我在第一版笔记的基础上进行了小的调整。</p><p> <strong>第二版笔记调整如下</strong>: </p><ol><li><p>原有的配图是截图方式，现在改为文字编辑或更换带有明显水印的截图，例如数据结构的代码全部是编辑器编辑之后再截图更加清晰; </p></li><li><p>部分章节的配色第一版没有加上去，在第二版中全部加上去保证统一格式; </p></li><li><p>数据结构前三个章节由于内容较少，第一版采用的是思维导图方式，在第二版中我进行了改进，与现有笔记格式统一; </p></li><li><p>为了防止盗版，把水印的位置与笔记合为一体，既不影响诸位使用也可以保证水印的存在；</p></li><li><p>另外，最近也开始在找人整理出第三版笔记了，具体更新时间暂时不确定，大家有需要可以先使用第二版笔记即可，应付考研完全是足够的；</p></li><li><p>由于笔记是彩色打印，截图打印出来的效果可能会有点不清晰，还请多谅解，不过基本不影响大家正常使用。</p></li></ol><h1 id="笔记如何使用"><a href="#笔记如何使用" class="headerlink" title="笔记如何使用?"></a>笔记如何使用?</h1><p>第一，笔记是对知识的整理、归纳、汇总，涉及的多是重点、难点知识，无法做到对知识的全面覆盖，所有一定要结合辅导书使用。前期需要以辅导书为主，笔记为辅，对知识进行全面复习;后期因为要抓住重点、难点、考点进行复习，不能胡子眉毛一把抓，可以笔记和辅导书同步结合，然后结合真题进行复习，越到后期笔记越重要。 </p><p>第二，为了解决408复习过程中复习后一个科目忘记前一个科目的情况，大家可以在复习空余，定期根据笔记来快速回顾前面的一个科目重点知识，这样既不需要花太多的时间也可防止知识遗忘。 </p><p>第三，笔记主要是用于初试，但是复试亦可，因为复试只需要根据提问叙述出大致意思即可，对一些细节、计算的要求相对较低，所以准备复试的小伙伴也完全可以在短期内复习408的大量内容，并且全部是重点。我整理了一份每章节的复试问题汇总，如果有需要可以私聊我。 </p><p>第四，对于本科期间的期末考试，原则上来说知识是覆盖到了，但是每个学校的期末考试侧重点是不一样的，所以如果是用于期末复习的小伙伴需要根据自己学校的历年考题来进行适当调整。</p><p>第五，现在改考408是大趋势，20、21两年改考的学校已经有几十所，诸位如果选定的学校不是408一定要做好准备：<strong>如果改考408怎么半？</strong>临时改科目确实是一件比较讨厌的事情，大家在准备的过程中也都是信息满满，抱着必上某所学校的决心，甚至是非某所学校不上的决绝，但是我遇到过很多人，当成绩出来的时候，他们找调剂，有点甚至需要二战、工作而以没有学可上而结束。到那时，很多人都会感慨一句:“<strong>有学上比考到自己心目中那所学校更重要。</strong>”</p><p>以上只是建议，还请诸位谨慎采纳，祝各位都可以取得一个好的成绩!</p><h1 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h1><p>笔记全程都是由我一人初试期间整理，难免会有个别错误以及一些不足之处，如果各位学弟学妹在使用过程中发现，可以通过邮箱（<a href="mailto:&#x31;&#x38;&#x38;&#53;&#49;&#51;&#56;&#x39;&#48;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;">&#x31;&#x38;&#x38;&#53;&#49;&#51;&#56;&#x39;&#48;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;</a>）反馈于我，我在之后的版本中会做一个汇总以便帮助大家指正;</p><p><strong>诸位做为中国高等教育的精英，保护版权、尊重版权、打击盗版应该从我们每个人做起，如果精英阶层都无法做到保护他人知识产权，那么我们所接受的教育就会存在很大缺陷!今日你为他人知识产权站队，明天他人也会为你的知识产权撑腰！</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】考研择校如果做到尽可能理性？</title>
      <link href="2021/04/13/210413%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/"/>
      <url>2021/04/13/210413%E8%80%83%E7%A0%94%E6%8B%A9%E6%A0%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-38614663c03722521a9e7f88195d097a_r.jpg" alt="考研择校如何做到尽可能理性选择，拒绝盲目？"></p><p>20年上岸，看到身边很多小伙伴最终被迫选择调剂、工作、二战，感到十分可惜。特写下此篇，以指导诸位学弟学妹在考研的第一步就选择对，这样会让你的考研之路更加有把握。看完此篇，再来对照你择校的过程。大家在选择学校的时候，一定要经过尽可能的理性分析，而不是感性的选择。选择学校这一步走错了，基本上也就意味着你的考研之路悲惨结局开始了。</p><h2 id="第一：什么是感性选择？"><a href="#第一：什么是感性选择？" class="headerlink" title="第一：什么是感性选择？"></a><strong>第一：什么是感性选择？</strong></h2><p>名校情结，非这个学校不上，完全没有考虑自己的实力和学校的难度；感觉自己能够考上，对自己要考的学校了解很少，例如初试科目难度怎么样、复试比例多少、刷人多不多、是否等歧视双非学校等信息都一无所知；对往年数据（经验贴）没有做任何收集，全凭自己的感觉走；选择考研，并不是自己真的想要考研，而是看身边人考研了，自己随大流；<strong>以上情况都是考研择校的大忌，往往会葬送你的考研梦想；</strong>当然，如果你能够承受名校情结可能带来的风险，并且知道如果自己无法上岸会去干什么，那你就勇敢去拼搏一把吧！</p><h2 id="第二：如何做到尽可能理性选择？"><a href="#第二：如何做到尽可能理性选择？" class="headerlink" title="第二：如何做到尽可能理性选择？"></a><strong>第二：如何做到尽可能理性选择？</strong></h2><p>要说明一点，择校想要做到完全理性是不可能的，只能做到有限理性，因为我们的信息是有限，即使你能够把我下面强调的信息完全收集到也不行，因为人们在预估自己的实力之时，往往很难做到理性。但是通过我下面的方法，可以尽可能让你选择一个自己更有把握的学校<br>选择几个学校作为备选项，就是这几个学校都可以作为你的意愿学校，这种备选学校最好能够有5个以上，实力都相差不大即可；收集备</p><p><strong>选学校过去三年的考研信息，这些信息包括：（很重要）</strong><br><strong>初试科目及难度、专硕/学硕招生人数（去掉推免之后的人数）、进入复试的人数及比例、历年的报录比、每年的单科分数线及总分数线、是否歧视双非学校的学生、是否保护第一志愿、复试科目都有哪些内容等等</strong>，只要能够找到的，全部都收集下来，会有一些信息学校没有公布；</p><p>还要再去看经验贴，就是往年考上的学姐学长在网上分享的经验贴，这是一个很好的一手材料，作为对考研学校的一些辅助分析，例如可以分析复试难度、是否歧视双非等信息；把上面这些数据拿出来对比，既要纵向对比（看这个学校的报考热度、分数是否增加），也要横向对比（看哪个学校更好考一些）。</p><p>根据这些对比，你要能够预估一下自己这些学校下一年的分数会在多少，自己要是考这些学校能够考多少分，需要付出多大的努力，有多大的决心；除此之外，还要考虑复试，因为初试能够进去只是过了第一关，复试这一关更加重要。复试不及格是无法录取的，就拿计算机专业来说，有的学校需要上机编程，你能否顺利通过，又能拿到多少分呢？对于计算机的同学来说，需要强调的是，就我目前观察的情况是，21年计算机多所学校出现了高分被刷的同学，而且不乏初试排名前几名的同学，这是因为现在考研已经进入了存量时代，老师开始更加重视学生专业技能而不在是你能考多少分。因为老师招收一个学生，本来就培养时间在2.5-3年之间，如果跨考的学生基础以及可塑性太差的话，即使是初试高分老师也是不太想要的。</p><p>对自己进行分析，这是最难做到理性的，所以在完成以上的分析之后，要把这些数据找一个老师或者考上的学长学姐帮你分析。看看你能否实现你自己预定的分数，哪个学校考上的把握更大，然后选择1-2个学校作为备选（这两个学校最好科目差不多，如果科目差别大的话，就只能选择一所学校了），到9、10月份的时候根据自己的复习情况填报志愿。</p><h2 id="第三：如何看待“选择大于努力”"><a href="#第三：如何看待“选择大于努力”" class="headerlink" title="第三：如何看待“选择大于努力”"></a><strong>第三：如何看待“选择大于努力”</strong></h2><p>每个人的看法都不一样，我说说自己的看法：“选择大于努力”这句话是考研界十分流行的一句话，首先要明确的是：选择确实比努力更重要，因为你选择错了，怎么努力都是徒劳，因为你努力的上限不能够达到你选择的下限，就像鲤鱼跳龙门一样，这条鲤鱼能够跳的最大高度不能够超过门的高度。</p><p>今年（20年）因为疫情的影响，很多学校扩招，选择这些学校的学生真的是很幸运的。但是疫情毕竟是突发事件，几十年才能遇到一次，所以我们还是主要考虑常规事件。选择很重要，但是你选择的学校毕竟是自己喜欢的、想要去的，如果选择一个自己即使考上了也不能够开心学习的学校，哪怕这个学校很好考，我也认为大可不必。选择还是要想我上面所说，尽可能理性选择，而不是感性盲目选择。</p><p>最后再说一句，每个人在备考的过程中都会雄心壮志，非这个学校不上，但是最终大多数人都会被现实打败，他们会屈服在自己考研分数的现实面前，不得不低下自己骄傲的头颅，卑微地四处找调剂，那个时候他们才会认识到<strong>“有学上是多么重要”</strong>。当然也有人会继续扬起自己骄傲的头颅选择二战。现实是可悲的，考研无论怎么扩招，最终录取率还是保持在20-30%，四、五个考研学生里只有一个学生能够录取！</p><p>选择考研，你真的准备好了吗？</p><hr><p>我建立了一个考研打卡群，群里有一些小伙伴可以每天一起打卡自己的学习内容，如果你是单独备考，欢迎你加入我们，一起交流学习！</p><p>微信：cs188513890（加好友请备注：考研打卡群）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【408笔记勘误】4月10日更新</title>
      <link href="2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/"/>
      <url>2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>笔记在整理过程中，难免存在一些错误，我会把大家反馈的错误在此处进行勘误，如果您在使用笔记的过程中发现有错误之处，还请及时告知于我，以便我勘误，并在下一版笔记中纠正。</p><p>联系方式（微信）：cs188513890</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h2><h3 id="第三节：线性表的链式表示"><a href="#第三节：线性表的链式表示" class="headerlink" title="第三节：线性表的链式表示"></a>第三节：线性表的链式表示</h3><img src="/2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/1-1.png" class><p>把**<u>“按值查找节点值”与“按序号查找节点的值”</u>**交换位置</p><h2 id="第四章：树和二叉树"><a href="#第四章：树和二叉树" class="headerlink" title="第四章：树和二叉树"></a>第四章：树和二叉树</h2><h3 id="第三节：二叉树的遍历与线索二叉树"><a href="#第三节：二叉树的遍历与线索二叉树" class="headerlink" title="第三节：二叉树的遍历与线索二叉树"></a>第三节：二叉树的遍历与线索二叉树</h3><img src="/2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/1-2.png" class><p>三种遍历方式，都应该是先访问左节点，再访问右节点，因此需要把<strong>T-&gt;rchild与T-&gt;lchild</strong>交换位置</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="第一章：操作系统概述"><a href="#第一章：操作系统概述" class="headerlink" title="第一章：操作系统概述"></a>第一章：操作系统概述</h3><h3 id="第一节：基本概念"><a href="#第一节：基本概念" class="headerlink" title="第一节：基本概念"></a>第一节：基本概念</h3><img src="/2021/04/08/210406%E7%AC%94%E8%AE%B0%E5%8B%98%E8%AF%AF/3-1.png" class><p>删去<strong>“前者时间换空间；后者空间换时间”</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【效率】如何用iPad辅助考研备考</title>
      <link href="2021/04/01/210401%E5%A6%82%E4%BD%95%E7%94%A8iPad%E8%BE%85%E5%8A%A9%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83/"/>
      <url>2021/04/01/210401%E5%A6%82%E4%BD%95%E7%94%A8iPad%E8%BE%85%E5%8A%A9%E8%80%83%E7%A0%94%E5%A4%87%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic1.zhimg.com/80/v2-9e9dc0dc8a84987e296c0920261bc910_1440w.jpg" alt="img"></p><p>iPad长期以来被诟病——买前生产力，买后爱奇艺。考研过程中，我看到身边很多人确实是把iPad作为一种追剧的神器，而不是学习的利刃。我通过将近一年的使用，却用iPad做了不少事情，用来考研备考的辅助神器，真的是一个不错的选择，今天为大家分享一些我的使用方法。<strong>当然正如题主所说，iPad只是辅助，能否发挥其性能以及把其性能发挥到何种程度也要看个人。</strong></p><blockquote><p>装备：32GiPad2019+BOW可折叠键盘+Apple Pencil（发挥最大效能三者缺一不可）<br>本文将会介绍以下几个软件：<strong>OneNote、notability、Anki背诵神器、墨墨背单词软件、MarginNote2、欧路词典、Forest专注森林、B站万能学习资源、百度网盘</strong></p></blockquote><h2 id="第一｜OneNote（做笔记、计划、记录、总结等）"><a href="#第一｜OneNote（做笔记、计划、记录、总结等）" class="headerlink" title="第一｜OneNote（做笔记、计划、记录、总结等）"></a>第一｜OneNote（做笔记、计划、记录、总结等）</h2><p>本人算是一个OneNote重度用户了，考研期间的笔记、每日计划、每周总结、考研择校等等所有的东西，基本都是在OneNote上完成。OneNote的一些其他用法可以看看我的这个回答</p><h3 id="1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）"><a href="#1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）" class="headerlink" title="1、考研每日计划（下面的这个视频是我制作的如何在OneNote制作每日计划模板教程）"></a>1、考研每日计划（下面的这个视频<strong>是我制作的如何在OneNote制作每日计划模板教程）</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-219e72ec6055307ceb025c2cd01b4185_1440w.jpg" alt="img"></p><h3 id="2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。"><a href="#2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。" class="headerlink" title="2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。"></a>2、考研择校（我的主页有如何择校的文章，可以关注一下哦），把每个学校的行管信息列出来，然后可以横向、纵向对比，选择最适合自己的学校。</h3><p><img src="https://pic3.zhimg.com/80/v2-38614663c03722521a9e7f88195d097a_1440w.jpg" alt="img"></p><h3 id="3、每个月的总体规划"><a href="#3、每个月的总体规划" class="headerlink" title="3、每个月的总体规划"></a>3、每个月的总体规划</h3><p><img src="https://pic4.zhimg.com/80/v2-233b0b5cc2d20a621d97dcc7dc9aa2f3_1440w.jpg" alt="img"></p><h3 id="4、每周的总结"><a href="#4、每周的总结" class="headerlink" title="4、每周的总结"></a>4、每周的总结</h3><p><img src="https://pic2.zhimg.com/80/v2-96b1c453043a1d8a0971d39b1cc1b5e5_1440w.jpg" alt="img">每周的一个小总结，这是最后一个多月前的一次大总结</p><p>5、通过OneNote，我记录下自己考研过程中的每日点点滴滴，每周都会回头看看自己这周学习了哪些内容，还有哪些需要加强，还会整理自己的英语笔记、专业课笔记、政治笔记。</p><p>政治复习是花最少的时间，获得最高的分数，具体建议可以看看我的博客中关于政治复习建议的文章</p><p><img src="https://pic1.zhimg.com/80/v2-e61ca954717deec88167421407af99bc_1440w.jpg" alt="img">徐涛的30天背诵大作战，每天背一点</p><p><img src="https://pic1.zhimg.com/80/v2-35bab5b50fb4f34e2cc2715e59f845ac_1440w.jpg" alt="img">英语作文模板，自己通过很多其他优秀的模板整理出一份属于自己的模板，最终效果也不错</p><p>下面是专业课笔记（计算机网络、数据结构、计算机组成原理、操作系统），因为408科目比较多，所以需要整理出笔记方便自己的复习，针对笔记虽然会很有争议，但是还是要因人而异，尤其是针对内容较多的时候，笔记可以更好辅助复习。</p><p><img src="https://pic2.zhimg.com/80/v2-2c11080be72801a3baf7369412d04999_1440w.jpg" alt="img">操作系统笔记</p><p><img src="https://pic2.zhimg.com/80/v2-0c4a66e65bd08bb74bc9c23d20f245f1_1440w.jpg" alt="img">计算机网络笔记</p><p><img src="https://pic1.zhimg.com/80/v2-70e64827c965aa1a5c7d177ffad482d4_1440w.jpg" alt="img">还有数据结构笔记和计算机组成原理笔记</p><p><img src="https://pic4.zhimg.com/80/v2-a521e3bbd6d119009e062074416da787_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-1f37d420b2c0058713f0d930ad2989ca_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-aad604278b4c225092f797a3e51123f4_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-43108766c4c1d52bffad75a7a4e4cdd0_1440w.jpg" alt="img"></p><p><img src="https://pic4.zhimg.com/80/v2-5c46076370d4547b0af45961f7b2bd8b_1440w.jpg" alt="img"></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="第二｜notability（标记、看PDF、整理笔记）"><a href="#第二｜notability（标记、看PDF、整理笔记）" class="headerlink" title="第二｜notability（标记、看PDF、整理笔记）"></a>第二｜notability（标记、看PDF、整理笔记）</h2><p>notability用来看PDF、做标记、整理笔记也是十分方便的，我主要用来完成做前两者的事情，如果再结合它的<strong>分屏功能</strong>简直是太棒了，就是iPad2019屏幕稍微有点小，不过也够用了。</p><p>notability手写、标记、荧光笔……等功能一定要用起来，我使用过好几款类似软件，但是最好用的还是这一款。</p><p><img src="https://pic2.zhimg.com/80/v2-7356d88f6c51cb6146ace5030bd68bed_1440w.jpg" alt="img">把OneNote里的笔记导出到notability，在上标记很方便</p><p><img src="https://pic2.zhimg.com/80/v2-54f5703ea2e1b21c6034ac0d4941acb1_1440w.jpg" alt="img">数学笔记，好多资料考后删了，内存不够，有点心疼</p><p><img src="https://pic2.zhimg.com/80/v2-06e50f547ce2df0ab182da64e083f4e1_1440w.jpg" alt="img">英语作文模板，考英语二，小作文背十篇基本就够了</p><p><img src="https://pic3.zhimg.com/80/v2-378423545490f6ccbec83c6de8b8f0b6_1440w.jpg" alt="img">这个是大作文模板，大作文要整理出来一份自己的模板，我的这一份用着感觉挺好的，考场发挥也不错啦</p><p><img src="https://pic1.zhimg.com/80/v2-4b82c015c019321d97b7d3ad4f559148_1440w.jpg" alt="img">政治很多资料都没必要买，可以看PDF版就好，特别是肖四，PDF版本会比纸质版提前3天出来，可以比别人早几天背诵，真的很重要</p><p><img src="https://pic1.zhimg.com/80/v2-970ab3ff6eb3c932e843998c3b76326c_1440w.jpg" alt="img">OneNote做出来的笔记，最终就是这样的，很方便，重点突出</p><p><img src="https://pic4.zhimg.com/80/v2-c9a741db8f5a1d1976fbba94edbfc753_1440w.jpg" alt="img">英语二大作文模板</p><p><strong>分屏功能</strong>：这个是nb和欧路词典，左边是英语文章，直接选中后复制就可以在右边出现翻译，对于英语学习来说简直是不可多得的利器，对于日后的研究生阅读论文帮助也很大。</p><p><img src="https://pic2.zhimg.com/80/v2-dac6d504608210ee808b416814b8ed41_1440w.jpg" alt="img"></p><h2 id="第三｜Anki背诵神器（强推，背英语单词、背政治题目）"><a href="#第三｜Anki背诵神器（强推，背英语单词、背政治题目）" class="headerlink" title="第三｜Anki背诵神器（强推，背英语单词、背政治题目）"></a><strong>第三｜Anki背诵神器（强推</strong>，背英语单词、背政治题目）</h2><p>遇到这款神器真是幸运，政治选择题能够拿到40+，真当是多亏这款软件了，用来做《肖1000题》、《各位名师的模拟题》大概做了40+套，重复很多遍，关键是为我节省了很多时间。*<strong>我今年也建立了一个Anki卡组免费共享裙，欢迎大家一起交流学习，可以直接看我主页“想法”第一条就是有图片可以扫描进入。*</strong></p><p><strong><em>注意：这款工具安卓、电脑均可使用，进群有安装包可以下载使用\</em></strong></p><p><img src="https://pic4.zhimg.com/80/v2-5fd56e965f0fca8894f58cd38cb216b3_1440w.jpg" alt="img">这个是我用到的模拟题</p><p><img src="https://pic2.zhimg.com/80/v2-7762737e6e031645f194ac4bd340d04d_1440w.jpg" alt="img">感谢各位大佬制作的Anki卡组，用起来很方便</p><h2 id="第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）"><a href="#第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）" class="headerlink" title="第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）"></a>第四｜墨墨背单词软件（我用过扇贝、百词斩，我感觉这个是最好用的，效果最好的）</h2><p>我试过很多款市面上流行的背单词软件，但是最喜欢的还是墨墨背单词，最大的特点就是根据“艾宾浩斯遗忘曲线”来帮助你重复背诵单词，其他软件这一点做的不是很好，缺点就是需要买单词上线，我当时买了8800个。</p><p><img src="https://pic2.zhimg.com/80/v2-ee3ab22400f2326f665b38e58721b8fd_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-0efdb35f4f58782210d17175a3f4fc96_1440w.jpg" alt="img"></p><h2 id="第五｜MarginNote2（可以把PDF标记之后直接生成PDF）"><a href="#第五｜MarginNote2（可以把PDF标记之后直接生成PDF）" class="headerlink" title="第五｜MarginNote2（可以把PDF标记之后直接生成PDF）"></a>第五｜MarginNote2（可以把PDF标记之后直接生成PDF）</h2><p>这个软件可以把你的标记生成思维导图，这一点还是很好用的，对于文科的学生我感觉帮助会更大一点，我用到比较少，据说生成的思维导图可以制作成卡片直接导入Anki中，尝试几次都没有成功。以后有机会再做尝试吧！</p><p><img src="https://pic3.zhimg.com/80/v2-bb0d075ac85759725e75eca4d5fd483a_1440w.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-963e5e817cdb4c257c3797b7dbed4e7c_1440w.jpg" alt="img"></p><h2 id="第六｜欧路词典（查生词）"><a href="#第六｜欧路词典（查生词）" class="headerlink" title="第六｜欧路词典（查生词）"></a>第六｜欧路词典（查生词）</h2><p>欧路词典有三个特点：一个是可以自己导入词典；一个是你可以利用iPad的分屏功能，在一个软件上直接划词复制之后，就会在欧路词典上出现这个词语的意思，非常方便；第三个功能是每次查词之后都可以加入生词本，然后你可以像墨墨单词那样复习一样；</p><p><img src="https://pic2.zhimg.com/80/v2-84533fa69f8cf0391199f1ce91a7a1ed_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-6fd7edf487fbbe0012b7cf319a8c061e_1440w.jpg" alt="img"></p><p><img src="https://pic3.zhimg.com/80/v2-cf14c10f886bf7952c5ba6feea1f4a0e_1440w.jpg" alt="img"></p><h2 id="第七｜Forest专注森林（学习时种树，让自己变得更加专注）"><a href="#第七｜Forest专注森林（学习时种树，让自己变得更加专注）" class="headerlink" title="第七｜Forest专注森林（学习时种树，让自己变得更加专注）"></a>第七｜Forest专注森林（学习时种树，让自己变得更加专注）</h2><p>很多人都控制不住自己，总是会玩iPad，所以你可以在自己学习的时候在Forest专注森林里面种树，也可以邀请其他小伙伴一起种树，如果其中一个人退出软件就会导致双方的树枯萎。</p><p><img src="https://pic3.zhimg.com/80/v2-25af2266b51dc12586ab59694b3043ea_1440w.jpg" alt="img"></p><h2 id="第八｜B站（传说中的学习万能宝库，什么资源都有）"><a href="#第八｜B站（传说中的学习万能宝库，什么资源都有）" class="headerlink" title="第八｜B站（传说中的学习万能宝库，什么资源都有）"></a>第八｜B站（传说中的学习万能宝库，什么资源都有）</h2><p>B站的学习功能就不用说了，这个是有目共睹。</p><h2 id="第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）"><a href="#第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）" class="headerlink" title="第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）"></a><strong>第九｜百度网盘（看视频，前一天缓存，第二天可以倍速观看）</strong></h2><p>百度网盘也是用的比较多的，我往往都是前一天晚上开始缓存，然后第二天就可以倍速观看了，如果没有提前缓存下来需要开通会员才可以使用倍速观看！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 效率 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【考研】政治考研复习建议</title>
      <link href="2021/04/01/210401%E6%94%BF%E6%B2%BB%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"/>
      <url>2021/04/01/210401%E6%94%BF%E6%B2%BB%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>20上岸，旱区（北上地区）政治75+，还算一个不错的分数；这篇帖子不仅仅是经验分享，更是一篇备考指导，让你可用最少的时间和精力，获得更多的分数，大家请根据自己的情况进行调整复习。</p><p><img src="https://pic2.zhimg.com/80/v2-137341f9506ac1289248d62ac6ee22ed_1440w.jpg" alt="img"></p><h3 id="一、欲拿高分，思想先行"><a href="#一、欲拿高分，思想先行" class="headerlink" title="一、欲拿高分，思想先行"></a><strong>一、欲拿高分，思想先行</strong></h3><p>考研过程中，只有政治可以说是几乎所有人的基础都是一样的——零基础，但是最后政治依然会有人拿到高分，而有人是50分低分飘过，究其原因，就是方法的失当和努力的缺失，更加重要的先入为主的错误思想。</p><p>这些错误思想包括：“政治是一门玄学”，“政治大家分数都差不多，拉不开分”，“政治只要能考60分就可以了”…………这些思想，在考研期间真是听了不知多少遍，其共同之处都是对政治的不重视。就拿“政治能否拉开分数来说”，诸位可以任意找几所学院的复试名单，看政治分数第一名与最后一名的分数差距便可知道，基本可以相差二十分以上，试问在考研过程中20分是个什么样的概念！！！关键是这20分的提升可能只需要四五十个小时便可以完成。</p><p>我们也完全可以把英语与政治对比一下，英语基础的好坏对你成绩的影响是非常大的，有的人可以轻轻松松考到80分，而有的人努力大半年也只能考50分，这就是差距。政治备考，如若可以重视起来，认真准备，并且善于利用我下面提供的一款软件Anki，拿到75+的分数并非不可能。</p><h3 id="二、书籍推荐、省时省；做好计划、心中有数；"><a href="#二、书籍推荐、省时省；做好计划、心中有数；" class="headerlink" title="二、书籍推荐、省时省；做好计划、心中有数；"></a><strong>二、书籍推荐、省时省；做好计划、心中有数；</strong></h3><h4 id="（一）书籍推荐"><a href="#（一）书籍推荐" class="headerlink" title="（一）书籍推荐"></a><strong>（一）书籍推荐</strong></h4><p>考研花钱，政治最花钱，买书是最多的，但是很多书完全可以不用买，因为只需要看一下PDF就可以了，但是有些必须要买。<strong>因为我用的是肖秀荣的书，所以就以他的整套书为例，如果你用的是其他老师的书，也可以进行对比。</strong>每个老师的图书系列都是差不多的，无论跟哪个老师都可以，基本上考研政治这几位名师都是很不错的，选择了就请相信。</p><p><img src="https://pic1.zhimg.com/80/v2-4037681b96edbfa76a7f8c5ff28affac_1440w.jpg" alt="img"></p><p>考研毕竟是要花钱的，不要想着所有的书都看PDF，这是绝对行不通的，能帮你省点钱都帮你省了，如果实在拮据，就去闲鱼看看必买的书籍吧！</p><p>注意：其他老师的模拟卷，不用买，全部使用我下文提到的Anki背诵软件即可，但是需要网上找相关的模拟卷卡组导入，如果私信我的人多，我可以建立一个Anki卡组资料共享群；</p><h4 id="（二）关于计划"><a href="#（二）关于计划" class="headerlink" title="（二）关于计划"></a>（二）关于计划</h4><p>考研需要有一个整体的计划，你哪个时期该做什么？做到什么程度？自己心中都应该有数，最好能够以计划的形式写出来。</p><p><img src="https://pic4.zhimg.com/80/v2-575240b2779bd61a391ca5b9edd459b3_1440w.jpg" alt="img"></p><p>我根据自己的帖子，做一个大致的计划，稍微前后提前或者推迟半个月，不能太多，太早复习时间有点早，太晚复习选择题部分不能保证40+。政治是一门投入产出比最大的课程，如果你三四月份就开始复习，可能到最后和人家八九月份复习的人来说没有太大的分数区别；但是如果太晚复习我是十分不建议的，有的人会十一月才开始复习政治，你连政治的基础概念都无法全部理解，可能会有很多人说自己复习的很晚但是依然拿到不错的分数，但是这样还是太冒险，非常不建议。</p><p><img src="https://pic4.zhimg.com/80/v2-a61561988a2e3eb0c71fcf37a848e993_1440w.jpg" alt="img"></p><p><strong>改：9月-一轮复习 毛概、思修基础知识</strong></p><h3 id="三、一轮复习，掌握方法"><a href="#三、一轮复习，掌握方法" class="headerlink" title="三、一轮复习，掌握方法"></a><strong>三、一轮复习，掌握方法</strong></h3><p><strong>复习资料</strong>：《精讲精练》+《徐涛视频》+《1000题》</p><p><strong>复习方法</strong>：《精讲精练》快速过一遍，看视频，边看边理解书上的内容（也就马原需要理解，其他三科只需要记忆），看完视频再看一遍书，开始做《1000题》，错误的地方做个标记，尤其是马原部分，因为还要二刷；</p><p><strong>复习时间：</strong>我建议的开始复习政治的时间是：8月中旬前后开始，不能太晚，太晚很多基础的东西复习不完了，到最后做模拟冲刺卷的时候，你会发现自己很多基础的知识题都会出错。这轮复习下来大概需要2个月左右；</p><p>政治分为马原、毛概、史纲、思修，其中马原是最难理解的，大家都是零基础，建议结合徐涛的视频来复习，看视频的时候用1.5的倍速观看，每个视频的时间都不长，倍速之后也就二十分钟。徐涛的视频讲的很有意思，很多人都喜欢看，而且越看越想看，而且看的时候就像在看综艺节目，很开心<strong>，但是开心的同时是否学到了东西却是值得商榷的</strong>，很多人到最后只记得看视频却忘记学习知识，这个大家需要注意。我个人认为：<strong>除了马原必须要看视频之外，其他三科完全可以选择不看</strong>，因为其他三科都是基本的知识，理解的地方很少，<strong>如果看的话建议两倍速</strong>；</p><h3 id="四、二轮复习，借助Anki，结合核心考点"><a href="#四、二轮复习，借助Anki，结合核心考点" class="headerlink" title="四、二轮复习，借助Anki，结合核心考点"></a><strong>四、二轮复习，借助Anki，结合核心考点</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-68753fee2a0813b9a72423b34b21bd9c_1440w.jpg" alt="img"></p><p><strong>复习资料</strong>：<u>《1000题》+Anki记忆软件+《风中劲草核心考点》+《精讲精练》</u></p><p><strong>复习方法做题部分</strong>：《1000题》肯定是需要至少两遍，第二遍做题，只需要马原部分用到《1000题》，毛概、史纲、思修的《1000题》复习，我推荐使用<strong>Anki背诵软件</strong>，这个《1000题》的卡组可以在官网上找到资料分享。做题部分其实并不需要完全与第二轮分开，你可以先复习马原、毛概并完成相应的题目，等你复习史纲的时候就可以回过头来做第二遍马原的题目，当然也可以等第一轮完全结束的时候在开始第二遍做题。</p><p><strong>复习方法-《风中劲草》如何使用</strong>：风中劲草这本书的好处是内容简介、多种颜色标记、重点清晰，这本书用来第二轮复习，可以看完一章或者看完整个科目之后就刷第二遍题目。风中劲草需要前前后后看四遍左右，2-3天就可以完成一轮复习。</p><h3 id="五、三轮复习、多做模拟题的选择题部分"><a href="#五、三轮复习、多做模拟题的选择题部分" class="headerlink" title="五、三轮复习、多做模拟题的选择题部分"></a>五<strong>、三轮复习、多做模拟题的选择题部分</strong></h3><p>这个过程你需要做30-40套模拟题，大家不要以为30套模拟题很多，其实很少，因为每套模拟题只需要做选择题就可以了，基本一套也就二十多分钟就可以做完了。主要是多选部分，多选拿到高分，选择题才能拿到高分，想要拿75+，多选需要保证40+，这样把握更大；</p><p><strong>复习资料</strong>：<u>各位老师的模拟题+时政+近五年《真题》</u></p><p><strong>模拟题复习方法</strong>：大概在十一月下旬开始，就会有各种老师的模拟题出版，记住，只需要买《肖八》和《肖四》，其他的模拟题全部都用Anki背诵软件来做题，Anki背诵就类似于墨墨单词软件，采用的是艾宾浩斯遗忘曲线来辅助。我推荐使用Anki的原因并不是省钱，而是它可以帮助你短期内把这些试卷做三遍以上，而且花的时间会比你买试卷做题少很多。注意：《肖八》需要好好做，可以先只做选择题部分，做完一整套试卷就对答案，然后把每个选项中不懂得部分都翻书看一下；</p><p><img src="https://pic2.zhimg.com/80/v2-edc9e2ce1ab349c017d2244995535e95_1440w.jpg" alt="img"></p><p><strong>时政复习方法</strong>：时政选择题也占6分，但是根据20年的情况可以发现，时政选择题远远超过了6分，而且很多题目都会和时政结合起来出题。时政可以看看肖老师的《时政小册子》，微博上会有很多人分享自己整理的时政，以及各种考研公众号也会整理出来，<strong>你要广泛搜集这些他们整理的，就不用自己整理了，找来打印出来记住就可以了；</strong></p><p><strong>真题复习方法</strong>：真题是一定要做的，你最起码要做完最近五年的真题，分析一下命题人是如何设置陷阱，同时也要看一下分析题的答题方法，保证能够拿到最多的分数。</p><h3 id="六、四轮复习、冲刺分析题"><a href="#六、四轮复习、冲刺分析题" class="headerlink" title="六、四轮复习、冲刺分析题"></a><strong>六、四轮复习、冲刺分析题</strong></h3><p><strong>复习资料</strong>：<u>《肖四》（如果你跟的其他老师就选择其他老师的资料）</u></p><p><strong>复习方法</strong>：分析题占比50分，但是却是最容易拿到的，我身边的大多数人都是在最后15-20天开始准备分析题，分析题我用的是《肖四》，其实每个老师押题都是能够压中的，但是绝对很难做到全部压中题目，有的老师可能用50个题目去压考研的5个题，而有的老师却只用三十个题目就可以压中，肖老师在考研政治中的名气大家都有所耳闻，最后只用几页A4纸就可以搞定，性价比高，拿分也高。这个阶段，你狂背肖四就可以了，当然也可以背其他老师的押题卷，看个人喜好。</p><p>但是要记住，无论是哪个老师，都无法做到全部压中原题，所以在考场上遇到你没有背到的题目，就要从材料中去找答案，你翻看一下就会发现每一题的材料都会给整个A4纸那么多的内容，答案都会隐藏在材料中，要多去材料中找到答案，进行归纳总结。</p><hr><h3 id="补充与答疑"><a href="#补充与答疑" class="headerlink" title="补充与答疑"></a>补充与答疑</h3><h4 id="补充一：《1000题》怎么用"><a href="#补充一：《1000题》怎么用" class="headerlink" title="补充一：《1000题》怎么用"></a><strong>补充一：《1000题》怎么用</strong></h4><p>1、《1000题》需要做不止一遍，如果只用纸质版，想要做2遍花费的时间就无法想象，但是如果使用Anki背诵的话，做3-4遍所花费的时间都比纸质版2遍要少很多，所以我还是推荐第一遍做纸质版，之后就用Anki背诵神器来记忆；</p><p>2、第一遍做题方法：看完视频和基础知识之后就做本章节对应的《1000题》，做题的时候需要记住，一定要做错题标记，一是为了能够统计错题率，二是能够后面回头复习的时候看到自己做错的题目，方便复习；</p><p>第一遍做题错误率会很高，这个不要担心，毕竟是刚开始，后面会降下来的；</p><p>3、<strong>第二遍做《1000题》：这里是重点，一定要认真看。</strong></p><p>马原部分涉及到哲学，还是有一定难度，需要理解，我建议再把纸质版的《1000题》做第二遍，之后再使用Anki做马原的题目就会感觉到如鱼得水；</p><p>毛中特、史纲、思修第二遍就可以直接使用Anki做题，你会发现做一段时间之后你对知识的理解以及做题的速度都会优于身边人。</p><hr><p><strong>本文首发于我的知乎账号</strong>：上海地区政治77，考研政治复习指导 - 后羿的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/145769562">https://zhuanlan.zhihu.com/p/145769562</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 经验贴 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
